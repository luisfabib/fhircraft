{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to","text":"<p>Fhircraft is a Python package that dynamically generates Pydantic FHIR (Fast Healthcare Interoperability Resources) resource models from FHIR specifications, enabling comprehensive data structuring, validation, and typing within Python. It also offers a fully functional FHIRPath engine and code generation features to facilitate integration with other systems.</p> <p>Active development</p> <p>This package is under active development. Major and/or breaking changes are to be expected in future updates.</p>"},{"location":"#why-use-fhircraft","title":"Why use Fhircraft?","text":"<ul> <li> <p>Dynamic FHIR models \u2013 Generate Pydantic FHIR resource models dynamically from FHIR specification; get all FHIR's data structuring, validation and typing in a pythonic way.</p> </li> <li> <p>Simple FHIR validation \u2013 Perform complete parsing and validation of FHIR resources without leaving Python; avoid dealing with FHIR's often complex rules and constraints. </p> </li> <li> <p>Pydantic core \u2013 Profit from Pydantic's validation and (de)-serialization capabilities which have made it the most widely used data validation library for Python.     </p> </li> <li> <p>Code generator \u2013 Leverage the code generation features of Fhircraft to write static Pydantic/Python code that can be integrated into other systems. </p> </li> <li> <p>Pythonic FHIRPath \u2013 Fhircraft provides a fully functional, pythonic and compliant FHIRPath engine to easily work with FHIR resources without leaving Python.  </p> </li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Quickstart</li> <li>Installation</li> <li>User Guide<ul> <li>Pydantic FHIR models</li> <li>FHIRPath</li> </ul> </li> <li>API Reference<ul> <li>./reference/*</li> </ul> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>If you've got Python 3.8+ and <code>pip&gt;24.1</code> installed, installing <code>fhircraft</code> is as simple as:</p> <pre><code>pip install fhircraft\n</code></pre> <p>or install it from the source via:</p> <pre><code>pip install git+https://github.com/luisfabib/fhircraft.git\n</code></pre> <p>Fhircraft has a few dependencies:</p> <ul> <li><code>Pydantic</code>: Pydantic is the most widely used data validation library for Python.</li> <li><code>Python JSONPath Next-Generation</code>: A standard compliant implementation of JSONPath for Python.</li> </ul> <p>You might need to update <code>pip</code> (generally recommended)</p> <pre><code>python -m pip install --upgrade pip\n</code></pre>"},{"location":"installation/#development-installation","title":"Development installation","text":"<p>To install Fhircraft's development environment use </p> <pre><code>pip install -e .[dev, docs]\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Welcome to the Fhircraft Quickstart Guide! Here, you'll learn how to easily install Fhircraft, construct dynamic Pydantic FHIR models, validate FHIR payloads, and more. </p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>If you've got Python 3.8+ and <code>pip</code> installed, installing <code>fhircraft</code> is as simple as:</p> <pre><code>pip install fhircraft\n</code></pre> <p>For more details, see the Installation instructions.</p>"},{"location":"quickstart/#features","title":"Features","text":"<p>Explore some of the key features of Fhircraft and learn how to access them quickly.</p>"},{"location":"quickstart/#constructing-dynamic-pydantic-fhir-models","title":"Constructing dynamic Pydantic FHIR models","text":"<p>Easily generate a Pydantic model representation for a FHIR resource by using the <code>construct_resource_model</code> function. This function automatically creates a model based on the structure definition of the specified resource or profile. You can provide the resource's definition either via its canonical URL or from a local file.</p> <p>For instance, to generate a Pydantic model for the core FHIR <code>Patient</code> resource:</p> Canonical URLLocal file <pre><code>from fhircraft.fhir.resources.factory import construct_resource_model\npatient_model = construct_resource_model(\n    canonical_url='http://hl7.org/fhir/StructureDefinition/Patient'\n)\n</code></pre> <p>HTTP Requests</p> <p>Specifying a FHIR resource via its canonical URL requires retrieving the resource details through HTTP requests. This operation requires an active internet connection, and data will be downloaded from the third-party domain associated with the resource. Ensure that internet access is available, and be aware that data will be obtained from external sources.</p> <pre><code>from fhircraft.fhir.resources.factory import construct_resource_model\nfrom fhicraft.utils import load_file\npatient_model = construct_resource_model(\n    structure_definition=load_file('FHIR_StructureDefinition_Patient.json')\n)\n</code></pre> <p>Once constructed, the model leverages the full capabilities of  Pydantic's features while also adhering to all FHIR structural and validation constraints, which are implemented as Pydantic validators.</p>"},{"location":"quickstart/#generating-pydantic-fhir-models-source-code","title":"Generating Pydantic FHIR models' source code","text":"<p>Fhircraft allows you to generate reusable source code for Pydantic FHIR models. By using the <code>generate_resource_model_code</code> function, you can obtain the source code (as a string) that defines the FHIR Pydantic model. This can be particularly useful for integrating the model into other projects or sharing it across different applications.</p> <pre><code>from fhircraft.fhir.resources.generator import generate_resource_model_code\nsource_code = generate_resource_model_code(patient_model)\n</code></pre> <p>You can save the generated source code and reuse it as needed. Keep in mind that the code requires Fhircraft and its dependencies to be installed in order to function properly.</p>"},{"location":"quickstart/#validating-fhir-payloads","title":"Validating FHIR payloads","text":"<p>The generated Pydantic models can be used to validate FHIR payloads, ensuring that they conform to the structure and constraints of the specified resource or profile.</p> <pre><code>from fhicraft.utils import load_file\ndata = load_file('my_fhir_patient.json')\nmy_patient = patient_model.model_validate(data)\n</code></pre> <p>If the input data does not conform to the expected FHIR resource or profile, the Pydantic model will raise a <code>ValidationError</code>. If no error is raised, the FHIR payload is valid and successfully loaded into the model.</p>"},{"location":"quickstart/#model-manipulation-using-fhirpath","title":"Model manipulation using FHIRPath","text":"<p>Fhircraft includes a powerful FHIRPath engine that enables you to query and manipulate FHIR resources using FHIRPath expressions in a Pythonic way. You can specify the FHIRPath expression as a string in the standard notation to interact with the resource efficiently. This feature allows for complex queries and updates, enhancing your ability to work with FHIR data programmatically.</p> Get valueUpdate value <pre><code>from fhicraft.fhir.path import fhirpath\npatient_surname = my_patient.get_fhirpath('Patient.name.surname')\n</code></pre> <pre><code>from fhicraft.fhir.path import fhirpath\npatient_surname = my_patient.replace_fhirpath('Patient.name.surname', 'John')\n</code></pre>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<p>See the  User Guide for more complete documentation of all of Fhircraft's features.</p> <p>For more in-depth information on Pydantic, explore the extensive   Pydantic documentation.</p> <p>If you need assistance with Fhircraft, you can seek help through GitHub by participating in the  GitHub Discussions or by opening an issue in the  GitHub Issues section.</p>"},{"location":"reference/fhircraft/utils/","title":"Utils","text":""},{"location":"reference/fhircraft/utils/#fhircraft.utils.capitalize","title":"<code>capitalize(string)</code>","text":"<p>Capitalize the first letter of a given string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The input string to capitalize.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string with the first letter capitalized.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def capitalize(string: str) -&gt; str:\n    '''\n    Capitalize the first letter of a given string.\n\n    Parameters:\n        string (str): The input string to capitalize.\n\n    Returns:\n        str: The string with the first letter capitalized.\n    '''    \n    return string[0].upper() + string[1:]\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.contains_list_type","title":"<code>contains_list_type(tp)</code>","text":"<p>Recursively check if List is anywhere in the variable's typing.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def contains_list_type(tp: Any) -&gt; bool:\n    \"\"\"Recursively check if List is anywhere in the variable's typing.\"\"\"   \n    # Check if the current type is a List\n    if get_origin(tp) in [List, list]:\n        return True\n\n    # Recursively check the type arguments\n    for arg in get_args(tp):\n        if contains_list_type(arg):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.contains_only_none","title":"<code>contains_only_none(d)</code>","text":"<p>Check if the input contains only None values recursively.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Any</code> <p>The input dictionary or list to check for only None values.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the input contains only None values, False otherwise.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def contains_only_none(d: Any) -&gt; bool:\n    \"\"\"\n    Check if the input contains only None values recursively.\n\n    Args:\n        d (Any): The input dictionary or list to check for only None values.\n\n    Returns:\n        result (bool): True if the input contains only None values, False otherwise.\n    \"\"\"    \n    if isinstance(d, dict):\n        return all(contains_only_none(v) for v in d.values())\n    elif isinstance(d, list):\n        return all(contains_only_none(item) for item in d)\n    else:\n        return d is None\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.ensure_list","title":"<code>ensure_list(variable)</code>","text":"<p>Ensure that the input variable is converted into a list if it is not already an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>any</code> <p>The input variable that needs to be converted into a list if it is not already an iterable.</p> required <p>Returns:</p> Name Type Description <code>variable</code> <code>list</code> <p>The input variable converted into a list, or the input variable itself if it was already an iterable.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def ensure_list(variable: Any) -&gt; list:\n    \"\"\"\n    Ensure that the input variable is converted into a list if it is not already an iterable.\n\n    Args:\n        variable (any): The input variable that needs to be converted into a list if it is not already an iterable.\n\n    Returns:\n        variable (list): The input variable converted into a list, or the input variable itself if it was already an iterable.\n    \"\"\"\n    if not isinstance(variable, list):\n        if isinstance(variable, tuple):\n            return list(variable)\n        return [variable]\n    return variable\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.get_dict_paths","title":"<code>get_dict_paths(nested_dict, prefix='')</code>","text":"<p>Get all paths in a nested dictionary with their corresponding values.</p> <p>Parameters:</p> Name Type Description Default <code>nested_dict</code> <code>Union[Dict[str, Any], List[Dict[str, Any]]]</code> <p>The nested dictionary or list of dictionaries to extract paths from.</p> required <code>prefix</code> <code>str</code> <p>The prefix to be added to the paths (default is '').</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing all paths in the nested dictionary with their corresponding values.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def get_dict_paths(nested_dict: Union[Dict[str, Any], List[Dict[str, Any]]], prefix: str = '') -&gt; Dict[str, Any]:\n    \"\"\"\n    Get all paths in a nested dictionary with their corresponding values.\n\n    Args:\n        nested_dict (Union[Dict[str, Any], List[Dict[str, Any]]]): The nested dictionary or list of dictionaries to extract paths from.\n        prefix (str): The prefix to be added to the paths (default is '').\n\n    Returns:\n        Dict[str, Any]: A dictionary containing all paths in the nested dictionary with their corresponding values.\n    \"\"\"\n    paths = {}\n    if isinstance(nested_dict, dict):\n        for key, value in nested_dict.items():\n            new_prefix = f\"{prefix}.{key}\" if prefix else key\n            if isinstance(value, dict):\n                paths.update(get_dict_paths(value, new_prefix))\n            elif isinstance(value, list):\n                for i, item in enumerate(value):\n                    list_prefix = f\"{new_prefix}[{i}]\"\n                    if isinstance(item, dict):\n                        paths.update(get_dict_paths(item, list_prefix))\n            else:\n                if value is not None:\n                    paths[new_prefix] = value\n    elif isinstance(nested_dict, list):\n        for i, item in enumerate(nested_dict):\n            list_prefix = f\"{prefix}[{i}]\"\n            if isinstance(item, dict):\n                paths.update(get_dict_paths(item, list_prefix))\n    return paths\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.is_url","title":"<code>is_url(string)</code>","text":"<p>Check if the input string is a valid URL.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The input string to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the input string is a valid URL, False otherwise.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def is_url(string: str) -&gt; bool:\n    \"\"\"Check if the input string is a valid URL.\n\n    Args:\n        string (str): The input string to check.\n\n    Returns:\n        bool: True if the input string is a valid URL, False otherwise.\n    \"\"\"    \n    return re.match(URL_PATTERNS, string) is not None\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.load_env_variables","title":"<code>load_env_variables(file_path=None)</code>","text":"<p>Loads environment variables from a .env file into a dictionary without changing the global environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Optional[str]</code> <p>Optional path to the .env file. If not provided, it looks for a .env file in the current directory.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>vars</code> <code>dict</code> <p>A dictionary containing the environment variables from the .env file.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def load_env_variables(file_path: Optional[str]=None) -&gt; dict:\n    \"\"\"\n    Loads environment variables from a .env file into a dictionary without changing the global environment variables.\n\n    Args:\n        file_path (Optional[str]): Optional path to the .env file. If not provided, it looks for a .env file in the current directory.\n\n    Returns: \n        vars (dict): A dictionary containing the environment variables from the .env file.\n    \"\"\"\n    # Determine the file path\n    env_file = file_path if file_path else '.env'\n\n    # Load the .env file into a dictionary\n    env_vars = dotenv_values(env_file)\n\n    return env_vars\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.load_file","title":"<code>load_file(file_path)</code>","text":"<p>Load data from a file based on its extension.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to load.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>dict</code> <p>The data loaded from the file as a dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file content is not a dictionary (for YAML files).</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def load_file(file_path: str) -&gt; Dict:\n    \"\"\"\n    Load data from a file based on its extension.\n\n    Args:\n        file_path (str): The path to the file to load.\n\n    Returns:\n        data (dict): The data loaded from the file as a dictionary.\n\n    Raises:\n        ValueError: If the file content is not a dictionary (for YAML files).\n    \"\"\"    \n    with open(file_path, 'r') as file:\n        file_extension = os.path.splitext(file_path)[1]\n        if file_extension == '.yaml' or file_extension == '.yml':\n            data = yaml.safe_load(file)\n            if not isinstance(data, dict):\n                raise ValueError(\"Invalid file content. File content must be a dictionary.\")\n            return data\n        elif file_extension == '.json':\n            return json.load(file)\n        else:\n            raise ValueError(\"Unsupported file format. Please provide a .yaml, .yml, or .json file.\")\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.load_url","title":"<code>load_url(url)</code>","text":"<p>Load content from a URL and parse it based on the content type (YAML or JSON).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to load content from.</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Union[Dict, List, Any]: Parsed content from the URL. Can be a dictionary, list, or any other valid JSON/YAML data type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL format is invalid or the content type is not supported.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def load_url(url: str) -&gt; Dict:\n    \"\"\"\n    Load content from a URL and parse it based on the content type (YAML or JSON).\n\n    Args:\n        url (str): The URL to load content from.\n\n    Returns:\n        Union[Dict, List, Any]: Parsed content from the URL. Can be a dictionary, list, or any other valid JSON/YAML data type.\n\n    Raises:\n        ValueError: If the URL format is invalid or the content type is not supported.\n    \"\"\"    \n    # Validate the URL format\n    if not url.startswith('http://') and not url.startswith('https://'):\n        raise ValueError(\"Invalid URL format. Please provide a valid URL starting with 'http://' or 'https://'.\")\n\n    # Add a timeout to the requests.get call\n    # Configure proxy if needed\n    settings = load_env_variables()\n    proxies = {\n        'https': settings.get('PROXY_URL_HTTPS'), \n        'http': settings.get('PROXY_URL_HTTP')\n    } if settings.get('PROXY_URL_HTTPS') or settings.get('PROXY_URL_HTTP') else None\n    # Download the StructureDefinition JSON            \n    response = requests.get(url, proxies=proxies, verify=settings.get('CERTIFICATE_BUNDLE_PATH'), timeout=10)\n\n    response.raise_for_status()\n    content_type = response.headers['Content-Type']\n\n    # Use content_type.lower() to make the content type check case-insensitive\n    if 'yaml' in content_type.lower():\n        try:\n            return yaml.safe_load(response.text)\n        except yaml.YAMLError as e:\n            raise ValueError(f\"Error loading YAML: {e}\")\n    elif 'json' in content_type.lower():\n        try:\n            return response.json()\n        except json.JSONDecodeError as e:\n            raise ValueError(f\"Error loading JSON: {e}\")\n    else:\n        raise ValueError(\"Unsupported content type. Please provide a URL that returns .yaml, .yml, or .json content.\")\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.merge_dicts","title":"<code>merge_dicts(dict1, dict2)</code>","text":"<p>Merge two dictionaries recursively, merging lists element by element and dictionaries at the same index.</p> <p>If a key exists in both dictionaries, the values are merged based on their types. If a key exists only in one dictionary, it is added to the merged dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict1</code> <code>dict</code> <p>The first dictionary to merge.</p> required <code>dict2</code> <code>dict</code> <p>The second dictionary to merge.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The merged dictionary.</p> Example <p>dict1 = {'a': 1, 'b': {'c': 2, 'd': [3, 4]}, 'e': [5, 6]} dict2 = {'b': {'c': 3, 'd': [4, 5]}, 'e': [6, 7], 'f': 8} merge_dicts(dict1, dict2) {'a': 1, 'b': {'c': 3, 'd': [3, 4, 5]}, 'e': [5, 6, 7], 'f': 8}</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def merge_dicts(dict1: dict, dict2: dict) -&gt; dict:\n    \"\"\"\n    Merge two dictionaries recursively, merging lists element by element and dictionaries at the same index.\n\n    If a key exists in both dictionaries, the values are merged based on their types. If a key exists only in one dictionary, it is added to the merged dictionary.\n\n    Args:\n        dict1 (dict): The first dictionary to merge.\n        dict2 (dict): The second dictionary to merge.\n\n    Returns:\n        dict: The merged dictionary.\n\n    Example:\n        &gt;&gt;&gt; dict1 = {'a': 1, 'b': {'c': 2, 'd': [3, 4]}, 'e': [5, 6]}\n        &gt;&gt;&gt; dict2 = {'b': {'c': 3, 'd': [4, 5]}, 'e': [6, 7], 'f': 8}\n        &gt;&gt;&gt; merge_dicts(dict1, dict2)\n        {'a': 1, 'b': {'c': 3, 'd': [3, 4, 5]}, 'e': [5, 6, 7], 'f': 8}\n    \"\"\"\n    def merge_lists(list1, list2):\n        # Merge two lists element by element\n        merged_list = []\n        for idx in range(max(len(list1), len(list2))):\n            if idx &lt; len(list1) and idx &lt; len(list2):\n                if isinstance(list1[idx], dict) and isinstance(list2[idx], dict):\n                    # Merge dictionaries at the same index\n                    merged_list.append(merge_dicts(list1[idx], list2[idx]))\n                else:\n                    # If they are not dictionaries, choose the element from the first list\n                    merged_list.append(list1[idx])\n            elif idx &lt; len(list1):\n                merged_list.append(list1[idx])\n            else:\n                merged_list.append(list2[idx])\n        return merged_list\n    merged_dict = dict1.copy()\n    for key, value in dict2.items():\n        if key in merged_dict:\n            if isinstance(merged_dict[key], list) and isinstance(value, list):\n                merged_dict[key] = merge_lists(merged_dict[key], value)\n            elif isinstance(merged_dict[key], dict) and isinstance(value, dict):\n                merged_dict[key] = merge_dicts(merged_dict[key], value)\n            else:\n                merged_dict[key] = value\n        else:\n            merged_dict[key] = value\n    return merged_dict\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.remove_none_dicts","title":"<code>remove_none_dicts(d)</code>","text":"<p>Remove any dictionaries with all values being None from the input dictionary recursively.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Union[Dict[str, Any], List[Any], Any]</code> <p>The input dictionary or list to remove None values from.</p> required <p>Returns:</p> Type Description <code>Union[Dict[str, Any], List[Any], Any]</code> <p>Union[Dict[str, Any], List[Any], Any]: The dictionary or list with None values removed.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def remove_none_dicts(d: Union[Dict[str, Any], List[Any], Any]) -&gt; Union[Dict[str, Any], List[Any], Any]:\n    \"\"\"\n    Remove any dictionaries with all values being None from the input dictionary recursively.\n\n    Args:\n        d (Union[Dict[str, Any], List[Any], Any]): The input dictionary or list to remove None values from.\n\n    Returns:\n        Union[Dict[str, Any], List[Any], Any]: The dictionary or list with None values removed.\n    \"\"\"\n    if not isinstance(d, dict):\n        return d    \n    new_dict = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = remove_none_dicts(v)\n            if not contains_only_none(v):\n                new_dict[k] = v\n        elif isinstance(v, list):\n            new_list = []\n            for item in v:\n                if isinstance(item, dict):\n                    item = remove_none_dicts(item)\n                    if not contains_only_none(item):\n                        new_list.append(item)\n                elif item is not None:\n                    new_list.append(item)\n            if new_list:\n                new_dict[k] = new_list\n        elif v is not None:\n            new_dict[k] = v\n    return new_dict\n</code></pre>"},{"location":"reference/fhircraft/utils/#fhircraft.utils.replace_nth","title":"<code>replace_nth(string, sub, wanted, n)</code>","text":"<p>Replace the nth occurrence of a substring in a string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The original string.</p> required <code>sub</code> <code>str</code> <p>The substring to be replaced.</p> required <code>wanted</code> <code>str</code> <p>The new substring to replace with.</p> required <code>n</code> <code>int</code> <p>The occurrence number of the substring to replace.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>The updated string after replacing the nth occurrence of the substring.</p> Source code in <code>fhircraft/utils.py</code> <pre><code>def replace_nth(string, sub, wanted, n):\n    \"\"\"\n    Replace the nth occurrence of a substring in a string.\n\n    Args:\n        string (str): The original string.\n        sub (str): The substring to be replaced.\n        wanted (str): The new substring to replace with.\n        n (int): The occurrence number of the substring to replace.\n\n    Returns:\n        string (str): The updated string after replacing the nth occurrence of the substring.\n    \"\"\"    \n    pattern = re.compile(sub)\n    where = [m for m in pattern.finditer(string)][n-1]\n    before = string[:where.start()]\n    after = string[where.end():]\n    newString = before + wanted + after\n    return newString\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/","title":"Lexer","text":""},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer","title":"<code>FhirPathLexer</code>","text":"<p>A Lexical analyzer for JsonPath.</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>class FhirPathLexer:\n    '''\n    A Lexical analyzer for JsonPath.\n\n    '''\n    def __init__(self, debug=False):\n        self.debug = debug\n        if self.__doc__ is None:\n            raise FhirPathLexerError('Docstrings have been removed by design of PLY.')\n\n    def tokenize(self, string):\n        '''\n        Maps a string to an iterator over tokens. In other words: [char] -&gt; [token]\n        '''\n\n        new_lexer = ply.lex.lex(module=self)\n        new_lexer.latest_newline = 0\n        new_lexer.string_value = None\n        new_lexer.input(string)\n\n        while True:\n            t = new_lexer.token()\n            if t is None:\n                break\n            t.col = t.lexpos - new_lexer.latest_newline\n            yield t\n\n        if new_lexer.string_value is not None:\n            raise FhirPathLexerError('Unexpected EOF in string literal or identifier')\n\n    # ============== PLY Lexer specification ==================\n    #\n    # Tokenizer for FHIRpath\n    #\n    # =========================================================\n\n    # Symbols (http://hl7.org/fhirpath/N1/#symbols)\n    # -------------------------------------------------------------------------------\n    # Symbols provide structure to the language and allow symbolic invocation of common \n    # operators such as addition. FHIRPath defines the following symbols:\n    literals = [\n        '.', ',', '[', ']', '(', ')', '{', '}', '+', '-', '*', '|', '/', '&amp;'\n    ]\n\n    reserved_words = { \n\n        # operators (http://hl7.org/fhirpath/N1/#operator-precedence)\n        # -------------------------------------------------------------------------------\n        **{\n            'div': 'DIV', \n            'mod': 'MOD',\n            'is': 'IS',\n            'as': 'AS',\n            'in': 'IN',\n            'contains' : 'CONTAINS',\n            'and': 'AND',\n            'xor': 'XOR',\n            'or': 'OR',\n            'implies': 'IMPLIES',\n        },   \n        **{operator: 'INEQUALITY_OPERATOR' for operator in ['&gt;','&lt;','&gt;=', '&lt;=']},\n        **{operator: 'EQUALITY_OPERATOR' for operator in ['=','~','!=', '!~']},\n        # Boolean (http://hl7.org/fhirpath/N1/#boolean)\n        # -------------------------------------------------------------------------------\n        **{operator: 'BOOLEAN' for operator in ['true','false']},  \n\n        # Calendar Duration (http://hl7.org/fhirpath/N1/#boolean)\n        # -------------------------------------------------------------------------------\n        # For time-valued quantities, in addition to the definite duration UCUM units,\n        # FHIRPath defines calendar duration keywords for calendar duration units\n        **{operator: 'CALENDAR_DURATION' for operator in [\n            'week','weeks','month','months','year','years','day','days',\n            'hour','hours','minute','minutes','second','seconds','miliseond','miliseconds'\n        ]},   \n\n        #  FHIRPath Root Names (http://hl7.org/fhirpath/N1/#path-selection)\n        # -------------------------------------------------------------------------------       \n        # The path may start with the type of the root node            \n        **{resource: 'ROOT_NODE' for resource in [\n            \"Account\", \"ActivityDefinition\", \"AdverseEvent\", \"AllergyIntolerance\", \"Appointment\", \"AppointmentResponse\",\n            \"AuditEvent\", \"Basic\", \"Binary\", \"BiologicallyDerivedProduct\", \"BodyStructure\", \"Bundle\", \"CapabilityStatement\",\n            \"CarePlan\", \"CareTeam\", \"CatalogEntry\", \"ChargeItem\", \"ChargeItemDefinition\", \"Claim\", \"ClaimResponse\", \"Extension\",\n            \"ClinicalImpression\", \"CodeSystem\", \"Communication\", \"CommunicationRequest\", \"CompartmentDefinition\", \"Composition\",\n            \"ConceptMap\",\"Condition\", \"Consent\", \"Contract\", \"Coverage\", \"CoverageEligibilityRequest\", \"CoverageEligibilityResponse\",\n            \"DetectedIssue\", \"Device\", \"DeviceDefinition\", \"DeviceMetric\", \"DeviceRequest\", \"DeviceUseStatement\", \"DiagnosticReport\",\n            \"DocumentManifest\", \"DocumentReference\", \"Encounter\", \"Endpoint\", \"EnrollmentRequest\", \"EnrollmentResponse\", \"EpisodeOfCare\",\n            \"EventDefinition\", \"Evidence\", \"EvidenceReport\", \"EvidenceVariable\", \"ExampleScenario\", \"ExplanationOfBenefit\", \"FamilyMemberHistory\",\n            \"Flag\", \"Goal\", \"GraphDefinition\", \"Group\", \"GuidanceResponse\", \"HealthcareService\", \"ImagingStudy\", \"Immunization\",\n            \"ImmunizationEvaluation\", \"ImmunizationRecommendation\", \"ImplementationGuide\", \"InsurancePlan\", \"Invoice\", \"Library\",\"Linkage\",\n            \"List\", \"Location\", \"Measure\", \"MeasureReport\", \"Media\", \"Medication\", \"MedicationAdministration\", \"MedicationDispense\",\n            \"MedicationKnowledge\", \"MedicationRequest\", \"MedicationStatement\", \"MedicinalProduct\", \"MedicinalProductAuthorization\",\n            \"MedicinalProductContraindication\", \"MedicinalProductIndication\", \"MedicinalProductIngredient\", \"MedicinalProductInteraction\",\n            \"MedicinalProductManufactured\", \"MedicinalProductPackaged\", \"MedicinalProductPharmaceutical\", \"MedicinalProductUndesirableEffect\",\n            \"MessageDefinition\", \"MessageHeader\", \"MolecularSequence\", \"NamingSystem\", \"NutritionOrder\", \"Observation\", \"ObservationDefinition\", \"OperationDefinition\",\n            \"OperationOutcome\", \"Organization\", \"OrganizationAffiliation\", \"Patient\", \"PaymentNotice\", \"PaymentReconciliation\", \"Person\",\n            \"PlanDefinition\", \"Practitioner\", \"PractitionerRole\", \"Procedure\", \"Provenance\", \"Questionnaire\", \"QuestionnaireResponse\",\n            \"RelatedPerson\", \"RequestGroup\", \"ResearchDefinition\", \"ResearchElementDefinition\", \"ResearchStudy\", \"ResearchSubject\", \"RiskAssessment\",\n            \"RiskEvidenceSynthesis\", \"Schedule\", \"SearchParameter\", \"ServiceRequest\", \"Slot\", \"Specimen\", \"SpecimenDefinition\", \"StructureDefinition\",\n            \"StructureMap\", \"Subscription\", \"Substance\", \"SubstanceNucleicAcid\", \"SubstancePolymer\", \"SubstanceProtein\", \"SubstanceReferenceInformation\", \"SubstanceSourceMaterial\",\n            \"SubstanceSpecification\", \"SupplyDelivery\", \"SupplyRequest\", \"Task\", \"TerminologyCapabilities\", \"TestReport\", \"TestScript\",\n            \"ValueSet\", \"VerificationResult\", \"VisionPrescription\"\n        ]}                  \n    }\n\n    # List of token names\n    tokens = list(set(reserved_words.values())) + [\n        'IDENTIFIER',\n        'INTEGER',\n        'DECIMAL',\n        'DATE',\n        'TIME',\n        'DATETIME',\n        'CHOICE_ELEMENT',\n        'STRING',\n        'CONTEXTUAL_OPERATOR',\n        'ENVIRONMENTAL_VARIABLE',\n    ]\n\n    def t_ignore_WHITESPACE(self, t):\n        # Whitespace (http://hl7.org/fhirpath/N1/#whitespace)\n        # -------------------------------------------------------------------------------\n        # FHIRPath defines tab (\\t), space ( ), line feed (\\n) and carriage return (\\r) as whitespace,\n        # meaning they are only used to separate other tokens within the language. Any number\n        # of whitespace characters can appear, and the language does not use whitespace for \n        # anything other than delimiting tokens.\n        r'[\\s]'\n        if t.value=='\\n':\n            t.lexer.lineno += 1\n            t.lexer.latest_newline = t.lexpos\n\n    def t_ignore_COMMENT(self, t):\n        # Comments (http://hl7.org/fhirpath/N1/#comments)\n        # -------------------------------------------------------------------------------\n        # FHIRPath defines two styles of comments, single-line, and multi-line. \n        # - A single-line comment consists of two forward slashes, followed by any \n        #   text up to the end of the line\n        # - To begin a multi-line comment, the typical forward slash-asterisk token\n        #   is used. The comment is closed with an asterisk-forward slash, and everything enclosed is ignored\n        r'\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)'\n        for substring in ['//','/*','*/']:\n            t.value = t.value.replace(substring,'')\n        t.value = t.value.strip()\n\n    def t_CHOICE_ELEMENT(self, t):\n        r'(?:\\`[a-zA-Z][a-zA-Z0-9\\-][^\\`]*\\[x\\]\\`)|(?:(?:_|[a-zA-Z])[a-zA-Z0-9_]*\\[x\\])'\n        t.value = t.value.replace('[x]','')\n        return t\n\n    def t_ENVIRONMENTAL_VARIABLE(self, t):\n        # Environmental variable (http://hl7.org/fhirpath/N1/#environment-variables)\n        # -------------------------------------------------------------------------------\n        # A token introduced by a % refers to a value that is passed into the evaluation \n        # engine by the calling environment. \n        r'\\%(\\w*)?'\n        return t\n\n    def t_CONTEXTUAL_OPERATOR(self, t):\n        # Contextual Operators (http://hl7.org/fhirpath/N1/#functions)\n        # -------------------------------------------------------------------------------\n        # Special elements within a funciton that refere to the input collection under evalution\n        r'\\$(\\w*)?'\n        return t\n\n    def t_INEQUALITY_OPERATOR(self, t):\n        r'&gt;=|&lt;=|&gt;|&lt;'\n        return t\n\n    def t_EQUALITY_OPERATOR(self, t):\n        r'=|!=|~|!~'\n        return t\n\n    def t_DATETIME(self, t):\n        # DateTime (http://hl7.org/fhirpath/N1/#datetime)\n        # -------------------------------------------------------------------------------\n        # The Date type represents date and partial date values.\n        # - The date literal is a subset of [ISO8601]:\n        # - A date being with a @\n        # - It uses the format YYYY-MM-DD format, though month and day parts are optional\n        # - Months must be present if a day is present\n        # The Time type represents time-of-day and partial time-of-day values.\n        # - A time begins with a @T\n        # - It uses the Thh:mm:ss.fff format\n        r'@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?T(?:\\d{2}(?:\\:\\d{2}(?:\\:\\d{2}(?:.\\d{3}(?:[\\+|\\-]\\d{2}(?:\\:\\d{2})?)?)?)?)?)?'\n        return t    \n\n    def t_DATE(self, t):\n        # Date (http://hl7.org/fhirpath/N1/#date)\n        # -------------------------------------------------------------------------------\n        # The Date type represents date and partial date values.\n        # - The date literal is a subset of [ISO8601]:\n        # - A date being with a @\n        # - It uses the format YYYY-MM-DD format, though month and day parts are optional\n        # - Months must be present if a day is present\n        r'@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?'\n        return t\n\n    def t_TIME(self, t):\n        # Time (http://hl7.org/fhirpath/N1/#time)\n        # -------------------------------------------------------------------------------\n        # The Time type represents time-of-day and partial time-of-day values.\n        # - A time begins with a @T\n        # - It uses the Thh:mm:ss.fff format\n        r'\\@T\\d{2}(?:\\:\\d{2}(?:\\:\\d{2}(?:\\.\\d{3}(?:[+|-]\\d{2}(?:\\:\\d{2})?)?)?)?)?'\n        return t\n\n    def t_NUMBER(self, t):\n        r'-?\\d+(\\.\\d+)?'\n        if '.' in t.value:\n            # Decimal (http://hl7.org/fhirpath/N1/#decimal)\n            # -------------------------------------------------------------------------------\n            t.value = float(t.value) \n            t.type = 'DECIMAL'\n        else:\n            # Integer (http://hl7.org/fhirpath/N1/#integer)\n            # -------------------------------------------------------------------------------\n            t.value = int(t.value)\n            t.type = 'INTEGER'\n        return t\n\n    def t_STRING(self, t):\n        # String (http://hl7.org/fhirpath/N1/#string)\n        # -------------------------------------------------------------------------------\n        # The String type represents string values up to 231-1 characters in length. String \n        # literals are surrounded by single-quotes and may use \\-escapes to escape quotes \n        # and represent Unicode characters \n        r'\\'([^\\']*)?\\''\n        t.value = t.value.strip('\\'')\n        return t\n\n    def t_IDENTIFIER(self, t):\n        # Identifiers (http://hl7.org/fhirpath/N1/#identifiers)\n        # -------------------------------------------------------------------------------\n        # Identifiers are used as labels to allow expressions to reference elements such \n        # as model types and properties. FHIRPath supports two types of identifiers, simple\n        # and delimited.\n        # - A simple identifier is any alphabetical character or an underscore, followed by \n        #   any number of alpha-numeric characters or underscores\n        # - A delimited identifier is any sequence of characters enclosed in backticks ( ` ):\n        r'(?:\\`[a-zA-Z][a-zA-Z0-9\\-][^\\`]*\\`)|(?:(?:_|[a-zA-Z])[a-zA-Z0-9_]*)'\n        if t.value.startswith('`') and t.value.endswith('`'):        \n            t.value = t.value.strip('`') \n            t.type = 'IDENTIFIER'\n        else:\n            t.type = self.reserved_words.get(t.value, 'IDENTIFIER')\n        return t\n\n    def t_error_invalid_function(self, t):\n        r'[a-zA-Z][a-zA-Z_0-9]*\\((?:.*)?\\)'\n        t.value = t.value.split('(')[0]\n        pos = t.lexpos - t.lexer.latest_newline\n        raise FhirPathLexerError(f'FHIRPath lexer error at {t.lexer.lineno}:{pos} - Invalid function: \"{t.value}\".\\n{_underline_error_in_fhir_path(t.lexer.lexdata, t.value, pos)}')\n\n    def t_error_doublequote_string(self, t):\n        r'\\\"([^\\\"]*)?\\\"'\n        pos = t.lexpos - t.lexer.latest_newline\n        raise FhirPathLexerError(f'FHIRPath lexer error at {t.lexer.lineno}:{pos} - Double-quoted strings are not valid in FHIRPath: {t.value}\\n{_underline_error_in_fhir_path(t.lexer.lexdata, t.value, pos)}')\n\n    def t_error(self, t):\n        raise FhirPathLexerError(f'FHIRPath lexer error at {t.lexer.lineno}:{t.lexpos - t.lexer.latest_newline} - Unexpected character: {t.value[0]}')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_CHOICE_ELEMENT","title":"<code>t_CHOICE_ELEMENT(t)</code>","text":"<p>(?:`[a-zA-Z][a-zA-Z0-9-][^`][x]`)|(?:(?:|[a-zA-Z])[a-zA-Z0-9][x])</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_CHOICE_ELEMENT(self, t):\n    r'(?:\\`[a-zA-Z][a-zA-Z0-9\\-][^\\`]*\\[x\\]\\`)|(?:(?:_|[a-zA-Z])[a-zA-Z0-9_]*\\[x\\])'\n    t.value = t.value.replace('[x]','')\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_CONTEXTUAL_OPERATOR","title":"<code>t_CONTEXTUAL_OPERATOR(t)</code>","text":"<p>\\$(\\w*)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_CONTEXTUAL_OPERATOR(self, t):\n    # Contextual Operators (http://hl7.org/fhirpath/N1/#functions)\n    # -------------------------------------------------------------------------------\n    # Special elements within a funciton that refere to the input collection under evalution\n    r'\\$(\\w*)?'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_DATE","title":"<code>t_DATE(t)</code>","text":"<p>@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_DATE(self, t):\n    # Date (http://hl7.org/fhirpath/N1/#date)\n    # -------------------------------------------------------------------------------\n    # The Date type represents date and partial date values.\n    # - The date literal is a subset of [ISO8601]:\n    # - A date being with a @\n    # - It uses the format YYYY-MM-DD format, though month and day parts are optional\n    # - Months must be present if a day is present\n    r'@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_DATETIME","title":"<code>t_DATETIME(t)</code>","text":"<p>@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?T(?:\\d{2}(?::\\d{2}(?::\\d{2}(?:.\\d{3}(?:[+|-]\\d{2}(?::\\d{2})?)?)?)?)?)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_DATETIME(self, t):\n    # DateTime (http://hl7.org/fhirpath/N1/#datetime)\n    # -------------------------------------------------------------------------------\n    # The Date type represents date and partial date values.\n    # - The date literal is a subset of [ISO8601]:\n    # - A date being with a @\n    # - It uses the format YYYY-MM-DD format, though month and day parts are optional\n    # - Months must be present if a day is present\n    # The Time type represents time-of-day and partial time-of-day values.\n    # - A time begins with a @T\n    # - It uses the Thh:mm:ss.fff format\n    r'@\\d{4}(?:-\\d{2}(?:-\\d{2})?)?T(?:\\d{2}(?:\\:\\d{2}(?:\\:\\d{2}(?:.\\d{3}(?:[\\+|\\-]\\d{2}(?:\\:\\d{2})?)?)?)?)?)?'\n    return t    \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_ENVIRONMENTAL_VARIABLE","title":"<code>t_ENVIRONMENTAL_VARIABLE(t)</code>","text":"<p>\\%(\\w*)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_ENVIRONMENTAL_VARIABLE(self, t):\n    # Environmental variable (http://hl7.org/fhirpath/N1/#environment-variables)\n    # -------------------------------------------------------------------------------\n    # A token introduced by a % refers to a value that is passed into the evaluation \n    # engine by the calling environment. \n    r'\\%(\\w*)?'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_EQUALITY_OPERATOR","title":"<code>t_EQUALITY_OPERATOR(t)</code>","text":"<p>=|!=|~|!~</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_EQUALITY_OPERATOR(self, t):\n    r'=|!=|~|!~'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_IDENTIFIER","title":"<code>t_IDENTIFIER(t)</code>","text":"<p>(?:`[a-zA-Z][a-zA-Z0-9-][^`]`)|(?:(?:|[a-zA-Z])[a-zA-Z0-9])</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_IDENTIFIER(self, t):\n    # Identifiers (http://hl7.org/fhirpath/N1/#identifiers)\n    # -------------------------------------------------------------------------------\n    # Identifiers are used as labels to allow expressions to reference elements such \n    # as model types and properties. FHIRPath supports two types of identifiers, simple\n    # and delimited.\n    # - A simple identifier is any alphabetical character or an underscore, followed by \n    #   any number of alpha-numeric characters or underscores\n    # - A delimited identifier is any sequence of characters enclosed in backticks ( ` ):\n    r'(?:\\`[a-zA-Z][a-zA-Z0-9\\-][^\\`]*\\`)|(?:(?:_|[a-zA-Z])[a-zA-Z0-9_]*)'\n    if t.value.startswith('`') and t.value.endswith('`'):        \n        t.value = t.value.strip('`') \n        t.type = 'IDENTIFIER'\n    else:\n        t.type = self.reserved_words.get(t.value, 'IDENTIFIER')\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_INEQUALITY_OPERATOR","title":"<code>t_INEQUALITY_OPERATOR(t)</code>","text":"<p>=|&lt;=|&gt;|&lt;</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_INEQUALITY_OPERATOR(self, t):\n    r'&gt;=|&lt;=|&gt;|&lt;'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_NUMBER","title":"<code>t_NUMBER(t)</code>","text":"<p>-?\\d+(.\\d+)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_NUMBER(self, t):\n    r'-?\\d+(\\.\\d+)?'\n    if '.' in t.value:\n        # Decimal (http://hl7.org/fhirpath/N1/#decimal)\n        # -------------------------------------------------------------------------------\n        t.value = float(t.value) \n        t.type = 'DECIMAL'\n    else:\n        # Integer (http://hl7.org/fhirpath/N1/#integer)\n        # -------------------------------------------------------------------------------\n        t.value = int(t.value)\n        t.type = 'INTEGER'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_STRING","title":"<code>t_STRING(t)</code>","text":"<p>\\'([^\\']*)?\\'</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_STRING(self, t):\n    # String (http://hl7.org/fhirpath/N1/#string)\n    # -------------------------------------------------------------------------------\n    # The String type represents string values up to 231-1 characters in length. String \n    # literals are surrounded by single-quotes and may use \\-escapes to escape quotes \n    # and represent Unicode characters \n    r'\\'([^\\']*)?\\''\n    t.value = t.value.strip('\\'')\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_TIME","title":"<code>t_TIME(t)</code>","text":"<p>\\@T\\d{2}(?::\\d{2}(?::\\d{2}(?:.\\d{3}(?:[+|-]\\d{2}(?::\\d{2})?)?)?)?)?</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_TIME(self, t):\n    # Time (http://hl7.org/fhirpath/N1/#time)\n    # -------------------------------------------------------------------------------\n    # The Time type represents time-of-day and partial time-of-day values.\n    # - A time begins with a @T\n    # - It uses the Thh:mm:ss.fff format\n    r'\\@T\\d{2}(?:\\:\\d{2}(?:\\:\\d{2}(?:\\.\\d{3}(?:[+|-]\\d{2}(?:\\:\\d{2})?)?)?)?)?'\n    return t\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_error_doublequote_string","title":"<code>t_error_doublequote_string(t)</code>","text":"<p>\\\"([^\\\"]*)?\\\"</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_error_doublequote_string(self, t):\n    r'\\\"([^\\\"]*)?\\\"'\n    pos = t.lexpos - t.lexer.latest_newline\n    raise FhirPathLexerError(f'FHIRPath lexer error at {t.lexer.lineno}:{pos} - Double-quoted strings are not valid in FHIRPath: {t.value}\\n{_underline_error_in_fhir_path(t.lexer.lexdata, t.value, pos)}')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_error_invalid_function","title":"<code>t_error_invalid_function(t)</code>","text":"<p>a-zA-Z((?:.)?)</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_error_invalid_function(self, t):\n    r'[a-zA-Z][a-zA-Z_0-9]*\\((?:.*)?\\)'\n    t.value = t.value.split('(')[0]\n    pos = t.lexpos - t.lexer.latest_newline\n    raise FhirPathLexerError(f'FHIRPath lexer error at {t.lexer.lineno}:{pos} - Invalid function: \"{t.value}\".\\n{_underline_error_in_fhir_path(t.lexer.lexdata, t.value, pos)}')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_ignore_COMMENT","title":"<code>t_ignore_COMMENT(t)</code>","text":"<p>\\/*([\\s\\S]?)*\\/|\\/\\/(.)</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_ignore_COMMENT(self, t):\n    # Comments (http://hl7.org/fhirpath/N1/#comments)\n    # -------------------------------------------------------------------------------\n    # FHIRPath defines two styles of comments, single-line, and multi-line. \n    # - A single-line comment consists of two forward slashes, followed by any \n    #   text up to the end of the line\n    # - To begin a multi-line comment, the typical forward slash-asterisk token\n    #   is used. The comment is closed with an asterisk-forward slash, and everything enclosed is ignored\n    r'\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)'\n    for substring in ['//','/*','*/']:\n        t.value = t.value.replace(substring,'')\n    t.value = t.value.strip()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.t_ignore_WHITESPACE","title":"<code>t_ignore_WHITESPACE(t)</code>","text":"<p>[\\s]</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def t_ignore_WHITESPACE(self, t):\n    # Whitespace (http://hl7.org/fhirpath/N1/#whitespace)\n    # -------------------------------------------------------------------------------\n    # FHIRPath defines tab (\\t), space ( ), line feed (\\n) and carriage return (\\r) as whitespace,\n    # meaning they are only used to separate other tokens within the language. Any number\n    # of whitespace characters can appear, and the language does not use whitespace for \n    # anything other than delimiting tokens.\n    r'[\\s]'\n    if t.value=='\\n':\n        t.lexer.lineno += 1\n        t.lexer.latest_newline = t.lexpos\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/lexer/#fhircraft.fhir.path.lexer.FhirPathLexer.tokenize","title":"<code>tokenize(string)</code>","text":"<p>Maps a string to an iterator over tokens. In other words: [char] -&gt; [token]</p> Source code in <code>fhircraft/fhir/path/lexer.py</code> <pre><code>def tokenize(self, string):\n    '''\n    Maps a string to an iterator over tokens. In other words: [char] -&gt; [token]\n    '''\n\n    new_lexer = ply.lex.lex(module=self)\n    new_lexer.latest_newline = 0\n    new_lexer.string_value = None\n    new_lexer.input(string)\n\n    while True:\n        t = new_lexer.token()\n        if t is None:\n            break\n        t.col = t.lexpos - new_lexer.latest_newline\n        yield t\n\n    if new_lexer.string_value is not None:\n        raise FhirPathLexerError('Unexpected EOF in string literal or identifier')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/","title":"Parser","text":""},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser","title":"<code>FhirPathParser</code>","text":"<p>An LALR-parser for FHIRPath</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>class FhirPathParser:\n    \"\"\"\n    An LALR-parser for FHIRPath\n    \"\"\"\n\n    tokens = FhirPathLexer.tokens\n\n    def __init__(self, debug=False, lexer_class=None):\n        if self.__doc__ is None:\n            raise FhirPathParserError(\n                'Docstrings have been removed! By design of PLY, '\n            )\n\n        self.debug = debug\n        self.lexer_class = lexer_class or FhirPathLexer # Crufty but works around statefulness in PLY\n\n        # Since PLY has some crufty aspects and dumps files, we try to keep them local\n        # However, we need to derive the name of the output Python file :-/\n        output_directory = os.path.dirname(__file__)\n        try:\n            module_name = os.path.splitext(os.path.split(__file__)[1])[0]\n        except:\n            module_name = __name__\n\n        start_symbol = 'expression'\n        parsing_table_module = '_'.join([module_name, start_symbol, 'parsetab'])\n\n        # Generate the parse table\n        self.parser = ply.yacc.yacc(module=self,\n                                    debug=self.debug,\n                                    tabmodule = parsing_table_module,\n                                    outputdir = output_directory,\n                                    write_tables=0,\n                                    start = start_symbol,\n                                    errorlog = logger)\n\n    def parse(self, string, lexer = None):\n        self.string = string\n        lexer = lexer or self.lexer_class()\n        return self.parse_token_stream(lexer.tokenize(string))\n\n    def is_valid(self, string):\n        try: \n            try:\n                self.parse(string)\n                return True     \n            except NotImplementedError:\n                return True     \n        except (FhirPathParserError, FhirPathLexerError):   \n            return False     \n\n    def parse_token_stream(self, token_iterator):\n        return self.parser.parse(lexer = IteratorToTokenStream(token_iterator))\n\n    # ===================== PLY Parser specification =====================\n    precedence = [\n        ('left', '.'),\n        ('left', '[', ']'),\n        ('left', '+', '-', '&amp;'),\n        ('left', '*', '/', 'DIV', 'MOD'),\n        ('left', 'IS', 'AS'),\n        ('left', '|'),\n        ('left', 'INEQUALITY_OPERATOR'),\n        ('left', 'EQUALITY_OPERATOR'),\n        ('left', 'IN', 'CONTAINS'),\n        ('left', 'AND'),\n        ('left', 'OR', 'XOR'),\n        ('left', 'IMPLIES'),\n    ]\n    precedence.reverse()\n\n    def p_error(self, t):\n        if t is None:\n            raise FhirPathParserError(f'FHIRPath parser error near the end of string \"{self.string}\"!')\n        raise FhirPathParserError(f'FHIRPath parser error at {t.lineno}:{t.col} - Invalid token \"{t.value}\" ({t.type}):\\n{_underline_error_in_fhir_path(self.string, t.value, t.col)}')\n\n\n    def p_term_expression(self, p):\n        \"\"\"expression : term \"\"\"\n        p[0] = p[1]\n\n    def p_invocation_expression(self, p):\n        \"expression : expression '.' invocation\"\n        p[0] = Invocation(p[1], p[3])\n\n    def p_indexer_expression(self, p):\n        \"expression : expression '[' expression ']'\"\n        p[0] = Invocation(p[1], subsetting.Index(p[3]))\n\n    def p_multiplicative_operation(self, p):\n        \"\"\"expression : expression '*' expression\n                      | expression '/' expression  \n                      | expression DIV expression  \n                      | expression MOD expression \"\"\"\n        op = p[2]\n        if op == '*':\n            p[0] = math.Multiplication(p[1], p[3])\n        elif op == '/':\n            p[0] = math.Division(p[1], p[3])\n        elif op == 'div':\n            p[0] = math.Div(p[1], p[3])\n        elif op == 'mod':\n            p[0] = math.Mod(p[1], p[3])  \n\n\n    def p_additive_operation(self, p):\n        \"\"\"expression : expression '+' expression\n                      | expression '-' expression  \n                      | expression '&amp;' expression \"\"\"\n        op = p[2]\n        if op == '+':\n            p[0] = math.Addition(p[1], p[3])\n        elif op == '-':\n            p[0] = math.Subtraction(p[1], p[3])\n        elif op == '&amp;':\n            p[0] = strings.Concatenation(p[1], p[3])  \n\n    def p_type_operation(self, p):\n        \"\"\"expression : expression IS type_specifier\n                     | expression AS type_specifier  \"\"\"\n        op = p[2]        \n        if op == 'is':\n            p[0] = types.Is(p[1], p[3])\n        elif op == 'as':\n            p[0] = types.As(p[1], p[3])\n\n    def p_union_operation(self, p):\n        \"\"\"expression : expression '|' expression \"\"\"\n        p[0] = collection.Union(p[1], p[3])\n\n    def p_inequality_operation(self, p):\n        \"\"\"expression : expression INEQUALITY_OPERATOR expression \"\"\"\n        op = p[2]\n        if op == '&gt;':\n            p[0] = comparison.GreaterThan(p[1], p[3])\n        elif op == '&gt;=':\n            p[0] = comparison.GreaterEqualThan(p[1], p[3])\n        elif op == '&lt;':\n            p[0] = comparison.LessThan(p[1], p[3])\n        elif op == '&lt;=':\n            p[0] = comparison.LessEqualThan(p[1], p[3])\n\n    def p_equality_operation(self, p):\n        \"\"\"expression : expression EQUALITY_OPERATOR expression \"\"\"\n        op = p[2]\n        if op == '=':\n            p[0] = equality.Equals(p[1], p[3])\n        elif op == '~':\n            p[0] = equality.Equivalent(p[1], p[3])\n        elif op == '!=':\n            p[0] = equality.NotEquals(p[1], p[3])\n        elif op == '!~':\n            p[0] = equality.NotEquivalent(p[1], p[3])\n\n    def p_membership_operation(self, p):\n        \"\"\"expression : expression IN expression\n                      | expression CONTAINS expression  \"\"\"\n        op = p[2]\n        if op == 'in':\n            p[0] = collection.In(p[1], p[3])\n        elif op == 'contains':\n            p[0] = collection.Contains(p[1], p[3])\n\n    def p_and_operation(self, p):\n        \"\"\"expression : expression AND expression \"\"\"\n        p[0] = boolean.And(p[1], p[3])\n\n    def p_or_operation(self, p):\n        \"\"\"expression : expression OR expression\n                      | expression XOR expression  \"\"\"\n        op = p[2]\n        if op == 'or':\n            p[0] = boolean.Or(p[1], p[3])\n        elif op == 'xor':\n            p[0] = boolean.Xor(p[1], p[3])\n\n    def p_implies_operation(self, p):\n        \"\"\"expression : expression IMPLIES expression \"\"\"\n        p[0] = boolean.Implies(p[1], p[3])    \n\n\n\n    def p_term(self, p):\n        \"\"\"term : invocation\n                | literal  \n                | constant \n                | parenthesized_expression \"\"\"\n        p[0] = p[1]\n\n    def p_parenthesized_expression(self, p):\n        \"\"\"parenthesized_expression : '(' expression ')' \"\"\"\n        p[0] = p[2]\n\n    def p_invocation(self, p):\n        \"\"\"invocation : element \n                      | root\n                      | type_choice\n                      | function \n                      | contextual \"\"\"\n        p[0] = p[1]\n\n\n    def p_root(self, p):\n        \"\"\" root : ROOT_NODE \"\"\"\n        p[0] = Root()\n\n    def p_element(self, p):\n        \"\"\"element : identifier \"\"\"\n        p[0] = Element(p[1])\n\n    def p_typechoice_invocation(self, p):\n        \"type_choice : CHOICE_ELEMENT\"\n        p[0] = additional.TypeChoice(p[1])\n\n    def p_constant(self, p):\n        \"\"\"constant : ENVIRONMENTAL_VARIABLE \"\"\"\n        if p[1] == '%context':\n            p[0] = This()\n        elif p[1] == '%resource':\n            p[0] = Parent()\n        elif p[1] == '%rootResource':\n            p[0] = Root()\n        else:\n            p[0] = p[1]\n\n    def p_contextual(self, p):\n        \"\"\"contextual : CONTEXTUAL_OPERATOR \"\"\"\n        if p[1] == '$':\n            p[0] = Root()\n        elif p[1] == '$this':\n            p[0] = This()\n        elif p[1] == '$index':\n           raise NotImplementedError()\n        elif p[1] == '$total':\n           raise NotImplementedError()\n        else:\n            raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{p.lexpos(1)}: Invalid contextual operator \"{p[1]}\".\\n{_underline_error_in_fhir_path(self.string, p[1], p.lexpos(1))}')                           \n\n    def p_type_specifier(self, p):\n        \"\"\"type_specifier : identifier \n                          | ROOT_NODE \"\"\"\n        p[0] = p[1]\n\n    def p_type_specifier_context(self, p):\n        \"\"\"type_specifier : type_specifier '.' identifier \"\"\"\n        p[0] = f'{p[1]}.{p[3]}'\n\n    def p_function(self, p):\n        \"\"\"function : function_name '(' arguments ')' \"\"\"\n\n        def check(args, function, nargs):\n            if args[1] == function:\n                params = ensure_list(args[3] or [])\n                params = [param for param in params if param is not None]\n                nprovided = len(params)\n                if nprovided not in ensure_list(nargs):\n                    raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{p.lexpos(1)}: Function {function}() requires {nargs} arguments, but {nprovided} were provided.\\n{_underline_error_in_fhir_path(self.string, function, p.lexpos(1))}')\n                return True \n            return False\n        # -------------------------------------------------------------------------------\n        # Existence\n        # -------------------------------------------------------------------------------\n        if check(p, 'empty', nargs=0):\n            p[0] = existence.Empty()\n        elif check(p, 'exists', nargs=[0,1]):\n            p[0] = existence.Exists(*p[3])\n        elif check(p, 'all', nargs=[0,1]):\n            p[0] = existence.All(*p[3])\n        elif check(p, 'allTrue', nargs=0):\n            p[0] = existence.AllTrue()\n        elif check(p, 'anyTrue', nargs=0):\n            p[0] = existence.AnyTrue()\n        elif check(p, 'allFalse', nargs=0):\n            p[0] = existence.AllFalse()\n        elif check(p, 'anyFalse', nargs=0):\n            p[0] = existence.AnyFalse()\n        elif check(p, 'subsetOf', nargs=1):\n            p[0] = existence.SubsetOf(*p[3])\n        elif check(p, 'supersetOf', nargs=1):\n            p[0] = existence.SupersetOf(*p[3])\n        elif check(p, 'count', nargs=0):\n            p[0] = existence.Count()\n        elif check(p, 'distinct', nargs=0):\n            p[0] = existence.Distinct()\n        elif check(p, 'isDistinct', nargs=0):\n            p[0] = existence.IsDistinct()\n        # -------------------------------------------------------------------------------\n        # Subsetting\n        # -------------------------------------------------------------------------------\n        elif check(p, 'where', nargs=1):\n            p[0] = filtering.Where(*p[3])\n        elif check(p, 'select', nargs=1):\n            p[0] = filtering.Select(*p[3])\n        elif check(p, 'repeat', nargs=1):\n            p[0] = filtering.Repeat(*p[3])\n        elif check(p, 'ofType', nargs=1):\n            p[0] = filtering.OfType(*p[3])\n        # -------------------------------------------------------------------------------\n        # Additional functions\n        # -------------------------------------------------------------------------------\n        elif check(p, 'extension', nargs=1):\n            p[0] = additional.Extension(*p[3])        \n        elif check(p, 'resolve', nargs=0):\n            p[0] = additional.Resolve()  \n        elif check(p, 'hasValue', nargs=0):\n            p[0] = additional.HasValue() \n        elif check(p, 'getValue', nargs=0):\n            p[0] = additional.GetValue() \n        elif check(p, 'htmlChecks', nargs=0):\n            p[0] = additional.HtmlChecks()\n        # -------------------------------------------------------------------------------\n        # Subsetting\n        # -------------------------------------------------------------------------------\n        elif check(p, 'single', nargs=0):\n            p[0] = subsetting.Single()\n        elif check(p, 'first', nargs=0):\n            p[0] = subsetting.First()\n        elif check(p, 'last', nargs=0):\n            p[0] = subsetting.Last()\n        elif check(p, 'tail', nargs=0):\n            p[0] = subsetting.Tail()\n        elif check(p, 'skip', nargs=1):\n            p[0] = subsetting.Skip(*p[3])\n        elif check(p, 'take', nargs=1):\n            p[0] = subsetting.Take(*p[3])\n        elif check(p, 'intersect', nargs=1):\n            p[0] = subsetting.Intersect(*p[3])\n        elif check(p, 'exclude', nargs=1):\n            p[0] = subsetting.Exclude(*p[3])\n        # -------------------------------------------------------------------------------\n        # Combining\n        # -------------------------------------------------------------------------------\n        elif check(p, 'union', nargs=1):\n            p[0] = combining.Union(*p[3])\n        elif check(p, 'combine', nargs=1):\n            p[0] = combining.Combine(*p[3])\n        # -------------------------------------------------------------------------------\n        # Conversion\n        # -------------------------------------------------------------------------------\n        elif check(p, 'iif', nargs=[2,3]):\n            p[0] = conversion.Iif(*p[3])\n        elif check(p, 'toBoolean', nargs=0):\n            p[0] = conversion.ToBoolean()\n        elif check(p, 'convertsToBoolean', nargs=0):\n            p[0] = conversion.ConvertsToBoolean()\n        elif check(p, 'toInteger', nargs=0):\n            p[0] = conversion.ToInteger()\n        elif check(p, 'convertsToInteger', nargs=0):\n            p[0] = conversion.ConvertsToInteger()\n        elif check(p, 'toDate', nargs=0):\n            p[0] = conversion.ToDate()\n        elif check(p, 'convertsToDate', nargs=0):\n            p[0] = conversion.ConvertsToDate()\n        elif check(p, 'toDateTime', nargs=0):\n            p[0] = conversion.ToDateTime()\n        elif check(p, 'convertsToDateTime', nargs=0):\n            p[0] = conversion.ConvertsToDateTime()\n        elif check(p, 'toDecimal', nargs=0):\n            p[0] = conversion.ToDecimal()\n        elif check(p, 'convertsToDecimal', nargs=0):\n            p[0] = conversion.ConvertsToDecimal()\n        elif check(p, 'toQuantity', nargs=[0,1]):\n            p[0] = conversion.ToQuantity()\n        elif check(p, 'convertsToQuantity', nargs=[0,1]):\n            p[0] = conversion.ConvertsToQuantity()\n        elif check(p, 'toString', nargs=0):\n            p[0] = conversion.ToString()\n        elif check(p, 'convertsToString', nargs=0):\n            p[0] = conversion.ConvertsToString()\n        elif check(p, 'toTime', nargs=0):\n            p[0] = conversion.ToTime()\n        elif check(p, 'convertsToTime', nargs=0):\n            p[0] = conversion.ConvertsToTime()\n        # -------------------------------------------------------------------------------\n        # String manipulation\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'indexOf', nargs=1):\n            p[0] = strings.IndexOf(*p[3]) \n        elif check(p, 'substring', nargs=(1,2)):\n            p[0] = strings.Substring(*p[3]) \n        elif check(p, 'startsWith', nargs=1): \n            p[0] = strings.StartsWith(*p[3])   \n        elif check(p, 'endsWith', nargs=1):\n            p[0] = strings.EndsWith(*p[3])     \n        elif check(p, 'contains', nargs=1):\n            p[0] = strings.Contains(*p[3])   \n        elif check(p, 'upper', nargs=0):\n            p[0] = strings.Upper()   \n        elif check(p, 'lower', nargs=0):\n            p[0] = strings.Lower()   \n        elif check(p, 'replace', nargs=2):\n            p[0] = strings.Replace(*p[3])   \n        elif check(p, 'matches', nargs=1):\n            p[0] = strings.Matches(*p[3])   \n        elif check(p, 'replaceMatches', nargs=2):\n            p[0] = strings.ReplaceMatches(*p[3])   \n        elif check(p, 'length', nargs=0):\n            p[0] = strings.Length()   \n        elif check(p, 'toChars', nargs=0):\n            p[0] = strings.ToChars()    \n        # -------------------------------------------------------------------------------\n        # Math\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'abs', nargs=0):\n            raise NotImplementedError()     \n        elif check(p, 'ceiling', nargs=0):\n            raise NotImplementedError()     \n        elif check(p, 'exp', nargs=0):\n            raise NotImplementedError()     \n        elif check(p, 'floor', nargs=0):\n            raise NotImplementedError()     \n        elif check(p, 'ln', nargs=0):\n            raise NotImplementedError()     \n        elif check(p, 'log', nargs=1):\n            raise NotImplementedError()    \n        elif check(p, 'power', nargs=1):\n            raise NotImplementedError()    \n        elif check(p, 'round', nargs=1):\n            raise NotImplementedError()    \n        elif check(p, 'sqrt', nargs=0):\n            raise NotImplementedError()    \n        elif check(p, 'truncate', nargs=0):\n            raise NotImplementedError()     \n        # -------------------------------------------------------------------------------\n        # Tree navigation\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'children', nargs=0):\n            p[0] = navigation.Children()     \n        elif check(p, 'descendants', nargs=0):\n            p[0] = navigation.Descendants()     \n        # -------------------------------------------------------------------------------\n        # Boolean functions\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'not', nargs=0):\n            p[0] = boolean.Not()     \n        # -------------------------------------------------------------------------------\n        # Utility functions\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'trace', nargs=[1,2]):\n            p[0] = utility.Trace(*p[3]) \n        elif check(p, 'now', nargs=0):\n            p[0] = utility.Now() \n        elif check(p, 'timeOfDay', nargs=0):\n            p[0] = utility.TimeOfDay() \n        elif check(p, 'today', nargs=0):\n            p[0] = utility.Today()  \n        # -------------------------------------------------------------------------------\n        # Type functions\n        # -------------------------------------------------------------------------------   \n        elif check(p, 'is', nargs=1):\n            p[0] = types.LegacyIs(*p[3]) \n        elif check(p, 'as', nargs=1):\n            p[0] = types.LegacyAs(*p[3])  \n        else:\n            pos = self.string.find(str(p[1]))\n            raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{pos}: Invalid function \"{p[1]}\".\\n{_underline_error_in_fhir_path(self.string,p[1], pos)}')\n\n    def p_function_name(self, p):\n        \"\"\" function_name : identifier \n                          | CONTAINS\n                          | IN\n                          | AS\n                          | IS\n                          \"\"\"\n        p[0] = p[1] \n\n    def p_function_arguments(self, p):\n        \"\"\"arguments : expression\n                     | empty \"\"\"\n        p[0] = [p[1]]\n\n    def p_function_arguments_list(self, p):\n        \"\"\"arguments : arguments ',' arguments \"\"\"\n        p[0] = ensure_list(p[1]) + ensure_list(p[2])\n\n    def p_identifier(self, p):\n        \"\"\" identifier : IDENTIFIER \"\"\"\n        p[0] = p[1]\n\n    def p_literal(self, p):\n        \"\"\"literal : STRING\n                   | BOOLEAN\n                   | date\n                   | time \n                   | datetime\n                   | number\n                   | quantity\n                   \"\"\"\n        p[0] = p[1]\n\n    def p_literal_empty(self, p):\n        \"\"\"literal : '{' '}' \"\"\"\n        p[0] = []\n\n    def p_datetime(self, p):\n        \"datetime : DATETIME\"\n        p[0] = literals.DateTime(p[1])\n\n    def p_time(self, p):\n        \"time : TIME\"\n        p[0] = literals.Time(p[1])\n\n    def p_date(self, p):\n        \"date : DATE\"\n        p[0] = literals.Date(p[1])\n\n    def p_quantity(self, p):\n        \"\"\"quantity : number unit\"\"\"\n        p[0] = literals.Quantity(p[1], p[2])\n\n    def p_unit(self, p):\n        \"\"\"unit : STRING\n                | CALENDAR_DURATION\"\"\"\n        p[0] = p[1]\n\n    def p_number(self, p):\n        \"\"\"number : INTEGER\n                  | DECIMAL\"\"\"\n        p[0] = p[1]\n\n\n    def p_empty(self, p):\n        \"\"\"empty :\"\"\"\n        p[0] = None\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_additive_operation","title":"<code>p_additive_operation(p)</code>","text":"<p>expression : expression '+' expression | expression '-' expression | expression '&amp;' expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_additive_operation(self, p):\n    \"\"\"expression : expression '+' expression\n                  | expression '-' expression  \n                  | expression '&amp;' expression \"\"\"\n    op = p[2]\n    if op == '+':\n        p[0] = math.Addition(p[1], p[3])\n    elif op == '-':\n        p[0] = math.Subtraction(p[1], p[3])\n    elif op == '&amp;':\n        p[0] = strings.Concatenation(p[1], p[3])  \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_and_operation","title":"<code>p_and_operation(p)</code>","text":"<p>expression : expression AND expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_and_operation(self, p):\n    \"\"\"expression : expression AND expression \"\"\"\n    p[0] = boolean.And(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_constant","title":"<code>p_constant(p)</code>","text":"<p>constant : ENVIRONMENTAL_VARIABLE</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_constant(self, p):\n    \"\"\"constant : ENVIRONMENTAL_VARIABLE \"\"\"\n    if p[1] == '%context':\n        p[0] = This()\n    elif p[1] == '%resource':\n        p[0] = Parent()\n    elif p[1] == '%rootResource':\n        p[0] = Root()\n    else:\n        p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_contextual","title":"<code>p_contextual(p)</code>","text":"<p>contextual : CONTEXTUAL_OPERATOR</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_contextual(self, p):\n    \"\"\"contextual : CONTEXTUAL_OPERATOR \"\"\"\n    if p[1] == '$':\n        p[0] = Root()\n    elif p[1] == '$this':\n        p[0] = This()\n    elif p[1] == '$index':\n       raise NotImplementedError()\n    elif p[1] == '$total':\n       raise NotImplementedError()\n    else:\n        raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{p.lexpos(1)}: Invalid contextual operator \"{p[1]}\".\\n{_underline_error_in_fhir_path(self.string, p[1], p.lexpos(1))}')                           \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_date","title":"<code>p_date(p)</code>","text":"<p>date : DATE</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_date(self, p):\n    \"date : DATE\"\n    p[0] = literals.Date(p[1])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_datetime","title":"<code>p_datetime(p)</code>","text":"<p>datetime : DATETIME</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_datetime(self, p):\n    \"datetime : DATETIME\"\n    p[0] = literals.DateTime(p[1])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_element","title":"<code>p_element(p)</code>","text":"<p>element : identifier</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_element(self, p):\n    \"\"\"element : identifier \"\"\"\n    p[0] = Element(p[1])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_empty","title":"<code>p_empty(p)</code>","text":"<p>empty :</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_empty(self, p):\n    \"\"\"empty :\"\"\"\n    p[0] = None\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_equality_operation","title":"<code>p_equality_operation(p)</code>","text":"<p>expression : expression EQUALITY_OPERATOR expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_equality_operation(self, p):\n    \"\"\"expression : expression EQUALITY_OPERATOR expression \"\"\"\n    op = p[2]\n    if op == '=':\n        p[0] = equality.Equals(p[1], p[3])\n    elif op == '~':\n        p[0] = equality.Equivalent(p[1], p[3])\n    elif op == '!=':\n        p[0] = equality.NotEquals(p[1], p[3])\n    elif op == '!~':\n        p[0] = equality.NotEquivalent(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_function","title":"<code>p_function(p)</code>","text":"<p>function : function_name '(' arguments ')'</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_function(self, p):\n    \"\"\"function : function_name '(' arguments ')' \"\"\"\n\n    def check(args, function, nargs):\n        if args[1] == function:\n            params = ensure_list(args[3] or [])\n            params = [param for param in params if param is not None]\n            nprovided = len(params)\n            if nprovided not in ensure_list(nargs):\n                raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{p.lexpos(1)}: Function {function}() requires {nargs} arguments, but {nprovided} were provided.\\n{_underline_error_in_fhir_path(self.string, function, p.lexpos(1))}')\n            return True \n        return False\n    # -------------------------------------------------------------------------------\n    # Existence\n    # -------------------------------------------------------------------------------\n    if check(p, 'empty', nargs=0):\n        p[0] = existence.Empty()\n    elif check(p, 'exists', nargs=[0,1]):\n        p[0] = existence.Exists(*p[3])\n    elif check(p, 'all', nargs=[0,1]):\n        p[0] = existence.All(*p[3])\n    elif check(p, 'allTrue', nargs=0):\n        p[0] = existence.AllTrue()\n    elif check(p, 'anyTrue', nargs=0):\n        p[0] = existence.AnyTrue()\n    elif check(p, 'allFalse', nargs=0):\n        p[0] = existence.AllFalse()\n    elif check(p, 'anyFalse', nargs=0):\n        p[0] = existence.AnyFalse()\n    elif check(p, 'subsetOf', nargs=1):\n        p[0] = existence.SubsetOf(*p[3])\n    elif check(p, 'supersetOf', nargs=1):\n        p[0] = existence.SupersetOf(*p[3])\n    elif check(p, 'count', nargs=0):\n        p[0] = existence.Count()\n    elif check(p, 'distinct', nargs=0):\n        p[0] = existence.Distinct()\n    elif check(p, 'isDistinct', nargs=0):\n        p[0] = existence.IsDistinct()\n    # -------------------------------------------------------------------------------\n    # Subsetting\n    # -------------------------------------------------------------------------------\n    elif check(p, 'where', nargs=1):\n        p[0] = filtering.Where(*p[3])\n    elif check(p, 'select', nargs=1):\n        p[0] = filtering.Select(*p[3])\n    elif check(p, 'repeat', nargs=1):\n        p[0] = filtering.Repeat(*p[3])\n    elif check(p, 'ofType', nargs=1):\n        p[0] = filtering.OfType(*p[3])\n    # -------------------------------------------------------------------------------\n    # Additional functions\n    # -------------------------------------------------------------------------------\n    elif check(p, 'extension', nargs=1):\n        p[0] = additional.Extension(*p[3])        \n    elif check(p, 'resolve', nargs=0):\n        p[0] = additional.Resolve()  \n    elif check(p, 'hasValue', nargs=0):\n        p[0] = additional.HasValue() \n    elif check(p, 'getValue', nargs=0):\n        p[0] = additional.GetValue() \n    elif check(p, 'htmlChecks', nargs=0):\n        p[0] = additional.HtmlChecks()\n    # -------------------------------------------------------------------------------\n    # Subsetting\n    # -------------------------------------------------------------------------------\n    elif check(p, 'single', nargs=0):\n        p[0] = subsetting.Single()\n    elif check(p, 'first', nargs=0):\n        p[0] = subsetting.First()\n    elif check(p, 'last', nargs=0):\n        p[0] = subsetting.Last()\n    elif check(p, 'tail', nargs=0):\n        p[0] = subsetting.Tail()\n    elif check(p, 'skip', nargs=1):\n        p[0] = subsetting.Skip(*p[3])\n    elif check(p, 'take', nargs=1):\n        p[0] = subsetting.Take(*p[3])\n    elif check(p, 'intersect', nargs=1):\n        p[0] = subsetting.Intersect(*p[3])\n    elif check(p, 'exclude', nargs=1):\n        p[0] = subsetting.Exclude(*p[3])\n    # -------------------------------------------------------------------------------\n    # Combining\n    # -------------------------------------------------------------------------------\n    elif check(p, 'union', nargs=1):\n        p[0] = combining.Union(*p[3])\n    elif check(p, 'combine', nargs=1):\n        p[0] = combining.Combine(*p[3])\n    # -------------------------------------------------------------------------------\n    # Conversion\n    # -------------------------------------------------------------------------------\n    elif check(p, 'iif', nargs=[2,3]):\n        p[0] = conversion.Iif(*p[3])\n    elif check(p, 'toBoolean', nargs=0):\n        p[0] = conversion.ToBoolean()\n    elif check(p, 'convertsToBoolean', nargs=0):\n        p[0] = conversion.ConvertsToBoolean()\n    elif check(p, 'toInteger', nargs=0):\n        p[0] = conversion.ToInteger()\n    elif check(p, 'convertsToInteger', nargs=0):\n        p[0] = conversion.ConvertsToInteger()\n    elif check(p, 'toDate', nargs=0):\n        p[0] = conversion.ToDate()\n    elif check(p, 'convertsToDate', nargs=0):\n        p[0] = conversion.ConvertsToDate()\n    elif check(p, 'toDateTime', nargs=0):\n        p[0] = conversion.ToDateTime()\n    elif check(p, 'convertsToDateTime', nargs=0):\n        p[0] = conversion.ConvertsToDateTime()\n    elif check(p, 'toDecimal', nargs=0):\n        p[0] = conversion.ToDecimal()\n    elif check(p, 'convertsToDecimal', nargs=0):\n        p[0] = conversion.ConvertsToDecimal()\n    elif check(p, 'toQuantity', nargs=[0,1]):\n        p[0] = conversion.ToQuantity()\n    elif check(p, 'convertsToQuantity', nargs=[0,1]):\n        p[0] = conversion.ConvertsToQuantity()\n    elif check(p, 'toString', nargs=0):\n        p[0] = conversion.ToString()\n    elif check(p, 'convertsToString', nargs=0):\n        p[0] = conversion.ConvertsToString()\n    elif check(p, 'toTime', nargs=0):\n        p[0] = conversion.ToTime()\n    elif check(p, 'convertsToTime', nargs=0):\n        p[0] = conversion.ConvertsToTime()\n    # -------------------------------------------------------------------------------\n    # String manipulation\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'indexOf', nargs=1):\n        p[0] = strings.IndexOf(*p[3]) \n    elif check(p, 'substring', nargs=(1,2)):\n        p[0] = strings.Substring(*p[3]) \n    elif check(p, 'startsWith', nargs=1): \n        p[0] = strings.StartsWith(*p[3])   \n    elif check(p, 'endsWith', nargs=1):\n        p[0] = strings.EndsWith(*p[3])     \n    elif check(p, 'contains', nargs=1):\n        p[0] = strings.Contains(*p[3])   \n    elif check(p, 'upper', nargs=0):\n        p[0] = strings.Upper()   \n    elif check(p, 'lower', nargs=0):\n        p[0] = strings.Lower()   \n    elif check(p, 'replace', nargs=2):\n        p[0] = strings.Replace(*p[3])   \n    elif check(p, 'matches', nargs=1):\n        p[0] = strings.Matches(*p[3])   \n    elif check(p, 'replaceMatches', nargs=2):\n        p[0] = strings.ReplaceMatches(*p[3])   \n    elif check(p, 'length', nargs=0):\n        p[0] = strings.Length()   \n    elif check(p, 'toChars', nargs=0):\n        p[0] = strings.ToChars()    \n    # -------------------------------------------------------------------------------\n    # Math\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'abs', nargs=0):\n        raise NotImplementedError()     \n    elif check(p, 'ceiling', nargs=0):\n        raise NotImplementedError()     \n    elif check(p, 'exp', nargs=0):\n        raise NotImplementedError()     \n    elif check(p, 'floor', nargs=0):\n        raise NotImplementedError()     \n    elif check(p, 'ln', nargs=0):\n        raise NotImplementedError()     \n    elif check(p, 'log', nargs=1):\n        raise NotImplementedError()    \n    elif check(p, 'power', nargs=1):\n        raise NotImplementedError()    \n    elif check(p, 'round', nargs=1):\n        raise NotImplementedError()    \n    elif check(p, 'sqrt', nargs=0):\n        raise NotImplementedError()    \n    elif check(p, 'truncate', nargs=0):\n        raise NotImplementedError()     \n    # -------------------------------------------------------------------------------\n    # Tree navigation\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'children', nargs=0):\n        p[0] = navigation.Children()     \n    elif check(p, 'descendants', nargs=0):\n        p[0] = navigation.Descendants()     \n    # -------------------------------------------------------------------------------\n    # Boolean functions\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'not', nargs=0):\n        p[0] = boolean.Not()     \n    # -------------------------------------------------------------------------------\n    # Utility functions\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'trace', nargs=[1,2]):\n        p[0] = utility.Trace(*p[3]) \n    elif check(p, 'now', nargs=0):\n        p[0] = utility.Now() \n    elif check(p, 'timeOfDay', nargs=0):\n        p[0] = utility.TimeOfDay() \n    elif check(p, 'today', nargs=0):\n        p[0] = utility.Today()  \n    # -------------------------------------------------------------------------------\n    # Type functions\n    # -------------------------------------------------------------------------------   \n    elif check(p, 'is', nargs=1):\n        p[0] = types.LegacyIs(*p[3]) \n    elif check(p, 'as', nargs=1):\n        p[0] = types.LegacyAs(*p[3])  \n    else:\n        pos = self.string.find(str(p[1]))\n        raise FhirPathParserError(f'FHIRPath parser error at {p.lineno(1)}:{pos}: Invalid function \"{p[1]}\".\\n{_underline_error_in_fhir_path(self.string,p[1], pos)}')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_function_arguments","title":"<code>p_function_arguments(p)</code>","text":"<p>arguments : expression | empty</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_function_arguments(self, p):\n    \"\"\"arguments : expression\n                 | empty \"\"\"\n    p[0] = [p[1]]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_function_arguments_list","title":"<code>p_function_arguments_list(p)</code>","text":"<p>arguments : arguments ',' arguments</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_function_arguments_list(self, p):\n    \"\"\"arguments : arguments ',' arguments \"\"\"\n    p[0] = ensure_list(p[1]) + ensure_list(p[2])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_function_name","title":"<code>p_function_name(p)</code>","text":"<p>function_name : identifier  | CONTAINS | IN | AS | IS</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_function_name(self, p):\n    \"\"\" function_name : identifier \n                      | CONTAINS\n                      | IN\n                      | AS\n                      | IS\n                      \"\"\"\n    p[0] = p[1] \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_identifier","title":"<code>p_identifier(p)</code>","text":"<p>identifier : IDENTIFIER</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_identifier(self, p):\n    \"\"\" identifier : IDENTIFIER \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_implies_operation","title":"<code>p_implies_operation(p)</code>","text":"<p>expression : expression IMPLIES expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_implies_operation(self, p):\n    \"\"\"expression : expression IMPLIES expression \"\"\"\n    p[0] = boolean.Implies(p[1], p[3])    \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_indexer_expression","title":"<code>p_indexer_expression(p)</code>","text":"<p>expression : expression '[' expression ']'</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_indexer_expression(self, p):\n    \"expression : expression '[' expression ']'\"\n    p[0] = Invocation(p[1], subsetting.Index(p[3]))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_inequality_operation","title":"<code>p_inequality_operation(p)</code>","text":"<p>expression : expression INEQUALITY_OPERATOR expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_inequality_operation(self, p):\n    \"\"\"expression : expression INEQUALITY_OPERATOR expression \"\"\"\n    op = p[2]\n    if op == '&gt;':\n        p[0] = comparison.GreaterThan(p[1], p[3])\n    elif op == '&gt;=':\n        p[0] = comparison.GreaterEqualThan(p[1], p[3])\n    elif op == '&lt;':\n        p[0] = comparison.LessThan(p[1], p[3])\n    elif op == '&lt;=':\n        p[0] = comparison.LessEqualThan(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_invocation","title":"<code>p_invocation(p)</code>","text":"<p>invocation : element  | root | type_choice | function  | contextual</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_invocation(self, p):\n    \"\"\"invocation : element \n                  | root\n                  | type_choice\n                  | function \n                  | contextual \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_invocation_expression","title":"<code>p_invocation_expression(p)</code>","text":"<p>expression : expression '.' invocation</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_invocation_expression(self, p):\n    \"expression : expression '.' invocation\"\n    p[0] = Invocation(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_literal","title":"<code>p_literal(p)</code>","text":"<p>literal : STRING | BOOLEAN | date | time  | datetime | number | quantity</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_literal(self, p):\n    \"\"\"literal : STRING\n               | BOOLEAN\n               | date\n               | time \n               | datetime\n               | number\n               | quantity\n               \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_literal_empty","title":"<code>p_literal_empty(p)</code>","text":"<p>literal : '{' '}'</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_literal_empty(self, p):\n    \"\"\"literal : '{' '}' \"\"\"\n    p[0] = []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_membership_operation","title":"<code>p_membership_operation(p)</code>","text":"<p>expression : expression IN expression | expression CONTAINS expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_membership_operation(self, p):\n    \"\"\"expression : expression IN expression\n                  | expression CONTAINS expression  \"\"\"\n    op = p[2]\n    if op == 'in':\n        p[0] = collection.In(p[1], p[3])\n    elif op == 'contains':\n        p[0] = collection.Contains(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_multiplicative_operation","title":"<code>p_multiplicative_operation(p)</code>","text":"<p>expression : expression '*' expression | expression '/' expression | expression DIV expression | expression MOD expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_multiplicative_operation(self, p):\n    \"\"\"expression : expression '*' expression\n                  | expression '/' expression  \n                  | expression DIV expression  \n                  | expression MOD expression \"\"\"\n    op = p[2]\n    if op == '*':\n        p[0] = math.Multiplication(p[1], p[3])\n    elif op == '/':\n        p[0] = math.Division(p[1], p[3])\n    elif op == 'div':\n        p[0] = math.Div(p[1], p[3])\n    elif op == 'mod':\n        p[0] = math.Mod(p[1], p[3])  \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_number","title":"<code>p_number(p)</code>","text":"<p>number : INTEGER | DECIMAL</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_number(self, p):\n    \"\"\"number : INTEGER\n              | DECIMAL\"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_or_operation","title":"<code>p_or_operation(p)</code>","text":"<p>expression : expression OR expression | expression XOR expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_or_operation(self, p):\n    \"\"\"expression : expression OR expression\n                  | expression XOR expression  \"\"\"\n    op = p[2]\n    if op == 'or':\n        p[0] = boolean.Or(p[1], p[3])\n    elif op == 'xor':\n        p[0] = boolean.Xor(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_parenthesized_expression","title":"<code>p_parenthesized_expression(p)</code>","text":"<p>parenthesized_expression : '(' expression ')'</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_parenthesized_expression(self, p):\n    \"\"\"parenthesized_expression : '(' expression ')' \"\"\"\n    p[0] = p[2]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_quantity","title":"<code>p_quantity(p)</code>","text":"<p>quantity : number unit</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_quantity(self, p):\n    \"\"\"quantity : number unit\"\"\"\n    p[0] = literals.Quantity(p[1], p[2])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_root","title":"<code>p_root(p)</code>","text":"<p>root : ROOT_NODE</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_root(self, p):\n    \"\"\" root : ROOT_NODE \"\"\"\n    p[0] = Root()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_term","title":"<code>p_term(p)</code>","text":"<p>term : invocation | literal | constant  | parenthesized_expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_term(self, p):\n    \"\"\"term : invocation\n            | literal  \n            | constant \n            | parenthesized_expression \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_term_expression","title":"<code>p_term_expression(p)</code>","text":"<p>expression : term</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_term_expression(self, p):\n    \"\"\"expression : term \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_time","title":"<code>p_time(p)</code>","text":"<p>time : TIME</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_time(self, p):\n    \"time : TIME\"\n    p[0] = literals.Time(p[1])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_type_operation","title":"<code>p_type_operation(p)</code>","text":"<p>expression : expression IS type_specifier | expression AS type_specifier</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_type_operation(self, p):\n    \"\"\"expression : expression IS type_specifier\n                 | expression AS type_specifier  \"\"\"\n    op = p[2]        \n    if op == 'is':\n        p[0] = types.Is(p[1], p[3])\n    elif op == 'as':\n        p[0] = types.As(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_type_specifier","title":"<code>p_type_specifier(p)</code>","text":"<p>type_specifier : identifier  | ROOT_NODE</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_type_specifier(self, p):\n    \"\"\"type_specifier : identifier \n                      | ROOT_NODE \"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_type_specifier_context","title":"<code>p_type_specifier_context(p)</code>","text":"<p>type_specifier : type_specifier '.' identifier</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_type_specifier_context(self, p):\n    \"\"\"type_specifier : type_specifier '.' identifier \"\"\"\n    p[0] = f'{p[1]}.{p[3]}'\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_typechoice_invocation","title":"<code>p_typechoice_invocation(p)</code>","text":"<p>type_choice : CHOICE_ELEMENT</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_typechoice_invocation(self, p):\n    \"type_choice : CHOICE_ELEMENT\"\n    p[0] = additional.TypeChoice(p[1])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_union_operation","title":"<code>p_union_operation(p)</code>","text":"<p>expression : expression '|' expression</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_union_operation(self, p):\n    \"\"\"expression : expression '|' expression \"\"\"\n    p[0] = collection.Union(p[1], p[3])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/parser/#fhircraft.fhir.path.parser.FhirPathParser.p_unit","title":"<code>p_unit(p)</code>","text":"<p>unit : STRING | CALENDAR_DURATION</p> Source code in <code>fhircraft/fhir/path/parser.py</code> <pre><code>def p_unit(self, p):\n    \"\"\"unit : STRING\n            | CALENDAR_DURATION\"\"\"\n    p[0] = p[1]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/utils/","title":"Utils","text":""},{"location":"reference/fhircraft/fhir/path/utils/#fhircraft.fhir.path.utils.join_fhirpath","title":"<code>join_fhirpath(*segments)</code>","text":"<p>Join multiple FHIR path segments into a single FHIR path string.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>str</code> <p>Variable number of FHIR path segments to join.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single FHIR path string created by joining the input segments with dots.</p> Example <p>This shows how to join a list of FHIRPath segments irrespectively of the separators:</p> <pre><code>&gt;&gt;&gt; from fhircraft.fhir.path.utils import join_fhirpath\n&gt;&gt;&gt; join_fhirpath(['Patient','.name','given.'])\nPatient.name.given\n</code></pre> Source code in <code>fhircraft/fhir/path/utils.py</code> <pre><code>def join_fhirpath(*segments: str) -&gt; str:\n    \"\"\"\n    Join multiple FHIR path segments into a single FHIR path string.\n\n    Args:\n        segments (str): Variable number of FHIR path segments to join.\n\n    Returns:\n        str: A single FHIR path string created by joining the input segments with dots.\n\n    Example:\n        This shows how to join a list of FHIRPath segments irrespectively of the separators:\n\n        ``` python\n        &gt;&gt;&gt; from fhircraft.fhir.path.utils import join_fhirpath\n        &gt;&gt;&gt; join_fhirpath(['Patient','.name','given.'])\n        Patient.name.given\n        ```\n    \"\"\"    \n    return '.'.join((\n        str(segment).strip('.') \n            for segment in segments if segment!=''\n    )) \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/utils/#fhircraft.fhir.path.utils.split_fhirpath","title":"<code>split_fhirpath(fhir_path)</code>","text":"<p>Split a FHIR path string at non-quoted dots.</p> <p>Parameters:</p> Name Type Description Default <code>fhir_path</code> <code>str</code> <p>The FHIR path string to split.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of strings resulting from splitting the FHIR path at non-quoted dots.</p> Example <p>This shows how to safely split a FHIRPath string into segments: </p> <pre><code>&gt;&gt;&gt; from fhircraft.fhir.path.utils import join_fhirpath\n&gt;&gt;&gt; split_fhirpath(\"Observation.components.where(code.coding.code='123')\"])\n[\"Observation\",\"components\",\"where(code.coding.code='123')\"]\n</code></pre> Source code in <code>fhircraft/fhir/path/utils.py</code> <pre><code>def split_fhirpath(fhir_path: str) -&gt; List[str]:\n    \"\"\"\n    Split a FHIR path string at non-quoted dots.\n\n    Args:\n        fhir_path (str): The FHIR path string to split.\n\n    Returns:\n        List[str]: A list of strings resulting from splitting the FHIR path at non-quoted dots.\n\n    Example:\n        This shows how to safely split a FHIRPath string into segments: \n\n        ``` python\n        &gt;&gt;&gt; from fhircraft.fhir.path.utils import join_fhirpath\n        &gt;&gt;&gt; split_fhirpath(\"Observation.components.where(code.coding.code='123')\"])\n        [\"Observation\",\"components\",\"where(code.coding.code='123')\"]\n        ```\n    \"\"\"    \n    FHIRPATH_SEPARATORS = re.compile(r'\\.(?=(?:[^\\)]*\\([^\\(]*\\))*[^\\(\\)]*$)')\n    # Split FHIR path only at non-quoted dots\n    return FHIRPATH_SEPARATORS.split(fhir_path)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/","title":"Additional","text":"<p>FHIR adds (compatible) functionality to the set of common FHIRPath functions. Some of these functions are candidates for elevation to the base version of FHIRPath when the next version is released.</p>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>extension()</code> function.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>URL to query the extensions.</p> Note <p>This class is a syntactical shortcut equivalent to:</p> <pre><code>Invocation(Element('extension'), Where(Equals(Element('url'), url)))\n</code></pre> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>class Extension(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`extension()`](https://build.fhir.org/fhirpath.html#functions) function.\n\n    Attributes:\n        url (str): URL to query the extensions.\n\n    Note:\n        This class is a syntactical shortcut equivalent to:\n\n            Invocation(Element('extension'), Where(Equals(Element('url'), url))) \n    \"\"\"\n    def __init__(self, url: str):\n        self.url = url\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Filters the input collection for items named `extension` with the given `url`.\n        Will return an empty collection if the input collection is empty or the url is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The indexed collection item.\n        \"\"\"\n        collection = ensure_list(collection)\n        return Invocation(Element('extension'), Where(Equals(Element('url'), self.url))).evaluate(collection, create=False) \n\n    def __str__(self):\n        return f'Extension(\"{self.url}\")'\n\n    def __repr__(self):\n        return f'Extension(\"{self.url}\")'\n\n    def __eq__(self, other):\n        return isinstance(other, Extension) and other.url == self.url\n\n    def __hash__(self):\n        return hash((self.url))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.Extension.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Filters the input collection for items named <code>extension</code> with the given <code>url</code>. Will return an empty collection if the input collection is empty or the url is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The indexed collection item.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Filters the input collection for items named `extension` with the given `url`.\n    Will return an empty collection if the input collection is empty or the url is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The indexed collection item.\n    \"\"\"\n    collection = ensure_list(collection)\n    return Invocation(Element('extension'), Where(Equals(Element('url'), self.url))).evaluate(collection, create=False) \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.GetValue","title":"<code>GetValue</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>getValue()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>class GetValue(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`getValue()`](https://build.fhir.org/fhirpath.html#functions) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; Any:\n        \"\"\"\n        Return the underlying system value for the FHIR primitive if the input collection contains a single\n        value which is a FHIR primitive, and it has a primitive value (see discussion for hasValue()). Otherwise the return value is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            Any: Value\n        \"\"\"\n        collection = ensure_list(collection)\n        if not HasValue().evaluate(collection):\n            return []\n        item = collection[0]\n        return item.value\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.GetValue.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Return the underlying system value for the FHIR primitive if the input collection contains a single value which is a FHIR primitive, and it has a primitive value (see discussion for hasValue()). Otherwise the return value is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Value</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Return the underlying system value for the FHIR primitive if the input collection contains a single\n    value which is a FHIR primitive, and it has a primitive value (see discussion for hasValue()). Otherwise the return value is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        Any: Value\n    \"\"\"\n    collection = ensure_list(collection)\n    if not HasValue().evaluate(collection):\n        return []\n    item = collection[0]\n    return item.value\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.HasValue","title":"<code>HasValue</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>hasValue()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>class HasValue(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`hasValue()`](https://build.fhir.org/fhirpath.html#functions) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true if the input collection contains a single value which is a FHIR primitive, and it has a primitive\n        value (e.g. as opposed to not having a value and just having extensions). Otherwise, the return value is empty. \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        collection = ensure_list(collection)\n        if len(collection) != 1:\n            return False\n        item = collection[0]\n        return item.value is not None\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.HasValue.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true if the input collection contains a single value which is a FHIR primitive, and it has a primitive value (e.g. as opposed to not having a value and just having extensions). Otherwise, the return value is empty. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true if the input collection contains a single value which is a FHIR primitive, and it has a primitive\n    value (e.g. as opposed to not having a value and just having extensions). Otherwise, the return value is empty. \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    collection = ensure_list(collection)\n    if len(collection) != 1:\n        return False\n    item = collection[0]\n    return item.value is not None\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.HtmlChecks","title":"<code>HtmlChecks</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>htmlChecks()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>class HtmlChecks(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`htmlChecks()`](https://build.fhir.org/fhirpath.html#functions) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        When invoked on a single xhtml element returns true if the rules around HTML usage are met, and false if they are not.\n        The return value is empty on any other kind of element, or a collection of xhtml elements. \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If the collection is not a single item.\n        \"\"\"\n\n        collection = ensure_list(collection)\n\n        if len(collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n        value = collection[0] \n        # TODO: Implement HTML validity check\n        return True\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.HtmlChecks.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>When invoked on a single xhtml element returns true if the rules around HTML usage are met, and false if they are not. The return value is empty on any other kind of element, or a collection of xhtml elements. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If the collection is not a single item.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    When invoked on a single xhtml element returns true if the rules around HTML usage are met, and false if they are not.\n    The return value is empty on any other kind of element, or a collection of xhtml elements. \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If the collection is not a single item.\n    \"\"\"\n\n    collection = ensure_list(collection)\n\n    if len(collection)&gt;1:\n        raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n    value = collection[0] \n    # TODO: Implement HTML validity check\n    return True\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.Resolve","title":"<code>Resolve</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>resolve()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>class Resolve(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`resolve()`](https://build.fhir.org/fhirpath.html#functions) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        For each item in the collection, if it is a string that is a `uri` (or `canonical` or `url`), locate the target of the\n        reference, and add it to the resulting collection. If the item does not resolve to a resource, the item is ignored \n        and nothing is added to the output collection.\n\n        The items in the collection may also represent a `Reference`, in which case the `Reference.reference` is resolved. \n        If the input is empty, the output will be empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem])): The output collection.\n        \"\"\"\n        from fhircraft.fhir.resources.factory import construct_resource_model\n        from fhircraft.fhir.resources.datatypes import get_complex_FHIR_type\n\n        collection = ensure_list(collection)\n        output_collection = []\n        for item in collection:\n            print(item.value)\n            if 'Reference' in type(item.value).__name__:\n                resource_url = item.value.reference\n            elif isinstance(item.value, str):\n                resource_url = item.value \n            else:\n                raise FHIRPathError('The resolve() function requires either a collection of URIs, Canonicals, URLs or References.')\n            if not resource_url.startswith('http://') and not resource_url.startswith('https://'):\n                return []\n            resource = load_url(resource_url)\n            profile_url = resource.get('meta',{}).get('profile',[None])[0]\n            if profile_url:\n                profile = construct_resource_model(profile_url)\n                resource = profile.model_validate(resource)\n            output_collection.append(resource)\n        return output_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/additional/#fhircraft.fhir.path.engine.additional.Resolve.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>For each item in the collection, if it is a string that is a <code>uri</code> (or <code>canonical</code> or <code>url</code>), locate the target of the reference, and add it to the resulting collection. If the item does not resolve to a resource, the item is ignored  and nothing is added to the output collection.</p> <p>The items in the collection may also represent a <code>Reference</code>, in which case the <code>Reference.reference</code> is resolved.  If the input is empty, the output will be empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem])</code> <p>The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/additional.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    For each item in the collection, if it is a string that is a `uri` (or `canonical` or `url`), locate the target of the\n    reference, and add it to the resulting collection. If the item does not resolve to a resource, the item is ignored \n    and nothing is added to the output collection.\n\n    The items in the collection may also represent a `Reference`, in which case the `Reference.reference` is resolved. \n    If the input is empty, the output will be empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem])): The output collection.\n    \"\"\"\n    from fhircraft.fhir.resources.factory import construct_resource_model\n    from fhircraft.fhir.resources.datatypes import get_complex_FHIR_type\n\n    collection = ensure_list(collection)\n    output_collection = []\n    for item in collection:\n        print(item.value)\n        if 'Reference' in type(item.value).__name__:\n            resource_url = item.value.reference\n        elif isinstance(item.value, str):\n            resource_url = item.value \n        else:\n            raise FHIRPathError('The resolve() function requires either a collection of URIs, Canonicals, URLs or References.')\n        if not resource_url.startswith('http://') and not resource_url.startswith('https://'):\n            return []\n        resource = load_url(resource_url)\n        profile_url = resource.get('meta',{}).get('profile',[None])[0]\n        if profile_url:\n            profile = construct_resource_model(profile_url)\n            resource = profile.model_validate(resource)\n        output_collection.append(resource)\n    return output_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/","title":"Boolean","text":"<p>For all boolean operators, the collections passed as operands are first evaluated as Booleans. The operators then use three-valued logic to propagate empty operands.</p>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.And","title":"<code>And</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>and</code> boolean logic operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>class And(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`and`](https://hl7.org/fhirpath/N1/#and) boolean logic operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if both operands evaluate to `True`, `False` if either operand evaluates to `False`, and the empty collection (`[]`) otherwise.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if left_boolean is None:\n            if right_boolean is True:\n                return []\n            elif right_boolean is False:\n                return False\n            elif right_boolean is None:\n                return []\n        elif right_boolean is None:\n            if left_boolean is True:\n                return []\n            elif left_boolean is False:\n                return False\n            elif left_boolean is None:\n                return []\n        return left_boolean and right_boolean\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, And) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.And.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if both operands evaluate to <code>True</code>, <code>False</code> if either operand evaluates to <code>False</code>, and the empty collection (<code>[]</code>) otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if both operands evaluate to `True`, `False` if either operand evaluates to `False`, and the empty collection (`[]`) otherwise.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if left_boolean is None:\n        if right_boolean is True:\n            return []\n        elif right_boolean is False:\n            return False\n        elif right_boolean is None:\n            return []\n    elif right_boolean is None:\n        if left_boolean is True:\n            return []\n        elif left_boolean is False:\n            return False\n        elif left_boolean is None:\n            return []\n    return left_boolean and right_boolean\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Implies","title":"<code>Implies</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>implies</code> boolean logic operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>class Implies(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`implies`](https://hl7.org/fhirpath/N1/#implies) boolean logic operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        If the left operand evaluates to `True`, this operator returns the boolean evaluation of the right operand. If the\n        left operand evaluates to `False`, this operator returns `True`. Otherwise, this operator returns `True` if the right\n        operand evaluates to `True`, and the empty collection (`[]`) otherwise.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if left_boolean is None:\n            if right_boolean is True:\n                return True\n            elif right_boolean is False:\n                return []\n            elif right_boolean is None:\n                return []\n        elif right_boolean is None:\n            if left_boolean is True:\n                return []\n            elif left_boolean is False:\n                return True\n            elif left_boolean is None:\n                return []\n        elif left_boolean is True:\n            if right_boolean is True:\n                return True\n            elif right_boolean is False:\n                return False\n        elif right_boolean is True:\n            if left_boolean is True:\n                return True\n            elif left_boolean is False:\n                return True\n        elif right_boolean is False and left_boolean is False:\n            return True\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Implies) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Implies.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the left operand evaluates to <code>True</code>, this operator returns the boolean evaluation of the right operand. If the left operand evaluates to <code>False</code>, this operator returns <code>True</code>. Otherwise, this operator returns <code>True</code> if the right operand evaluates to <code>True</code>, and the empty collection (<code>[]</code>) otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    If the left operand evaluates to `True`, this operator returns the boolean evaluation of the right operand. If the\n    left operand evaluates to `False`, this operator returns `True`. Otherwise, this operator returns `True` if the right\n    operand evaluates to `True`, and the empty collection (`[]`) otherwise.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if left_boolean is None:\n        if right_boolean is True:\n            return True\n        elif right_boolean is False:\n            return []\n        elif right_boolean is None:\n            return []\n    elif right_boolean is None:\n        if left_boolean is True:\n            return []\n        elif left_boolean is False:\n            return True\n        elif left_boolean is None:\n            return []\n    elif left_boolean is True:\n        if right_boolean is True:\n            return True\n        elif right_boolean is False:\n            return False\n    elif right_boolean is True:\n        if left_boolean is True:\n            return True\n        elif left_boolean is False:\n            return True\n    elif right_boolean is False and left_boolean is False:\n        return True\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Not","title":"<code>Not</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>not</code> boolean logic function.</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>class Not(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`not`](https://hl7.org/fhirpath/N1/#not) boolean logic function.\n    \"\"\"\n    def evaluate(self, collection: Union[List[FHIRPathCollectionItem], bool], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if the input collection evaluates to `False`, and `False` if it evaluates to `True`. Otherwise, the result is empty (`[]`):\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        if isinstance(collection, bool):\n            boolean = collection\n        else:\n            collection = ensure_list(collection)\n            if len(collection) &gt; 0:\n                boolean = bool(collection)\n            else:\n                return []\n        return not boolean\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Not.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if the input collection evaluates to <code>False</code>, and <code>False</code> if it evaluates to <code>True</code>. Otherwise, the result is empty (<code>[]</code>):</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>def evaluate(self, collection: Union[List[FHIRPathCollectionItem], bool], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if the input collection evaluates to `False`, and `False` if it evaluates to `True`. Otherwise, the result is empty (`[]`):\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    if isinstance(collection, bool):\n        boolean = collection\n    else:\n        collection = ensure_list(collection)\n        if len(collection) &gt; 0:\n            boolean = bool(collection)\n        else:\n            return []\n    return not boolean\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>or</code> boolean logic operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>class Or(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`or`](https://hl7.org/fhirpath/N1/#or) boolean logic operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `False` if both operands evaluate to `False`, `True` if either operand evaluates to `True`, and empty (`[]`) otherwise.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if left_boolean is None:\n            if right_boolean is True:\n                return True\n            elif right_boolean is False:\n                return []\n            elif right_boolean is None:\n                return []\n        elif right_boolean is None:\n            if left_boolean is True:\n                return True\n            elif left_boolean is False:\n                return []\n            elif left_boolean is None:\n                return []\n        return left_boolean or right_boolean\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Or) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Or.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>False</code> if both operands evaluate to <code>False</code>, <code>True</code> if either operand evaluates to <code>True</code>, and empty (<code>[]</code>) otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `False` if both operands evaluate to `False`, `True` if either operand evaluates to `True`, and empty (`[]`) otherwise.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if left_boolean is None:\n        if right_boolean is True:\n            return True\n        elif right_boolean is False:\n            return []\n        elif right_boolean is None:\n            return []\n    elif right_boolean is None:\n        if left_boolean is True:\n            return True\n        elif left_boolean is False:\n            return []\n        elif left_boolean is None:\n            return []\n    return left_boolean or right_boolean\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Xor","title":"<code>Xor</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>xor</code> boolean logic operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>class Xor(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`xor`](https://hl7.org/fhirpath/N1/#xor) boolean logic operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if exactly one of the operands evaluates to `True`, `False` if either both operands evaluate to `True` or both operands evaluate to `False`, and the empty collection (`[]`) otherwise.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if left_boolean is None:\n            if right_boolean is True:\n                return []\n            elif right_boolean is False:\n                return []\n            elif right_boolean is None:\n                return []\n        elif right_boolean is None:\n            if left_boolean is True:\n                return []\n            elif left_boolean is False:\n                return []\n            elif left_boolean is None:\n                return []\n        return left_boolean ^ right_boolean\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Xor) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/boolean/#fhircraft.fhir.path.engine.boolean.Xor.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if exactly one of the operands evaluates to <code>True</code>, <code>False</code> if either both operands evaluate to <code>True</code> or both operands evaluate to <code>False</code>, and the empty collection (<code>[]</code>) otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/boolean.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if exactly one of the operands evaluates to `True`, `False` if either both operands evaluate to `True` or both operands evaluate to `False`, and the empty collection (`[]`) otherwise.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_boolean, right_boolean = _evaluate_boolean_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if left_boolean is None:\n        if right_boolean is True:\n            return []\n        elif right_boolean is False:\n            return []\n        elif right_boolean is None:\n            return []\n    elif right_boolean is None:\n        if left_boolean is True:\n            return []\n        elif left_boolean is False:\n            return []\n        elif left_boolean is None:\n            return []\n    return left_boolean ^ right_boolean\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/","title":"Collection","text":"<p>The comparison module contains the object representations of the collection FHIRPath operators.</p>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.Contains","title":"<code>Contains</code>","text":"<p>               Bases: <code>FHIRCollectionOperator</code></p> <p>A representation of the FHIRPath <code>contains</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>class Contains(FHIRCollectionOperator):\n    \"\"\"\n    A representation of the FHIRPath [`contains`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        If the right operand is a collection with a single item, this operator returns true if the item is in the\n        left operand using equality semantics. If the right-hand side of the operator is empty, the result is empty,\n        if the left-hand side is empty, the result is false. This is the converse operation of `in`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If the left expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        right = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in right]\n        if len(right)==0:\n            return []\n        if len(right)!=1:\n            raise FHIRPathError('Left expression evaluates to a non-singleton collection.')\n        value = right[0].value\n        check_collection = [item.value if isinstance(item, FHIRPathCollectionItem) else item for item in left]\n        return value in check_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.Contains.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the right operand is a collection with a single item, this operator returns true if the item is in the left operand using equality semantics. If the right-hand side of the operator is empty, the result is empty, if the left-hand side is empty, the result is false. This is the converse operation of <code>in</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If the left expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    If the right operand is a collection with a single item, this operator returns true if the item is in the\n    left operand using equality semantics. If the right-hand side of the operator is empty, the result is empty,\n    if the left-hand side is empty, the result is false. This is the converse operation of `in`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If the left expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    right = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in right]\n    if len(right)==0:\n        return []\n    if len(right)!=1:\n        raise FHIRPathError('Left expression evaluates to a non-singleton collection.')\n    value = right[0].value\n    check_collection = [item.value if isinstance(item, FHIRPathCollectionItem) else item for item in left]\n    return value in check_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.FHIRCollectionOperator","title":"<code>FHIRCollectionOperator</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>Abstract class definition for the category of collection FHIRPath operators.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>class FHIRCollectionOperator(FHIRPath):\n    \"\"\"\n    Abstract class definition for the category of collection FHIRPath operators. \n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        create = kwargs.get('create')\n        left_collection = [\n            item.value if isinstance(item, FHIRPathCollectionItem) else item \n                for item in ensure_list(self.left.evaluate(collection, create))\n        ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n\n        right_collection = [ \n            item.value if isinstance(item, FHIRPathCollectionItem) else item  \n                for item in ensure_list(self.right.evaluate(collection, create))\n        ] if isinstance(self.right, FHIRPath) else ensure_list(self.right)\n\n        return left_collection, right_collection\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.In","title":"<code>In</code>","text":"<p>               Bases: <code>FHIRCollectionOperator</code></p> <p>A representation of the FHIRPath <code>in</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>class In(FHIRCollectionOperator):\n    \"\"\"\n    A representation of the FHIRPath [`in`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        If the left operand is a collection with a single item, this operator returns true if the item is in the \n        right operand using equality semantics. If the left-hand side of the operator is empty, the result is empty,\n        if the right-hand side is empty, the result is false. If the left operand has multiple items, an exception is thrown.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If the left expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        left = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in left]\n        if len(left)==0:\n            return []\n        if len(left)!=1:\n            raise FHIRPathError('Left expression evaluates to a non-singleton collection.')\n        value = left[0].value\n        check_collection = [item.value if isinstance(item, FHIRPathCollectionItem) else item for item in right]\n        return value in check_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.In.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the left operand is a collection with a single item, this operator returns true if the item is in the  right operand using equality semantics. If the left-hand side of the operator is empty, the result is empty, if the right-hand side is empty, the result is false. If the left operand has multiple items, an exception is thrown.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If the left expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    If the left operand is a collection with a single item, this operator returns true if the item is in the \n    right operand using equality semantics. If the left-hand side of the operator is empty, the result is empty,\n    if the right-hand side is empty, the result is false. If the left operand has multiple items, an exception is thrown.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If the left expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    left = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in left]\n    if len(left)==0:\n        return []\n    if len(left)!=1:\n        raise FHIRPathError('Left expression evaluates to a non-singleton collection.')\n    value = left[0].value\n    check_collection = [item.value if isinstance(item, FHIRPathCollectionItem) else item for item in right]\n    return value in check_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.Union","title":"<code>Union</code>","text":"<p>               Bases: <code>FHIRCollectionOperator</code></p> <p>A representation of the FHIRPath <code>|</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>class Union(FHIRCollectionOperator):\n    \"\"\"\n    A representation of the FHIRPath [`|`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Merge the two collections into a single collection, eliminating any duplicate values to \n        determine equality). There is no expectation of order in the resulting collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem])): The output collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        left = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in left]\n        right = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in right]\n        return UnionFunction(left).evaluate(right)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/collection/#fhircraft.fhir.path.engine.collection.Union.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Merge the two collections into a single collection, eliminating any duplicate values to  determine equality). There is no expectation of order in the resulting collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem])</code> <p>The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/collection.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Merge the two collections into a single collection, eliminating any duplicate values to \n    determine equality). There is no expectation of order in the resulting collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem])): The output collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    left = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in left]\n    right = [FHIRPathCollectionItem(value=item) if not isinstance(item, FHIRPathCollectionItem) else item for item in right]\n    return UnionFunction(left).evaluate(right)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/combining/","title":"Combining","text":"<p>The filtering module contains the object representations of the combining-category FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/combining/#fhircraft.fhir.path.engine.combining.Combine","title":"<code>Combine</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>combine()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other_collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The other collection to combine with.</p> Source code in <code>fhircraft/fhir/path/engine/combining.py</code> <pre><code>class Combine(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`combine()`](https://hl7.org/fhirpath/N1/#combineother-collection-collection) function.\n\n    Attributes:\n        other_collection (List[FHIRPathCollectionItem]): The other collection to combine with.\n    \"\"\"\n    def __init__(self, other_collection: List[FHIRPathCollectionItem]):\n        self.other_collection = ensure_list(other_collection)\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Merge the input and other collections into a single collection without eliminating duplicate\n        values. Combining an empty collection with a non-empty collection will return the non-empty\n        collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return collection + self.other_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/combining/#fhircraft.fhir.path.engine.combining.Combine.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Merge the input and other collections into a single collection without eliminating duplicate values. Combining an empty collection with a non-empty collection will return the non-empty collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/combining.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Merge the input and other collections into a single collection without eliminating duplicate\n    values. Combining an empty collection with a non-empty collection will return the non-empty\n    collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return collection + self.other_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/combining/#fhircraft.fhir.path.engine.combining.Union","title":"<code>Union</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>union()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other_collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The other collection to combine with.</p> Source code in <code>fhircraft/fhir/path/engine/combining.py</code> <pre><code>class Union(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`union()`](https://hl7.org/fhirpath/N1/#unionother-collection) function.\n\n    Attributes:\n        other_collection (List[FHIRPathCollectionItem]): The other collection to combine with.\n    \"\"\"\n    def __init__(self, other_collection: List[FHIRPathCollectionItem]):\n        self.other_collection = ensure_list(other_collection)\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Merge the two collections into a single collection, eliminating any duplicate values. \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return sorted(list(set(collection) | set(self.other_collection)), key=lambda item: item.value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/combining/#fhircraft.fhir.path.engine.combining.Union.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Merge the two collections into a single collection, eliminating any duplicate values. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/combining.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Merge the two collections into a single collection, eliminating any duplicate values. \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return sorted(list(set(collection) | set(self.other_collection)), key=lambda item: item.value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/","title":"Comparison","text":"<p>The comparison module contains the object representations of the comparison FHIRPath operators.</p>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.FHIRComparisonOperator","title":"<code>FHIRComparisonOperator</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>Abstract class definition for the category of comparison FHIRPath operators.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>class FHIRComparisonOperator(FHIRPath):\n    \"\"\"\n    Abstract class definition for the category of comparison FHIRPath operators. \n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def convert_to_fhirpath_types(self, item):\n        if 'Quantity' in type(item).__name__:\n            return Quantity(item.value, item.code)\n        else:\n            return item \n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        create = kwargs.get('create')\n        left_collection = [\n            item.value if isinstance(item, FHIRPathCollectionItem) else item \n                for item in ensure_list(self.left.evaluate(collection, create))\n        ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n        left_collection = [self.convert_to_fhirpath_types(item) for item in left_collection]\n\n        right_collection = [ \n            item.value if isinstance(item, FHIRPathCollectionItem) else item  \n                for item in ensure_list(self.right.evaluate(collection, create))\n        ] if isinstance(self.right, FHIRPath) else ensure_list(self.right)\n        right_collection = [self.convert_to_fhirpath_types(item) for item in right_collection]\n\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the left expression, instead got a {len(collection)}-items collection.')\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the right expression, instead got a {len(collection)}-items collection.')\n        if len(left_collection)==0 or len(right_collection)==0:\n            return None, None\n        return left_collection[0], right_collection[0]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.GreaterEqualThan","title":"<code>GreaterEqualThan</code>","text":"<p>               Bases: <code>FHIRComparisonOperator</code></p> <p>A representation of the FHIRPath <code>&gt;=</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>class GreaterEqualThan(FHIRComparisonOperator):\n    \"\"\"\n    A representation of the FHIRPath [`&gt;=`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The greater or equal operator (&gt;=) returns true if the first operand is greater than or equal to the second. \n        The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not left and not right: return None, None\n        return left &gt;= right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.GreaterEqualThan.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The greater or equal operator (&gt;=) returns true if the first operand is greater than or equal to the second.  The operands must be of the same type, or convertible to the same type using implicit conversion.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The greater or equal operator (&gt;=) returns true if the first operand is greater than or equal to the second. \n    The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not left and not right: return None, None\n    return left &gt;= right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.GreaterThan","title":"<code>GreaterThan</code>","text":"<p>               Bases: <code>FHIRComparisonOperator</code></p> <p>A representation of the FHIRPath <code>&gt;</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>class GreaterThan(FHIRComparisonOperator):\n    \"\"\"\n    A representation of the FHIRPath [`&gt;`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The greater than operator (&gt;) returns true if the first operand is strictly greater than the second.\n        The operands must be of the same type, or convertible to the same type using an implicit conversion.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not left and not right: return None, None\n        return left &gt; right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.GreaterThan.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The greater than operator (&gt;) returns true if the first operand is strictly greater than the second. The operands must be of the same type, or convertible to the same type using an implicit conversion.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The greater than operator (&gt;) returns true if the first operand is strictly greater than the second.\n    The operands must be of the same type, or convertible to the same type using an implicit conversion.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not left and not right: return None, None\n    return left &gt; right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.LessEqualThan","title":"<code>LessEqualThan</code>","text":"<p>               Bases: <code>FHIRComparisonOperator</code></p> <p>A representation of the FHIRPath <code>&lt;=</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>class LessEqualThan(FHIRComparisonOperator):\n    \"\"\"\n    A representation of the FHIRPath [`&lt;=`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The less or equal operator (&lt;=) returns true if the first operand is less than or equal to the second.\n        The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not left and not right: return None, None\n        return left &lt;= right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.LessEqualThan.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The less or equal operator (&lt;=) returns true if the first operand is less than or equal to the second. The operands must be of the same type, or convertible to the same type using implicit conversion.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The less or equal operator (&lt;=) returns true if the first operand is less than or equal to the second.\n    The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not left and not right: return None, None\n    return left &lt;= right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.LessThan","title":"<code>LessThan</code>","text":"<p>               Bases: <code>FHIRComparisonOperator</code></p> <p>A representation of the FHIRPath <code>&lt;</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>class LessThan(FHIRComparisonOperator):\n    \"\"\"\n    A representation of the FHIRPath [`&lt;`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The less than operator (&lt;) returns true if the first operand is strictly less than the second. \n        The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not left and not right: return None, None\n        return left &lt; right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/comparison/#fhircraft.fhir.path.engine.comparison.LessThan.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The less than operator (&lt;) returns true if the first operand is strictly less than the second.  The operands must be of the same type, or convertible to the same type using implicit conversion.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/comparison.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The less than operator (&lt;) returns true if the first operand is strictly less than the second. \n    The operands must be of the same type, or convertible to the same type using implicit conversion.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not left and not right: return None, None\n    return left &lt; right\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/","title":"Conversion","text":"<p>FHIRPath defines both implicit and explicit conversion. Implicit conversions occur automatically, as opposed to explicit conversions that require a function in this section to be called explicitly.</p>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToBoolean","title":"<code>ConvertsToBoolean</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToBoolean()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToBoolean(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToBoolean()`](http://hl7.org/fhirpath/N1/#convertstoboolean-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is a `Boolean`\n            - the item is an `Integer` that is equal to one of the possible integer representations of `Boolean` values\n            - the item is a `Decimal` that is equal to one of the possible decimal representations of `Boolean` values\n            - the item is a `String` that is equal to one of the possible string representations of `Boolean` values\n\n        If the item is not one of the above types, or the item is a `String`, `Integer`, or `Decimal`, but is not equal to one of the possible values convertible to a `Boolean`, the result is false.\n        If the input collection is empty, the result is empty ('[]').\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToBoolean().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToBoolean.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is a <code>Boolean</code>     - the item is an <code>Integer</code> that is equal to one of the possible integer representations of <code>Boolean</code> values     - the item is a <code>Decimal</code> that is equal to one of the possible decimal representations of <code>Boolean</code> values     - the item is a <code>String</code> that is equal to one of the possible string representations of <code>Boolean</code> values</p> <p>If the item is not one of the above types, or the item is a <code>String</code>, <code>Integer</code>, or <code>Decimal</code>, but is not equal to one of the possible values convertible to a <code>Boolean</code>, the result is false. If the input collection is empty, the result is empty ('[]').</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is a `Boolean`\n        - the item is an `Integer` that is equal to one of the possible integer representations of `Boolean` values\n        - the item is a `Decimal` that is equal to one of the possible decimal representations of `Boolean` values\n        - the item is a `String` that is equal to one of the possible string representations of `Boolean` values\n\n    If the item is not one of the above types, or the item is a `String`, `Integer`, or `Decimal`, but is not equal to one of the possible values convertible to a `Boolean`, the result is false.\n    If the input collection is empty, the result is empty ('[]').\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToBoolean().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDate","title":"<code>ConvertsToDate</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToDate()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToDate(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToDate()`](http://hl7.org/fhirpath/N1/#convertstodate-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is a `Date`\n            - the item is a `DateTime`\n            - the item is a `String` and is convertible to a `Date`\n        If the item is not one of the above types, or is not convertible to a `Date` (using the format `YYYY-MM-DD`), the result is `False`.\n        If the item contains a partial date (e.g. `'2012-01'`), the result is a partial date.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToDate().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDate.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is a <code>Date</code>     - the item is a <code>DateTime</code>     - the item is a <code>String</code> and is convertible to a <code>Date</code> If the item is not one of the above types, or is not convertible to a <code>Date</code> (using the format <code>YYYY-MM-DD</code>), the result is <code>False</code>. If the item contains a partial date (e.g. <code>'2012-01'</code>), the result is a partial date. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is a `Date`\n        - the item is a `DateTime`\n        - the item is a `String` and is convertible to a `Date`\n    If the item is not one of the above types, or is not convertible to a `Date` (using the format `YYYY-MM-DD`), the result is `False`.\n    If the item contains a partial date (e.g. `'2012-01'`), the result is a partial date.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToDate().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDateTime","title":"<code>ConvertsToDateTime</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToDateTime()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToDateTime(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToDateTime()`](http://hl7.org/fhirpath/N1/#convertstodatetime-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is a `DateTime`\n            - the item is a `Date`, in which case the result is a `DateTime` with the year, month, and day of the `Date`, and the time components empty (not set to zero)\n            - the item is a `String` and is convertible to a `DateTime`\n        If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm`), the result is `False`.\n        If the item contains a partial datetime (e.g. `'2012-01-01T10:00'`), the result is 'True'.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToDateTime().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDateTime.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is a <code>DateTime</code>     - the item is a <code>Date</code>, in which case the result is a <code>DateTime</code> with the year, month, and day of the <code>Date</code>, and the time components empty (not set to zero)     - the item is a <code>String</code> and is convertible to a <code>DateTime</code> If the item is a <code>String</code>, but the string is not convertible to a <code>DateTime</code> (using the format <code>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</code>), the result is <code>False</code>. If the item contains a partial datetime (e.g. <code>'2012-01-01T10:00'</code>), the result is 'True'. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is a `DateTime`\n        - the item is a `Date`, in which case the result is a `DateTime` with the year, month, and day of the `Date`, and the time components empty (not set to zero)\n        - the item is a `String` and is convertible to a `DateTime`\n    If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm`), the result is `False`.\n    If the item contains a partial datetime (e.g. `'2012-01-01T10:00'`), the result is 'True'.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToDateTime().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDecimal","title":"<code>ConvertsToDecimal</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToDecimal()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToDecimal(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToDecimal()`](http://hl7.org/fhirpath/N1/#convertstodecimal-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is an `Integer` or `Decimal`\n            - the item is a `String` and is convertible to a `Decimal`\n            - the item is a `Boolean`, where `True` results in a `1.0` and `False` results in a `0.0`.\n        If the item is not one of the above types, or is not convertible to a `Decimal`, the result is `False`.\n        If the input collection is empty, the result is empty ('[]').\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToDecimal().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToDecimal.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is an <code>Integer</code> or <code>Decimal</code>     - the item is a <code>String</code> and is convertible to a <code>Decimal</code>     - the item is a <code>Boolean</code>, where <code>True</code> results in a <code>1.0</code> and <code>False</code> results in a <code>0.0</code>. If the item is not one of the above types, or is not convertible to a <code>Decimal</code>, the result is <code>False</code>. If the input collection is empty, the result is empty ('[]').</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is an `Integer` or `Decimal`\n        - the item is a `String` and is convertible to a `Decimal`\n        - the item is a `Boolean`, where `True` results in a `1.0` and `False` results in a `0.0`.\n    If the item is not one of the above types, or is not convertible to a `Decimal`, the result is `False`.\n    If the input collection is empty, the result is empty ('[]').\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToDecimal().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToInteger","title":"<code>ConvertsToInteger</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToInteger()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToInteger(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToInteger()`](http://hl7.org/fhirpath/N1/#convertstointeger-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is an `Integer`\n            - the item is a `String` and is convertible to an integer\n            - the item is a `Boolean`, where `True` results in a 1 and `False` results in a 0.\n        If the item is not one of the above types, or the item is a `String`, but is not convertible to an `Integer`, the result is false.\n        If the input collection is empty, the result is empty ('[]').\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToInteger().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToInteger.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is an <code>Integer</code>     - the item is a <code>String</code> and is convertible to an integer     - the item is a <code>Boolean</code>, where <code>True</code> results in a 1 and <code>False</code> results in a 0. If the item is not one of the above types, or the item is a <code>String</code>, but is not convertible to an <code>Integer</code>, the result is false. If the input collection is empty, the result is empty ('[]').</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is an `Integer`\n        - the item is a `String` and is convertible to an integer\n        - the item is a `Boolean`, where `True` results in a 1 and `False` results in a 0.\n    If the item is not one of the above types, or the item is a `String`, but is not convertible to an `Integer`, the result is false.\n    If the input collection is empty, the result is empty ('[]').\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToInteger().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToQuantity","title":"<code>ConvertsToQuantity</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToQuantity()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToQuantity(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToQuantity()`](http://hl7.org/fhirpath/N1/#convertstoquantity-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is an `Integer`, or `Decimal`, where the resulting quantity will have the default unit (`'1'`)\n            - the item is a `Quantity`\n            - the item is a `String` and is convertible to a `Quantity`\n            - the item is a `Boolean`, where true results in the quantity `1.0 '1'`, and false results in the quantity `0.0 '1'`\n        If the item is not one of the above types, the result is `False`.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToQuantity().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToQuantity.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is an <code>Integer</code>, or <code>Decimal</code>, where the resulting quantity will have the default unit (<code>'1'</code>)     - the item is a <code>Quantity</code>     - the item is a <code>String</code> and is convertible to a <code>Quantity</code>     - the item is a <code>Boolean</code>, where true results in the quantity <code>1.0 '1'</code>, and false results in the quantity <code>0.0 '1'</code> If the item is not one of the above types, the result is <code>False</code>. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is an `Integer`, or `Decimal`, where the resulting quantity will have the default unit (`'1'`)\n        - the item is a `Quantity`\n        - the item is a `String` and is convertible to a `Quantity`\n        - the item is a `Boolean`, where true results in the quantity `1.0 '1'`, and false results in the quantity `0.0 '1'`\n    If the item is not one of the above types, the result is `False`.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToQuantity().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToString","title":"<code>ConvertsToString</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToString()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToString(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToString()`](http://hl7.org/fhirpath/N1/#convertstostring-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item in the input collection is a `String`\n            - the item in the input collection is an `Integer`, `Decimal`, `Date`, `Time`, `DateTime`, or `Quantity` the output will contain its `String` representation\n            - the item is a `Boolean`, where true results in `'true'` and false in `'false'`.\n        If the item is not one of the above types, the result is `False`.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToString().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToString.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item in the input collection is a <code>String</code>     - the item in the input collection is an <code>Integer</code>, <code>Decimal</code>, <code>Date</code>, <code>Time</code>, <code>DateTime</code>, or <code>Quantity</code> the output will contain its <code>String</code> representation     - the item is a <code>Boolean</code>, where true results in <code>'true'</code> and false in <code>'false'</code>. If the item is not one of the above types, the result is <code>False</code>. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item in the input collection is a `String`\n        - the item in the input collection is an `Integer`, `Decimal`, `Date`, `Time`, `DateTime`, or `Quantity` the output will contain its `String` representation\n        - the item is a `Boolean`, where true results in `'true'` and false in `'false'`.\n    If the item is not one of the above types, the result is `False`.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToString().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToTime","title":"<code>ConvertsToTime</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>convertsToTime()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ConvertsToTime(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`convertsToTime()`](http://hl7.org/fhirpath/N1/#convertstotime-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return `True` if:\n            - the item is a `Time`\n            - the item is a `String` and is convertible to a `Time`\n        If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `hh:mm:ss.fff(+|-)hh:mm`), the result is `False`.\n        If the item contains a partial datetime (e.g. `'10:00'`), the result is 'True'.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return ToTime().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ConvertsToTime.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return <code>True</code> if:     - the item is a <code>Time</code>     - the item is a <code>String</code> and is convertible to a <code>Time</code> If the item is a <code>String</code>, but the string is not convertible to a <code>DateTime</code> (using the format <code>hh:mm:ss.fff(+|-)hh:mm</code>), the result is <code>False</code>. If the item contains a partial datetime (e.g. <code>'10:00'</code>), the result is 'True'. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>int</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return `True` if:\n        - the item is a `Time`\n        - the item is a `String` and is convertible to a `Time`\n    If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `hh:mm:ss.fff(+|-)hh:mm`), the result is `False`.\n    If the item contains a partial datetime (e.g. `'10:00'`), the result is 'True'.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return ToTime().evaluate(collection) != []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.FHIRTypeConversionFunction","title":"<code>FHIRTypeConversionFunction</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Abstract class definition for the category of type conversion FHIRPath functions.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class FHIRTypeConversionFunction(FHIRPathFunction):    \n    \"\"\"\n    Abstract class definition for the category of type conversion FHIRPath functions. \n    \"\"\"\n    def validate_collection(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Validates the input collection of a FHIRPath type conversion function. \n\n        Args: \n            collection (List[FHIRPathCollectionItem]): Collection to be validated.\n\n        Returns: \n            collection (List[FHIRPathCollectionItem]): Validated collection.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\"\n        collection = ensure_list(collection)\n        if len(collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n        return collection \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.FHIRTypeConversionFunction.validate_collection","title":"<code>validate_collection(collection, *args, **kwargs)</code>","text":"<p>Validates the input collection of a FHIRPath type conversion function. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>Collection to be validated.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>Validated collection.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def validate_collection(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Validates the input collection of a FHIRPath type conversion function. \n\n    Args: \n        collection (List[FHIRPathCollectionItem]): Collection to be validated.\n\n    Returns: \n        collection (List[FHIRPathCollectionItem]): Validated collection.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\"\n    collection = ensure_list(collection)\n    if len(collection)&gt;1:\n        raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n    return collection \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.Iif","title":"<code>Iif</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>iif()</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>criterion</code> <code>FHIRPath</code> <p>The criterion expression,  is expected to evaluate to a <code>Boolean</code>.</p> required <code>true_result</code> <code>Union[FHIRPath, Any]</code> <p>Value to be returned if <code>criterion</code> evaluates to <code>True</code></p> required <code>otherwise_result</code> <code>Optional[Union[FHIRPath, Any]]</code> <p>Value to be returned if <code>criterion</code> evaluates to <code>False</code>. Defaults to an empty collection.</p> <code>None</code> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class Iif(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`iif()`](http://hl7.org/fhirpath/N1/#iifcriterion-expression-true-result-collection-otherwise-result-collection-collection) function.\n\n    Args:\n        criterion (FHIRPath): The criterion expression,  is expected to evaluate to a `Boolean`.\n        true_result (Union[FHIRPath, Any]): Value to be returned if `criterion` evaluates to `True`\n        otherwise_result (Optional[Union[FHIRPath, Any]]): Value to be returned if `criterion` evaluates to `False`. Defaults to an empty collection.\n    \"\"\"\n    def __init__(self, criterion, true_result, otherwise_result=None):\n        self.criterion = criterion \n        self.true_result = true_result \n        self.otherwise_result = otherwise_result \n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Thif function acts as an immediate if, also known as a conditional operator.\n\n        If `criterion` evaluates to `True`, the function returns the value of the `true_result` argument. \n        If `true_result` is a FHIRPath expression it is evaluated.  \n\n        If `criterion` is `False` or an empty collection, the function returns the `otherwise_result` argument,\n        unless the optional `otherwise_result` is not given, in which case the function returns an empty collection.\n        If `otherwise_result` is a FHIRPath expression it is evaluated.  \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n\n        \"\"\" \n        collection = ensure_list(collection)\n        criterion = self.criterion.evaluate(collection, **kwargs)\n        if criterion:\n            if isinstance(self.true_result, FHIRPath):\n                return self.true_result.evaluate(collection, **kwargs)\n            else:\n                return self.true_result\n        else:\n            if self.otherwise_result:\n                if isinstance(self.otherwise_result, FHIRPath):\n                    return self.otherwise_result.evaluate(collection, **kwargs)\n                else:\n                    return self.otherwise_result\n            else:\n                return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.Iif.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Thif function acts as an immediate if, also known as a conditional operator.</p> <p>If <code>criterion</code> evaluates to <code>True</code>, the function returns the value of the <code>true_result</code> argument.  If <code>true_result</code> is a FHIRPath expression it is evaluated.  </p> <p>If <code>criterion</code> is <code>False</code> or an empty collection, the function returns the <code>otherwise_result</code> argument, unless the optional <code>otherwise_result</code> is not given, in which case the function returns an empty collection. If <code>otherwise_result</code> is a FHIRPath expression it is evaluated.  </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Thif function acts as an immediate if, also known as a conditional operator.\n\n    If `criterion` evaluates to `True`, the function returns the value of the `true_result` argument. \n    If `true_result` is a FHIRPath expression it is evaluated.  \n\n    If `criterion` is `False` or an empty collection, the function returns the `otherwise_result` argument,\n    unless the optional `otherwise_result` is not given, in which case the function returns an empty collection.\n    If `otherwise_result` is a FHIRPath expression it is evaluated.  \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n\n    \"\"\" \n    collection = ensure_list(collection)\n    criterion = self.criterion.evaluate(collection, **kwargs)\n    if criterion:\n        if isinstance(self.true_result, FHIRPath):\n            return self.true_result.evaluate(collection, **kwargs)\n        else:\n            return self.true_result\n    else:\n        if self.otherwise_result:\n            if isinstance(self.otherwise_result, FHIRPath):\n                return self.otherwise_result.evaluate(collection, **kwargs)\n            else:\n                return self.otherwise_result\n        else:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToBoolean","title":"<code>ToBoolean</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toBoolean()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToBoolean(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toBoolean()`](http://hl7.org/fhirpath/N1/#boolean-conversion-functions) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single `Boolean` if:\n            - the item is a `Boolean`\n            - the item is an `Integer` that is equal to one of the possible integer representations of `Boolean` values\n            - the item is a `Decimal` that is equal to one of the possible decimal representations of `Boolean` values\n            - the item is a `String` that is equal to one of the possible string representations of `Boolean` values\n\n        If the item is not one of the above types, or the item is a `String`, `Integer`, or `Decimal`, but is not equal to one of the possible values convertible to a `Boolean`, the result is false.\n        If the input collection is empty, the result is empty ('[]').\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, str):\n            if value.lower() in ['true', 't', 'yes', 'y', '1', '1.0']:\n                return True \n            elif value.lower() in ['false', 'f', 'no', 'n', '0', '0.0']:\n                return False \n            else:\n                return []\n        elif isinstance(value, (int, float)):\n            return bool(value) \n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToBoolean.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single <code>Boolean</code> if:     - the item is a <code>Boolean</code>     - the item is an <code>Integer</code> that is equal to one of the possible integer representations of <code>Boolean</code> values     - the item is a <code>Decimal</code> that is equal to one of the possible decimal representations of <code>Boolean</code> values     - the item is a <code>String</code> that is equal to one of the possible string representations of <code>Boolean</code> values</p> <p>If the item is not one of the above types, or the item is a <code>String</code>, <code>Integer</code>, or <code>Decimal</code>, but is not equal to one of the possible values convertible to a <code>Boolean</code>, the result is false. If the input collection is empty, the result is empty ('[]').</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single `Boolean` if:\n        - the item is a `Boolean`\n        - the item is an `Integer` that is equal to one of the possible integer representations of `Boolean` values\n        - the item is a `Decimal` that is equal to one of the possible decimal representations of `Boolean` values\n        - the item is a `String` that is equal to one of the possible string representations of `Boolean` values\n\n    If the item is not one of the above types, or the item is a `String`, `Integer`, or `Decimal`, but is not equal to one of the possible values convertible to a `Boolean`, the result is false.\n    If the input collection is empty, the result is empty ('[]').\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, str):\n        if value.lower() in ['true', 't', 'yes', 'y', '1', '1.0']:\n            return True \n        elif value.lower() in ['false', 'f', 'no', 'n', '0', '0.0']:\n            return False \n        else:\n            return []\n    elif isinstance(value, (int, float)):\n        return bool(value) \n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDate","title":"<code>ToDate</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toDate()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToDate(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toDate()`](http://hl7.org/fhirpath/N1/#todate-date) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single date if:\n            - the item is a `Date`\n            - the item is a `DateTime`\n            - the item is a `String` and is convertible to a `Date`\n        If the item is not one of the above types, or is not convertible to a `Date` (using the format `YYYY-MM-DD`), the result is empty.\n        If the item contains a partial date (e.g. `'2012-01'`), the result is a partial date.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            str: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, str):\n            date_match = re.match(fr'^{primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?$', value)\n            datetime_match = re.match(fr'^({primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?)(T{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?)?', value)\n            if date_match:\n                return value\n            elif datetime_match:\n                return datetime_match.group(1)\n            else:\n                return []\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDate.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single date if:     - the item is a <code>Date</code>     - the item is a <code>DateTime</code>     - the item is a <code>String</code> and is convertible to a <code>Date</code> If the item is not one of the above types, or is not convertible to a <code>Date</code> (using the format <code>YYYY-MM-DD</code>), the result is empty. If the item contains a partial date (e.g. <code>'2012-01'</code>), the result is a partial date. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single date if:\n        - the item is a `Date`\n        - the item is a `DateTime`\n        - the item is a `String` and is convertible to a `Date`\n    If the item is not one of the above types, or is not convertible to a `Date` (using the format `YYYY-MM-DD`), the result is empty.\n    If the item contains a partial date (e.g. `'2012-01'`), the result is a partial date.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        str: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, str):\n        date_match = re.match(fr'^{primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?$', value)\n        datetime_match = re.match(fr'^({primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?)(T{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?)?', value)\n        if date_match:\n            return value\n        elif datetime_match:\n            return datetime_match.group(1)\n        else:\n            return []\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDateTime","title":"<code>ToDateTime</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toDateTime()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToDateTime(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toDateTime()`](http://hl7.org/fhirpath/N1/#todatetime-datetime) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single datetime if:\n            - the item is a `DateTime`\n            - the item is a `Date`, in which case the result is a `DateTime` with the year, month, and day of the `Date`, and the time components empty (not set to zero)\n            - the item is a `String` and is convertible to a `DateTime`\n        If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm`), the result is empty.\n        If the item contains a partial datetime (e.g. `'2012-01-01T10:00'`), the result is a partial datetime.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            str: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, str):\n            date_match = re.match(fr'^{primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?$', value)\n            datetime_match = re.match(fr'^({primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?)(T{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?)?', value)\n            if date_match or datetime_match:\n                return value\n            else:\n                return []\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDateTime.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single datetime if:     - the item is a <code>DateTime</code>     - the item is a <code>Date</code>, in which case the result is a <code>DateTime</code> with the year, month, and day of the <code>Date</code>, and the time components empty (not set to zero)     - the item is a <code>String</code> and is convertible to a <code>DateTime</code> If the item is a <code>String</code>, but the string is not convertible to a <code>DateTime</code> (using the format <code>YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm</code>), the result is empty. If the item contains a partial datetime (e.g. <code>'2012-01-01T10:00'</code>), the result is a partial datetime. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single datetime if:\n        - the item is a `DateTime`\n        - the item is a `Date`, in which case the result is a `DateTime` with the year, month, and day of the `Date`, and the time components empty (not set to zero)\n        - the item is a `String` and is convertible to a `DateTime`\n    If the item is a `String`, but the string is not convertible to a `DateTime` (using the format `YYYY-MM-DDThh:mm:ss.fff(+|-)hh:mm`), the result is empty.\n    If the item contains a partial datetime (e.g. `'2012-01-01T10:00'`), the result is a partial datetime.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        str: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, str):\n        date_match = re.match(fr'^{primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?$', value)\n        datetime_match = re.match(fr'^({primitives.YEAR_REGEX}(-{primitives.MONTH_REGEX}(-{primitives.DAY_REGEX})?)?)(T{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?)?', value)\n        if date_match or datetime_match:\n            return value\n        else:\n            return []\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDecimal","title":"<code>ToDecimal</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toDecimal()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToDecimal(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toDecimal()`](http://hl7.org/fhirpath/N1/#todecimal-decimal) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single decimal if:\n            - the item is an `Integer` or `Decimal`\n            - the item is a `String` and is convertible to a `Decimal`\n            - the item is a `Boolean`, where `True` results in a `1.0` and `False` results in a `0.0`.\n        If the item is not one of the above types, the result is empty (`[]`).\n        If the item is a `String`, but the string is not convertible to a `Decimal`, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            float: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, (int, float, bool)):\n            return float(value) \n        elif isinstance(value, str):\n            if re.match(r\"(\\\\+|-)?\\d+(\\.\\d+)?\", value):\n                return float(value)\n            else:\n                return []\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToDecimal.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single decimal if:     - the item is an <code>Integer</code> or <code>Decimal</code>     - the item is a <code>String</code> and is convertible to a <code>Decimal</code>     - the item is a <code>Boolean</code>, where <code>True</code> results in a <code>1.0</code> and <code>False</code> results in a <code>0.0</code>. If the item is not one of the above types, the result is empty (<code>[]</code>). If the item is a <code>String</code>, but the string is not convertible to a <code>Decimal</code>, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single decimal if:\n        - the item is an `Integer` or `Decimal`\n        - the item is a `String` and is convertible to a `Decimal`\n        - the item is a `Boolean`, where `True` results in a `1.0` and `False` results in a `0.0`.\n    If the item is not one of the above types, the result is empty (`[]`).\n    If the item is a `String`, but the string is not convertible to a `Decimal`, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        float: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, (int, float, bool)):\n        return float(value) \n    elif isinstance(value, str):\n        if re.match(r\"(\\\\+|-)?\\d+(\\.\\d+)?\", value):\n            return float(value)\n        else:\n            return []\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToInteger","title":"<code>ToInteger</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toInteger()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToInteger(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toInteger()`](http://hl7.org/fhirpath/N1/#tointeger-integer) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single `Integer` if:\n            - the item is an `Integer`\n            - the item is a `String` and is convertible to an integer\n            - the item is a `Boolean`, where `True` results in a 1 and `False` results in a 0.\n        If the item is not one the above types, the result is empty (`[]`).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            int: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, (int, bool)):\n            return int(value) \n        elif isinstance(value, str):\n            if re.match(r\"[+-]?\\d\", value):\n                return int(value)\n            else:\n                return []\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToInteger.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single <code>Integer</code> if:     - the item is an <code>Integer</code>     - the item is a <code>String</code> and is convertible to an integer     - the item is a <code>Boolean</code>, where <code>True</code> results in a 1 and <code>False</code> results in a 0. If the item is not one the above types, the result is empty (<code>[]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single `Integer` if:\n        - the item is an `Integer`\n        - the item is a `String` and is convertible to an integer\n        - the item is a `Boolean`, where `True` results in a 1 and `False` results in a 0.\n    If the item is not one the above types, the result is empty (`[]`).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        int: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, (int, bool)):\n        return int(value) \n    elif isinstance(value, str):\n        if re.match(r\"[+-]?\\d\", value):\n            return int(value)\n        else:\n            return []\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToQuantity","title":"<code>ToQuantity</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toQuantity()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToQuantity(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toQuantity()`](http://hl7.org/fhirpath/N1/#toquantity-string) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single quantity if:\n            - the item is an `Integer`, or `Decimal`, where the resulting quantity will have the default unit (`'1'`)\n            - the item is a `Quantity`\n            - the item is a `String` and is convertible to a `Quantity`\n            - the item is a `Boolean`, where true results in the quantity `1.0 '1'`, and false results in the quantity `0.0 '1'`\n        If the item is not one of the above types, the result is empty.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            Quantity: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        Quantity = get_complex_FHIR_type('Quantity')\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, (bool, int, float)):\n            return Quantity(value=float(value), unit='1')\n        elif isinstance(value, str):\n            quantity_match = re.match(r\"((\\+|-)?\\d+(\\.\\d+)?)\\s*(('([^']+)'|([a-zA-Z]+))?)\", value)\n            if quantity_match:\n                return Quantity(value=quantity_match.group(1), unit=quantity_match.group(4))\n            else:\n                return []\n        elif isinstance(value, Quantity):\n            return value\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToQuantity.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single quantity if:     - the item is an <code>Integer</code>, or <code>Decimal</code>, where the resulting quantity will have the default unit (<code>'1'</code>)     - the item is a <code>Quantity</code>     - the item is a <code>String</code> and is convertible to a <code>Quantity</code>     - the item is a <code>Boolean</code>, where true results in the quantity <code>1.0 '1'</code>, and false results in the quantity <code>0.0 '1'</code> If the item is not one of the above types, the result is empty. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>Quantity</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single quantity if:\n        - the item is an `Integer`, or `Decimal`, where the resulting quantity will have the default unit (`'1'`)\n        - the item is a `Quantity`\n        - the item is a `String` and is convertible to a `Quantity`\n        - the item is a `Boolean`, where true results in the quantity `1.0 '1'`, and false results in the quantity `0.0 '1'`\n    If the item is not one of the above types, the result is empty.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        Quantity: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    Quantity = get_complex_FHIR_type('Quantity')\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, (bool, int, float)):\n        return Quantity(value=float(value), unit='1')\n    elif isinstance(value, str):\n        quantity_match = re.match(r\"((\\+|-)?\\d+(\\.\\d+)?)\\s*(('([^']+)'|([a-zA-Z]+))?)\", value)\n        if quantity_match:\n            return Quantity(value=quantity_match.group(1), unit=quantity_match.group(4))\n        else:\n            return []\n    elif isinstance(value, Quantity):\n        return value\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToString","title":"<code>ToString</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toString()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToString(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toString()`](http://hl7.org/fhirpath/N1/#tostring-string) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single string if:\n            - the item in the input collection is a `String`\n            - the item in the input collection is an `Integer`, `Decimal`, `Date`, `Time`, `DateTime`, or `Quantity` the output will contain its `String` representation\n            - the item is a `Boolean`, where true results in `'true'` and false in `'false'`.\n        If the item is not one of the above types, the result is empty.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            str: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, bool):\n            return 'true' if value else 'false'\n        elif isinstance(value, (str, int, float)):\n            return str(value)\n        elif isinstance(value, get_complex_FHIR_type('Quantity')):\n            return f'{value.value} {value.unit}'\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToString.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single string if:     - the item in the input collection is a <code>String</code>     - the item in the input collection is an <code>Integer</code>, <code>Decimal</code>, <code>Date</code>, <code>Time</code>, <code>DateTime</code>, or <code>Quantity</code> the output will contain its <code>String</code> representation     - the item is a <code>Boolean</code>, where true results in <code>'true'</code> and false in <code>'false'</code>. If the item is not one of the above types, the result is empty. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single string if:\n        - the item in the input collection is a `String`\n        - the item in the input collection is an `Integer`, `Decimal`, `Date`, `Time`, `DateTime`, or `Quantity` the output will contain its `String` representation\n        - the item is a `Boolean`, where true results in `'true'` and false in `'false'`.\n    If the item is not one of the above types, the result is empty.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        str: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, bool):\n        return 'true' if value else 'false'\n    elif isinstance(value, (str, int, float)):\n        return str(value)\n    elif isinstance(value, get_complex_FHIR_type('Quantity')):\n        return f'{value.value} {value.unit}'\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToTime","title":"<code>ToTime</code>","text":"<p>               Bases: <code>FHIRTypeConversionFunction</code></p> <p>A representation of the FHIRPath <code>toTime()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>class ToTime(FHIRTypeConversionFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toTime()`](http://hl7.org/fhirpath/N1/#totime-time) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        If the input collection contains a single item, this function will return a single time if:\n            - the item is a `Time`\n            - the item is a `String` and is convertible to a `Time`\n        If the item is a `String`, but the string is not convertible to a `Time` (using the format `hh:mm:ss.fff(+|-)hh:mm`), the result is empty.\n        If the item contains a partial datetime (e.g. `'10:00'`), the result is a partial datetime.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            str: Converted value\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        value = collection[0].value\n        if isinstance(value, str):\n            time_match = re.match(fr'^{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?', value)\n            if time_match:\n                return value\n            else:\n                return []\n        else: \n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/conversion/#fhircraft.fhir.path.engine.conversion.ToTime.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the input collection contains a single item, this function will return a single time if:     - the item is a <code>Time</code>     - the item is a <code>String</code> and is convertible to a <code>Time</code> If the item is a <code>String</code>, but the string is not convertible to a <code>Time</code> (using the format <code>hh:mm:ss.fff(+|-)hh:mm</code>), the result is empty. If the item contains a partial datetime (e.g. <code>'10:00'</code>), the result is a partial datetime. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>int</code> <p>Converted value</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> Source code in <code>fhircraft/fhir/path/engine/conversion.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    If the input collection contains a single item, this function will return a single time if:\n        - the item is a `Time`\n        - the item is a `String` and is convertible to a `Time`\n    If the item is a `String`, but the string is not convertible to a `Time` (using the format `hh:mm:ss.fff(+|-)hh:mm`), the result is empty.\n    If the item contains a partial datetime (e.g. `'10:00'`), the result is a partial datetime.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        str: Converted value\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    value = collection[0].value\n    if isinstance(value, str):\n        time_match = re.match(fr'^{primitives.HOUR_REGEX}(:{primitives.MINUTES_REGEX}(:{primitives.SECONDS_REGEX}({primitives.TIMEZONE_REGEX})?)?)?', value)\n        if time_match:\n            return value\n        else:\n            return []\n    else: \n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/","title":"Core","text":""},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A class representing an element in a FHIRPath, used for navigating and manipulating FHIR resources.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>The name of the element.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class Element(FHIRPath):\n    \"\"\"\n    A class representing an element in a FHIRPath, used for navigating and manipulating FHIR resources.\n\n    Attributes:\n        label (str): The name of the element.\n    \"\"\"\n    def __init__(self, label: str):\n        self.label = label\n\n    def create_element(self, parent: typing.Any) -&gt; typing.Any:\n        \"\"\" \n        Ensure that the input parent object has the necessary field information to create a new element based on the label provided.\n\n        Args:\n            parent (Any): The parent object from which the element will be created.\n\n        Returns:\n            element (Any): The newly created element based on the field information of the parent object, or None if the parent is invalid or lacks the required field information.\n\n        Raises:\n            KeyError: If there is an issue with retrieving the field information from the parent object.\n            AttributeError: If there is an attribute error while trying to create the new element.\n        \"\"\"\n        if not parent:\n            return None\n        if not hasattr(parent, 'model_fields'):\n            return None \n        field_info = parent.model_fields.get(self.label)\n        try:\n            model = get_fhir_model_from_field(field_info)\n            new_element = model.model_construct()    \n        except (KeyError, AttributeError):\n            new_element = None \n        if field_info and contains_list_type(field_info.annotation):\n            new_element = ensure_list(new_element)\n        return new_element\n\n    @staticmethod\n    def setter(value: typing.Any, item: FHIRPathCollectionItem, index: int, label: str) -&gt; None:\n        \"\"\" \n        Sets the value of the specified element in the parent object.\n\n        Args:\n            value (Any): The value to set for the element.\n            item (FHIRPathCollectionItem): The parent collection item.\n            index (int): The index of the element in the parent object.\n            label (str): The label of the element to set.\n        \"\"\"\n        parent = item.value\n        parents = getattr(parent, label)\n        if not isinstance(parents, list):\n            setattr(parent, label, value)\n        else:\n            if len(parents)&lt;=index:\n                parents.insert(index, value)\n            else:                \n                parents[index] = value\n\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\" \n        Evaluate the collection of FHIRPathCollectionItems and create new elements if necessary.\n\n        Args:\n            collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItems to evaluate.\n            create (bool): A flag indicating whether to create new elements if they do not exist.\n\n        Returns:\n            List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItems after evaluation.\n        \"\"\"\n        collection = ensure_list(collection)\n        element_collection = []\n        for item in collection:\n            if not item.value:\n                continue\n            element_value = getattr(item.value, self.label, None)         \n            if not element_value and not isinstance(element_value, bool) and create:\n                element_value = self.create_element(item.value)  \n                setattr(item.value, self.label, element_value)  \n            for index, value in enumerate(ensure_list(element_value)):\n                if create or value is not None: \n                    element = FHIRPathCollectionItem(\n                        value, \n                        path=Element(self.label), \n                        parent=item, \n                        setter=partial(self.setter, item=item, index=index, label=self.label)\n                    )\n                    # element.set_value(value)\n                    element_collection.append(element)\n        return element_collection\n\n    def __str__(self):\n        return self.label\n\n    def __repr__(self):\n        return f'Element({self.label})'\n\n    def __eq__(self, other):\n        return isinstance(other, Element) and self.label == other.label\n\n    def __hash__(self):\n        return hash(self.label)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Element.create_element","title":"<code>create_element(parent)</code>","text":"<p>Ensure that the input parent object has the necessary field information to create a new element based on the label provided.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Any</code> <p>The parent object from which the element will be created.</p> required <p>Returns:</p> Name Type Description <code>element</code> <code>Any</code> <p>The newly created element based on the field information of the parent object, or None if the parent is invalid or lacks the required field information.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If there is an issue with retrieving the field information from the parent object.</p> <code>AttributeError</code> <p>If there is an attribute error while trying to create the new element.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def create_element(self, parent: typing.Any) -&gt; typing.Any:\n    \"\"\" \n    Ensure that the input parent object has the necessary field information to create a new element based on the label provided.\n\n    Args:\n        parent (Any): The parent object from which the element will be created.\n\n    Returns:\n        element (Any): The newly created element based on the field information of the parent object, or None if the parent is invalid or lacks the required field information.\n\n    Raises:\n        KeyError: If there is an issue with retrieving the field information from the parent object.\n        AttributeError: If there is an attribute error while trying to create the new element.\n    \"\"\"\n    if not parent:\n        return None\n    if not hasattr(parent, 'model_fields'):\n        return None \n    field_info = parent.model_fields.get(self.label)\n    try:\n        model = get_fhir_model_from_field(field_info)\n        new_element = model.model_construct()    \n    except (KeyError, AttributeError):\n        new_element = None \n    if field_info and contains_list_type(field_info.annotation):\n        new_element = ensure_list(new_element)\n    return new_element\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Element.evaluate","title":"<code>evaluate(collection, create)</code>","text":"<p>Evaluate the collection of FHIRPathCollectionItems and create new elements if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>A list of FHIRPathCollectionItems to evaluate.</p> required <code>create</code> <code>bool</code> <p>A flag indicating whether to create new elements if they do not exist.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItems after evaluation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\" \n    Evaluate the collection of FHIRPathCollectionItems and create new elements if necessary.\n\n    Args:\n        collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItems to evaluate.\n        create (bool): A flag indicating whether to create new elements if they do not exist.\n\n    Returns:\n        List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItems after evaluation.\n    \"\"\"\n    collection = ensure_list(collection)\n    element_collection = []\n    for item in collection:\n        if not item.value:\n            continue\n        element_value = getattr(item.value, self.label, None)         \n        if not element_value and not isinstance(element_value, bool) and create:\n            element_value = self.create_element(item.value)  \n            setattr(item.value, self.label, element_value)  \n        for index, value in enumerate(ensure_list(element_value)):\n            if create or value is not None: \n                element = FHIRPathCollectionItem(\n                    value, \n                    path=Element(self.label), \n                    parent=item, \n                    setter=partial(self.setter, item=item, index=index, label=self.label)\n                )\n                # element.set_value(value)\n                element_collection.append(element)\n    return element_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Element.setter","title":"<code>setter(value, item, index, label)</code>  <code>staticmethod</code>","text":"<p>Sets the value of the specified element in the parent object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to set for the element.</p> required <code>item</code> <code>FHIRPathCollectionItem</code> <p>The parent collection item.</p> required <code>index</code> <code>int</code> <p>The index of the element in the parent object.</p> required <code>label</code> <code>str</code> <p>The label of the element to set.</p> required Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>@staticmethod\ndef setter(value: typing.Any, item: FHIRPathCollectionItem, index: int, label: str) -&gt; None:\n    \"\"\" \n    Sets the value of the specified element in the parent object.\n\n    Args:\n        value (Any): The value to set for the element.\n        item (FHIRPathCollectionItem): The parent collection item.\n        index (int): The index of the element in the parent object.\n        label (str): The label of the element to set.\n    \"\"\"\n    parent = item.value\n    parents = getattr(parent, label)\n    if not isinstance(parents, list):\n        setattr(parent, label, value)\n    else:\n        if len(parents)&lt;=index:\n            parents.insert(index, value)\n        else:                \n            parents[index] = value\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath","title":"<code>FHIRPath</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing a FHIRPath, used for navigating and manipulating FHIR resources.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class FHIRPath(ABC):\n    \"\"\"\n    Abstract base class representing a FHIRPath, used for navigating and manipulating\n    FHIR resources.\n    \"\"\"\n\n    def get_value(self, data):\n        \"\"\"\n        Extracts the value(s) from the given data.\n\n        Args:\n            data (Any): The data from which to extract values.\n\n        Returns:\n            (Any): The extracted value(s), or None if no values are found.\n        \"\"\"\n        collection = self.find(data)\n        values = [item.value for item in collection if item.value and not isinstance(item.value, bool)]\n        if len(values) == 1:\n            values = values[0]\n        elif len(values) == 0:\n            return None\n        return values        \n\n\n    def find(self, collection: typing.Any) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Finds and returns a collection of FHIRPathCollectionItem instances from the input collection.\n\n        Args:\n            collection (Any): The input collection to search.\n\n        Returns:\n            List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n        \"\"\"\n        # Ensure that entrypoint is a FHIRPathCollectionItem instance\n        collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n        return self.evaluate(collection, create=False)\n\n    def find_or_create(self, collection) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Finds or creates and returns a collection of FHIRPathCollectionItem instances from the input collection.\n\n        Args:\n            collection (Any): The input collection to search or create items in.\n\n        Returns:\n            List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n        \"\"\"        \n        # Ensure that entrypoint is a FHIRPathCollectionItem instance\n        collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n        return self.evaluate(collection, create=True)\n\n    def update(self, collection, value) -&gt; None:\n        \"\"\"\n        Updates the input collection with the given value.\n\n        Args:\n            collection (Any): The input collection to update.\n            value (Any): The value to set in the collection.\n        \"\"\"        \n        # Ensure that entrypoint is a FHIRPathCollectionItem instance\n        collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n        # Collect the elements and set the values for each of them\n        new_collection = self.evaluate(collection, create=False)\n        for item in new_collection:\n            item.set_value(value)\n\n    def update_or_create(self, collection, value) -&gt; None:     \n        \"\"\"\n        Updates or creates the input collection with the given value.\n\n        Args:\n            collection (Any): The input collection to update or create items in.\n            value (Any): The value to set in the collection.\n        \"\"\"         \n        # Ensure that entrypoint is a FHIRPathCollectionItem instance\n        collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n        # Collect the elements and set the values for each of them\n        for item in self.evaluate(collection, create=True):\n            item.set_value(value)\n\n    def evaluate(self, collection, create: bool) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Evaluates the collection and returns a list of FHIRPathCollectionItem instances.\n\n        Args:\n            collection (Any): The input collection to evaluate.\n            create (bool): Flag indicating whether to create new items if they do not exist.\n\n        Returns:\n            List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n\n        Raises:\n            NotImplementedError: If the method is not implemented by a subclass.\n        \"\"\"\n        raise NotImplementedError()        \n\n    def child(self, child):\n        \"\"\"\n        Returns the child of this FHIRPath instance with some canonicalization.\n\n        Args:\n            child (Any): The child element.\n\n        Returns:\n            (Any): The canonicalized child element.\n        \"\"\"\n        if isinstance(self, This) or isinstance(self, Root):\n            return child\n        elif isinstance(child, This):\n            return self\n        elif isinstance(child, Root):\n            return child\n        else:\n            return Invocation(self, child)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.child","title":"<code>child(child)</code>","text":"<p>Returns the child of this FHIRPath instance with some canonicalization.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>Any</code> <p>The child element.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The canonicalized child element.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def child(self, child):\n    \"\"\"\n    Returns the child of this FHIRPath instance with some canonicalization.\n\n    Args:\n        child (Any): The child element.\n\n    Returns:\n        (Any): The canonicalized child element.\n    \"\"\"\n    if isinstance(self, This) or isinstance(self, Root):\n        return child\n    elif isinstance(child, This):\n        return self\n    elif isinstance(child, Root):\n        return child\n    else:\n        return Invocation(self, child)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.evaluate","title":"<code>evaluate(collection, create)</code>","text":"<p>Evaluates the collection and returns a list of FHIRPathCollectionItem instances.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Any</code> <p>The input collection to evaluate.</p> required <code>create</code> <code>bool</code> <p>Flag indicating whether to create new items if they do not exist.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented by a subclass.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection, create: bool) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Evaluates the collection and returns a list of FHIRPathCollectionItem instances.\n\n    Args:\n        collection (Any): The input collection to evaluate.\n        create (bool): Flag indicating whether to create new items if they do not exist.\n\n    Returns:\n        List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n\n    Raises:\n        NotImplementedError: If the method is not implemented by a subclass.\n    \"\"\"\n    raise NotImplementedError()        \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.find","title":"<code>find(collection)</code>","text":"<p>Finds and returns a collection of FHIRPathCollectionItem instances from the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Any</code> <p>The input collection to search.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def find(self, collection: typing.Any) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Finds and returns a collection of FHIRPathCollectionItem instances from the input collection.\n\n    Args:\n        collection (Any): The input collection to search.\n\n    Returns:\n        List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n    \"\"\"\n    # Ensure that entrypoint is a FHIRPathCollectionItem instance\n    collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n    return self.evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.find_or_create","title":"<code>find_or_create(collection)</code>","text":"<p>Finds or creates and returns a collection of FHIRPathCollectionItem instances from the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Any</code> <p>The input collection to search or create items in.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def find_or_create(self, collection) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Finds or creates and returns a collection of FHIRPathCollectionItem instances from the input collection.\n\n    Args:\n        collection (Any): The input collection to search or create items in.\n\n    Returns:\n        List[FHIRPathCollectionItem]: A list of FHIRPathCollectionItem instances.\n    \"\"\"        \n    # Ensure that entrypoint is a FHIRPathCollectionItem instance\n    collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n    return self.evaluate(collection, create=True)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.get_value","title":"<code>get_value(data)</code>","text":"<p>Extracts the value(s) from the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data from which to extract values.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The extracted value(s), or None if no values are found.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def get_value(self, data):\n    \"\"\"\n    Extracts the value(s) from the given data.\n\n    Args:\n        data (Any): The data from which to extract values.\n\n    Returns:\n        (Any): The extracted value(s), or None if no values are found.\n    \"\"\"\n    collection = self.find(data)\n    values = [item.value for item in collection if item.value and not isinstance(item.value, bool)]\n    if len(values) == 1:\n        values = values[0]\n    elif len(values) == 0:\n        return None\n    return values        \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.update","title":"<code>update(collection, value)</code>","text":"<p>Updates the input collection with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Any</code> <p>The input collection to update.</p> required <code>value</code> <code>Any</code> <p>The value to set in the collection.</p> required Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def update(self, collection, value) -&gt; None:\n    \"\"\"\n    Updates the input collection with the given value.\n\n    Args:\n        collection (Any): The input collection to update.\n        value (Any): The value to set in the collection.\n    \"\"\"        \n    # Ensure that entrypoint is a FHIRPathCollectionItem instance\n    collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n    # Collect the elements and set the values for each of them\n    new_collection = self.evaluate(collection, create=False)\n    for item in new_collection:\n        item.set_value(value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPath.update_or_create","title":"<code>update_or_create(collection, value)</code>","text":"<p>Updates or creates the input collection with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Any</code> <p>The input collection to update or create items in.</p> required <code>value</code> <code>Any</code> <p>The value to set in the collection.</p> required Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def update_or_create(self, collection, value) -&gt; None:     \n    \"\"\"\n    Updates or creates the input collection with the given value.\n\n    Args:\n        collection (Any): The input collection to update or create items in.\n        value (Any): The value to set in the collection.\n    \"\"\"         \n    # Ensure that entrypoint is a FHIRPathCollectionItem instance\n    collection = [FHIRPathCollectionItem.wrap(item) for item in ensure_list(collection)]\n    # Collect the elements and set the values for each of them\n    for item in self.evaluate(collection, create=True):\n        item.set_value(value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem","title":"<code>FHIRPathCollectionItem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>A context-aware representation of an item in a FHIRPath collection.</p>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem--attributes","title":"Attributes","text":"<p>value (Any): The value of the collection item. path (Optional[FHIRPath]): The path associated with the collection item, by default This(). element (Optional[str]): The element name of the collection item, by default None. index (Optional[int]): The index of the collection item, by default None. parent (Optional[FHIRPathCollectionItem]): The item of the parent collection from which this item was derived, by default None. setter (Optional[callable]): The setter function for the collection item, by default None.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>@dataclass\nclass FHIRPathCollectionItem(object):\n    \"\"\"\n    A context-aware representation of an item in a FHIRPath collection.\n\n    Attributes\n    ----------\n    value (Any): The value of the collection item.\n    path (Optional[FHIRPath]): The path associated with the collection item, by default This().\n    element (Optional[str]): The element name of the collection item, by default None.\n    index (Optional[int]): The index of the collection item, by default None.\n    parent (Optional[FHIRPathCollectionItem]): The item of the parent collection from which this item was derived, by default None.\n    setter (Optional[callable]): The setter function for the collection item, by default None.\n    \"\"\"\n    value: typing.Any\n    path: typing.Any = field(default_factory=lambda: This())\n    element: Optional[str] = None\n    index: Optional[int] = None\n    parent: Optional[\"FHIRPathCollectionItem\"] = None\n    setter: Optional[callable] = None\n\n    @classmethod\n    def wrap(cls, data: typing.Union[\"FHIRPathCollectionItem\"]):\n        \"\"\"\n        Wraps data in a FHIRPathCollectionItem instance.\n\n        Args:\n            data (Union[FHIRPathCollectionItem): The data to be wrapped.\n\n        Returns:\n            item (FHIRPathCollectionItem): The wrapped FHIRPathCollectionItem instance.\n        \"\"\"\n        if isinstance(data, cls):\n            return data\n        else:\n            return cls(data)\n\n    def set_literal(self,value):\n        setattr(self.parent.value, self.path.label, value)\n\n    def set_value(self,value):\n        \"\"\"\n        Sets the value of the item using the setter function.\n\n        Args:\n            value (Any): The value to set.\n\n        Raises:\n            ValueError: If the value is a list.\n            RuntimeError: If there is no setter function associated with this item.\n        \"\"\"        \n        if self.setter:\n            if isinstance(value, list):\n                raise ValueError('Only single value is accepted')\n            self.setter(value)\n        else:\n            raise RuntimeError('There is not setter function associated with this item')\n\n\n    @property\n    def field_info(self):\n        \"\"\"\n        Retrieves the field information from the parent's value.\n\n        Returns:\n           (Any): The field information, or None if not available.\n        \"\"\"        \n        parent = self.parent.value\n        if isinstance(parent, list):\n            parent = parent[0]\n        if hasattr(parent, 'model_fields') and hasattr(self.path, 'label'):\n            return parent.model_fields.get(self.path.label)\n        return None\n\n    @property\n    def is_list_type(self):\n        \"\"\"\n        Checks if the field information indicates a list type.\n\n        Returns:\n            (bool): True if the field information indicates a list type, False otherwise.\n        \"\"\"        \n        if not self.field_info:\n            return False\n        return contains_list_type(self.field_info.annotation)\n\n    def construct_resource(self):\n        \"\"\"\n        Constructs a FHIR resource based on the field information.\n\n        Returns:\n            (Any): The constructed FHIR resource, or None if construction fails.\n        \"\"\"        \n        if self.field_info:\n            model = get_fhir_model_from_field(self.field_info)\n            return model.model_construct()    \n\n    @property\n    def full_path(self):\n        \"\"\"\n        Retrieves the full path of the item.\n\n        Returns:\n            (str): The full path of the item.\n        \"\"\"        \n        return self.path if self.parent is None else self.parent.full_path.child(self.path)\n\n    def __repr__(self):\n        return f'FHIRPathCollectionItem(value={self.value.__repr__()[:10]}, element={self.element.__repr__()[:10]}..., index={self.index}, parent={self.parent.full_path if self.parent else None})'\n\n    def __hash__(self):\n        return hash((self.value, self.path, self.parent))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.field_info","title":"<code>field_info</code>  <code>property</code>","text":"<p>Retrieves the field information from the parent's value.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The field information, or None if not available.</p>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.full_path","title":"<code>full_path</code>  <code>property</code>","text":"<p>Retrieves the full path of the item.</p> <p>Returns:</p> Type Description <code>str</code> <p>The full path of the item.</p>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.is_list_type","title":"<code>is_list_type</code>  <code>property</code>","text":"<p>Checks if the field information indicates a list type.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the field information indicates a list type, False otherwise.</p>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.construct_resource","title":"<code>construct_resource()</code>","text":"<p>Constructs a FHIR resource based on the field information.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The constructed FHIR resource, or None if construction fails.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def construct_resource(self):\n    \"\"\"\n    Constructs a FHIR resource based on the field information.\n\n    Returns:\n        (Any): The constructed FHIR resource, or None if construction fails.\n    \"\"\"        \n    if self.field_info:\n        model = get_fhir_model_from_field(self.field_info)\n        return model.model_construct()    \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.set_value","title":"<code>set_value(value)</code>","text":"<p>Sets the value of the item using the setter function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is a list.</p> <code>RuntimeError</code> <p>If there is no setter function associated with this item.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def set_value(self,value):\n    \"\"\"\n    Sets the value of the item using the setter function.\n\n    Args:\n        value (Any): The value to set.\n\n    Raises:\n        ValueError: If the value is a list.\n        RuntimeError: If there is no setter function associated with this item.\n    \"\"\"        \n    if self.setter:\n        if isinstance(value, list):\n            raise ValueError('Only single value is accepted')\n        self.setter(value)\n    else:\n        raise RuntimeError('There is not setter function associated with this item')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathCollectionItem.wrap","title":"<code>wrap(data)</code>  <code>classmethod</code>","text":"<p>Wraps data in a FHIRPathCollectionItem instance.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[FHIRPathCollectionItem</code> <p>The data to be wrapped.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>FHIRPathCollectionItem</code> <p>The wrapped FHIRPathCollectionItem instance.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>@classmethod\ndef wrap(cls, data: typing.Union[\"FHIRPathCollectionItem\"]):\n    \"\"\"\n    Wraps data in a FHIRPathCollectionItem instance.\n\n    Args:\n        data (Union[FHIRPathCollectionItem): The data to be wrapped.\n\n    Returns:\n        item (FHIRPathCollectionItem): The wrapped FHIRPathCollectionItem instance.\n    \"\"\"\n    if isinstance(data, cls):\n        return data\n    else:\n        return cls(data)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathError","title":"<code>FHIRPathError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception related to FHIRPath specific syntax or runtime criteria.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class FHIRPathError(Exception):\n    \"\"\"\n    An exception related to FHIRPath specific syntax or runtime criteria.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathFunction","title":"<code>FHIRPathFunction</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>Abstract base class representing a FHIRPath function, used for functional evaluation of collections.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class FHIRPathFunction(FHIRPath):\n    \"\"\"\n    Abstract base class representing a FHIRPath function, used for functional evaluation of collections.\n    \"\"\"\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}()'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}()'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathMixin","title":"<code>FHIRPathMixin</code>","text":"<p>Mixin class to incorporate a simple FHIRPath interface to the child class.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class FHIRPathMixin:\n    \"\"\" \n    Mixin class to incorporate a simple FHIRPath interface to the child class.\n    \"\"\"\n\n    @property\n    def fhirpath(self) -&gt; typing.Callable:\n        \"\"\" \n        Initialized FHIRPath engine instance\n        \"\"\"\n        return import_fhirpath_engine()\n\n    def get_fhirpath(self, expression:str) -&gt; typing.Union[None,typing.Any, typing.List[typing.Any]]:\n        \"\"\"\n        Evaluates and retrieves the value(s) of a FHIRPath expression        \n\n        Args:\n            expression (str): FHIRPath expression to evaluate\n\n        Returns:\n            (Union[NoneType,Any, List[Any]): The extracted value(s), or None if no values are found.\n        \"\"\"\n        # Evaluate the FHIRPath expression\n        collection = self.fhirpath.parse(expression).find(self)\n        # Get the values of the collection items\n        values = [\n            item.value for item in collection \n                if item.value and not isinstance(item.value, bool)\n        ]\n        if len(values) == 1:\n            return values[0]\n        elif len(values) == 0:\n            return None\n        else:\n            return values    \n\n    def replace_fhirpath(self, expression:str, new_value:typing.Any) -&gt; None:\n        \"\"\"\n        Evaluates and replaces the value given by a FHIRPath expression        \n\n        Args:\n            expression (str): FHIRPath expression to evaluate\n        \"\"\"\n        # Evaluate the FHIRPath expression\n        self.fhirpath.parse(expression).update_or_create(self, new_value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathMixin.fhirpath","title":"<code>fhirpath: typing.Callable</code>  <code>property</code>","text":"<p>Initialized FHIRPath engine instance</p>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathMixin.get_fhirpath","title":"<code>get_fhirpath(expression)</code>","text":"<p>Evaluates and retrieves the value(s) of a FHIRPath expression        </p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>FHIRPath expression to evaluate</p> required <p>Returns:</p> Type Description <code>Union[NoneType,Any, List[Any]</code> <p>The extracted value(s), or None if no values are found.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def get_fhirpath(self, expression:str) -&gt; typing.Union[None,typing.Any, typing.List[typing.Any]]:\n    \"\"\"\n    Evaluates and retrieves the value(s) of a FHIRPath expression        \n\n    Args:\n        expression (str): FHIRPath expression to evaluate\n\n    Returns:\n        (Union[NoneType,Any, List[Any]): The extracted value(s), or None if no values are found.\n    \"\"\"\n    # Evaluate the FHIRPath expression\n    collection = self.fhirpath.parse(expression).find(self)\n    # Get the values of the collection items\n    values = [\n        item.value for item in collection \n            if item.value and not isinstance(item.value, bool)\n    ]\n    if len(values) == 1:\n        return values[0]\n    elif len(values) == 0:\n        return None\n    else:\n        return values    \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.FHIRPathMixin.replace_fhirpath","title":"<code>replace_fhirpath(expression, new_value)</code>","text":"<p>Evaluates and replaces the value given by a FHIRPath expression        </p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>FHIRPath expression to evaluate</p> required Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def replace_fhirpath(self, expression:str, new_value:typing.Any) -&gt; None:\n    \"\"\"\n    Evaluates and replaces the value given by a FHIRPath expression        \n\n    Args:\n        expression (str): FHIRPath expression to evaluate\n    \"\"\"\n    # Evaluate the FHIRPath expression\n    self.fhirpath.parse(expression).update_or_create(self, new_value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Invocation","title":"<code>Invocation</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A class representing an invocation in the context of FHIRPath evaluation  indicated by two dot-separated identifiers <code>&lt;left&gt;.&lt;right&gt;</code>.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>The left-hand side FHIRPath segment of the invocation.</p> <code>right</code> <code>FHIRPath</code> <p>The right-hand side  FHIRPath segment of the invocation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class Invocation(FHIRPath):\n    \"\"\"\n    A class representing an invocation in the context of FHIRPath evaluation \n    indicated by two dot-separated identifiers `&lt;left&gt;.&lt;right&gt;`.\n\n    Attributes:\n        left (FHIRPath): The left-hand side FHIRPath segment of the invocation.\n        right (FHIRPath): The right-hand side  FHIRPath segment of the invocation.\n    \"\"\"\n    def __init__(self, left:FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Performs the evaluation of the Invocation by applying the left-hand side FHIRPath segment on the given collection to obtain a parent collection. \n        Then, the right-hand side FHIRPath segment is applied on the parent collection to derive the child collection.\n\n        Args:\n            collection (List[FHIRPathCollectionItem]): The collection on which the evaluation is performed.\n            create (bool): A boolean flag indicating whether to create any missing elements.\n\n        Returns:\n            List[FHIRPathCollectionItem]: The resulting child collection after the evaluation process.\n        \"\"\"        \n        parent_collection = self.left.evaluate(collection, create)\n        child_collection = self.right.evaluate(parent_collection, create)\n        return child_collection\n\n    def __eq__(self, other):\n        return isinstance(other, Invocation) and self.left == other.left and self.right == other.right\n\n    def __str__(self):\n        return '%s.%s' % (self.left, self.right)\n\n    def __repr__(self):\n        return '%s(%r, %r)' % (self.__class__.__name__, self.left, self.right)\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Invocation.evaluate","title":"<code>evaluate(collection, create)</code>","text":"<p>Performs the evaluation of the Invocation by applying the left-hand side FHIRPath segment on the given collection to obtain a parent collection.  Then, the right-hand side FHIRPath segment is applied on the parent collection to derive the child collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The collection on which the evaluation is performed.</p> required <code>create</code> <code>bool</code> <p>A boolean flag indicating whether to create any missing elements.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]: The resulting child collection after the evaluation process.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Performs the evaluation of the Invocation by applying the left-hand side FHIRPath segment on the given collection to obtain a parent collection. \n    Then, the right-hand side FHIRPath segment is applied on the parent collection to derive the child collection.\n\n    Args:\n        collection (List[FHIRPathCollectionItem]): The collection on which the evaluation is performed.\n        create (bool): A boolean flag indicating whether to create any missing elements.\n\n    Returns:\n        List[FHIRPathCollectionItem]: The resulting child collection after the evaluation process.\n    \"\"\"        \n    parent_collection = self.left.evaluate(collection, create)\n    child_collection = self.right.evaluate(parent_collection, create)\n    return child_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Parent","title":"<code>Parent</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A class representing the parent of a FHIRPath</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class Parent(FHIRPath):\n    \"\"\" \n    A class representing the parent of a FHIRPath\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Evaluate the collection of parent resources in the input collection.\n\n        Args:\n            collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n        \"\"\"        \n        collection = ensure_list(collection)\n        return [\n            item.parent for item in collection\n        ]\n\n    def __str__(self):\n        return '$'\n\n    def __repr__(self):\n        return 'Parent()'\n\n    def __eq__(self, other):\n        return isinstance(other, Parent)\n\n    def __hash__(self):\n        return hash('$resource')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Parent.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Evaluate the collection of parent resources in the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The collection of items to be evaluated.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>A list of FHIRPathCollectionItem instances after evaluation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Evaluate the collection of parent resources in the input collection.\n\n    Args:\n        collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n    \"\"\"        \n    collection = ensure_list(collection)\n    return [\n        item.parent for item in collection\n    ]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Root","title":"<code>Root</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A class representing the root of a FHIRPath, i.e. the top-most segment of the FHIRPath  whose collection has no parent associated.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class Root(FHIRPath):\n    \"\"\" \n    A class representing the root of a FHIRPath, i.e. the top-most segment of the FHIRPath \n    whose collection has no parent associated.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Evaluate the collection of top-most resources in the input collection.\n\n        Args:\n            collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n        \"\"\"        \n        collection = ensure_list(collection)\n        return [\n            FHIRPathCollectionItem(item, path=Root(), parent=None)\n                if not isinstance(item, FHIRPathCollectionItem)\n                else FHIRPathCollectionItem(item.value, parent=None, path=Root())\n                    if item.parent is None else Root().find(item.parent)[0]\n                        for item in collection\n        ]\n\n    def __str__(self):\n        return '$'\n\n    def __repr__(self):\n        return 'Root()'\n\n    def __eq__(self, other):\n        return isinstance(other, Root)\n\n    def __hash__(self):\n        return hash('$rootResource')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.Root.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Evaluate the collection of top-most resources in the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The collection of items to be evaluated.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>A list of FHIRPathCollectionItem instances after evaluation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Evaluate the collection of top-most resources in the input collection.\n\n    Args:\n        collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n    \"\"\"        \n    collection = ensure_list(collection)\n    return [\n        FHIRPathCollectionItem(item, path=Root(), parent=None)\n            if not isinstance(item, FHIRPathCollectionItem)\n            else FHIRPathCollectionItem(item.value, parent=None, path=Root())\n                if item.parent is None else Root().find(item.parent)[0]\n                    for item in collection\n    ]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.This","title":"<code>This</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A class representation of the FHIRPath <code>$this</code> operator used to represent the item from the input collection currently under evaluation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>class This(FHIRPath):\n    \"\"\"\n    A class representation of the FHIRPath `$this` operator used to represent\n    the item from the input collection currently under evaluation.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Simply returns the input collection. \n\n        Args:\n            collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n        \"\"\"\n        return ensure_list(collection)\n\n    def __str__(self):\n        return '`this`'\n\n    def __repr__(self):\n        return 'This()'\n\n    def __eq__(self, other):\n        return isinstance(other, This)\n\n    def __hash__(self):\n        return hash('this')\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/core/#fhircraft.fhir.path.engine.core.This.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Simply returns the input collection. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The collection of items to be evaluated.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>A list of FHIRPathCollectionItem instances after evaluation.</p> Source code in <code>fhircraft/fhir/path/engine/core.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Simply returns the input collection. \n\n    Args:\n        collection (List[FHIRPathCollectionItem]): The collection of items to be evaluated.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem]): A list of FHIRPathCollectionItem instances after evaluation.\n    \"\"\"\n    return ensure_list(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/","title":"Equality","text":"<p>The equality module contains the object representations of the equality FHIRPath operators.</p>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.Equals","title":"<code>Equals</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>=</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>class Equals(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`=`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true if the left collection is equal to the right collection:\n        As noted above, if either operand is an empty collection, the result is an empty collection. Otherwise:\n        If both operands are collections with a single item, they must be of the same type (or be implicitly convertible to the same type), and:\n            - For primitives:\n                - String: comparison is based on Unicode values\n                - Integer: values must be exactly equal\n                - Decimal: values must be equal, trailing zeroes after the decimal are ignored\n                - Boolean: values must be the same\n                - Date: must be exactly the same\n                - DateTime: must be exactly the same, respecting the timezone offset (though +00:00 = -00:00 = Z)\n                - Time: must be exactly the same\n            - For complex types, equality requires all child properties to be equal, recursively.=\n        If both operands are collections with multiple items:\n            - Each item must be equal\n            - Comparison is order dependent\n        Otherwise, equals returns false.\n        Note that this implies that if the collections have a different number of items to compare, the result will be false.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_collection, right_collection = _evaluate_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if len(left_collection)==0 or len(right_collection)==0:\n            return []\n        if len(left_collection)==1 and len(right_collection)==1:\n            return left_collection[0] == right_collection[0]\n        return left_collection == right_collection\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Equals) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.Equals.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true if the left collection is equal to the right collection: As noted above, if either operand is an empty collection, the result is an empty collection. Otherwise: If both operands are collections with a single item, they must be of the same type (or be implicitly convertible to the same type), and:     - For primitives:         - String: comparison is based on Unicode values         - Integer: values must be exactly equal         - Decimal: values must be equal, trailing zeroes after the decimal are ignored         - Boolean: values must be the same         - Date: must be exactly the same         - DateTime: must be exactly the same, respecting the timezone offset (though +00:00 = -00:00 = Z)         - Time: must be exactly the same     - For complex types, equality requires all child properties to be equal, recursively.= If both operands are collections with multiple items:     - Each item must be equal     - Comparison is order dependent Otherwise, equals returns false. Note that this implies that if the collections have a different number of items to compare, the result will be false.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true if the left collection is equal to the right collection:\n    As noted above, if either operand is an empty collection, the result is an empty collection. Otherwise:\n    If both operands are collections with a single item, they must be of the same type (or be implicitly convertible to the same type), and:\n        - For primitives:\n            - String: comparison is based on Unicode values\n            - Integer: values must be exactly equal\n            - Decimal: values must be equal, trailing zeroes after the decimal are ignored\n            - Boolean: values must be the same\n            - Date: must be exactly the same\n            - DateTime: must be exactly the same, respecting the timezone offset (though +00:00 = -00:00 = Z)\n            - Time: must be exactly the same\n        - For complex types, equality requires all child properties to be equal, recursively.=\n    If both operands are collections with multiple items:\n        - Each item must be equal\n        - Comparison is order dependent\n    Otherwise, equals returns false.\n    Note that this implies that if the collections have a different number of items to compare, the result will be false.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_collection, right_collection = _evaluate_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if len(left_collection)==0 or len(right_collection)==0:\n        return []\n    if len(left_collection)==1 and len(right_collection)==1:\n        return left_collection[0] == right_collection[0]\n    return left_collection == right_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.Equivalent","title":"<code>Equivalent</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>~</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>class Equivalent(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`~`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true if the collections are the same. In particular, comparing empty collections for equivalence { } ~ { } will result in true.\n        If both operands are collections with a single item, they must be of the same type (or implicitly convertible to the same type), and:\n            - For primitives\n                - String: the strings must be the same, ignoring case and locale, and normalizing whitespace (see String Equivalence for more details).\n                - Integer: exactly equal\n                - Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand. Trailing zeroes after the decimal are ignored in determining precision.\n                - Date, DateTime and Time: values must be equal, except that if the input values have different levels of precision, the comparison returns false, not empty ({ }).\n                - Boolean: the values must be the same\n            - For complex types, equivalence requires all child properties to be equivalent, recursively.\n        If both operands are collections with multiple items:\n            - Each item must be equivalent\n            - Comparison is not order dependent\n        Note that this implies that if the collections have a different number of items to compare, or if one input is a value and the other is empty ({ }), the result will be false.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        left_collection, right_collection = _evaluate_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n        if len(left_collection)==0 and len(right_collection)==0:\n            return True\n        elif len(left_collection)==0 or len(right_collection)==0:\n            return False\n        def handle_types(value):\n            if isinstance(value,str):\n                return value.lower().strip()\n            else:\n                return value \n\n        return [handle_types(item) for item in left_collection] == [handle_types(item) for item in right_collection]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Equivalent) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.Equivalent.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true if the collections are the same. In particular, comparing empty collections for equivalence { } ~ { } will result in true. If both operands are collections with a single item, they must be of the same type (or implicitly convertible to the same type), and:     - For primitives         - String: the strings must be the same, ignoring case and locale, and normalizing whitespace (see String Equivalence for more details).         - Integer: exactly equal         - Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand. Trailing zeroes after the decimal are ignored in determining precision.         - Date, DateTime and Time: values must be equal, except that if the input values have different levels of precision, the comparison returns false, not empty ({ }).         - Boolean: the values must be the same     - For complex types, equivalence requires all child properties to be equivalent, recursively. If both operands are collections with multiple items:     - Each item must be equivalent     - Comparison is not order dependent Note that this implies that if the collections have a different number of items to compare, or if one input is a value and the other is empty ({ }), the result will be false.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true if the collections are the same. In particular, comparing empty collections for equivalence { } ~ { } will result in true.\n    If both operands are collections with a single item, they must be of the same type (or implicitly convertible to the same type), and:\n        - For primitives\n            - String: the strings must be the same, ignoring case and locale, and normalizing whitespace (see String Equivalence for more details).\n            - Integer: exactly equal\n            - Decimal: values must be equal, comparison is done on values rounded to the precision of the least precise operand. Trailing zeroes after the decimal are ignored in determining precision.\n            - Date, DateTime and Time: values must be equal, except that if the input values have different levels of precision, the comparison returns false, not empty ({ }).\n            - Boolean: the values must be the same\n        - For complex types, equivalence requires all child properties to be equivalent, recursively.\n    If both operands are collections with multiple items:\n        - Each item must be equivalent\n        - Comparison is not order dependent\n    Note that this implies that if the collections have a different number of items to compare, or if one input is a value and the other is empty ({ }), the result will be false.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    left_collection, right_collection = _evaluate_expressions(self.left, self.right, collection, create=kwargs.get('create', False))\n    if len(left_collection)==0 and len(right_collection)==0:\n        return True\n    elif len(left_collection)==0 or len(right_collection)==0:\n        return False\n    def handle_types(value):\n        if isinstance(value,str):\n            return value.lower().strip()\n        else:\n            return value \n\n    return [handle_types(item) for item in left_collection] == [handle_types(item) for item in right_collection]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.NotEquals","title":"<code>NotEquals</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>!=</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>class NotEquals(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`!=`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The converse of the equals operator, returning true if equal returns false; false if equal \n        returns true; and empty ({ }) if equal returns empty. In other words, A != B is short-hand for (A = B).not().\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        return not Equals(self.left, self.right).evaluate(collection, **kwargs)\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, NotEquals) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.NotEquals.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The converse of the equals operator, returning true if equal returns false; false if equal  returns true; and empty ({ }) if equal returns empty. In other words, A != B is short-hand for (A = B).not().</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The converse of the equals operator, returning true if equal returns false; false if equal \n    returns true; and empty ({ }) if equal returns empty. In other words, A != B is short-hand for (A = B).not().\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    return not Equals(self.left, self.right).evaluate(collection, **kwargs)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.NotEquivalent","title":"<code>NotEquivalent</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>!~</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>class NotEquivalent(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`!~`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        The converse of the equivalent operator, returning true if equivalent returns \n        false and false is equivalent returns true. In other words, A !~ B is short-hand for (A ~ B).not().\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n        \"\"\"\n        return not Equivalent(self.left, self.right).evaluate(collection, **kwargs)\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, NotEquivalent) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/equality/#fhircraft.fhir.path.engine.equality.NotEquivalent.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>The converse of the equivalent operator, returning true if equivalent returns  false and false is equivalent returns true. In other words, A !~ B is short-hand for (A ~ B).not().</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/equality.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    The converse of the equivalent operator, returning true if equivalent returns \n    false and false is equivalent returns true. In other words, A !~ B is short-hand for (A ~ B).not().\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n    \"\"\"\n    return not Equivalent(self.left, self.right).evaluate(collection, **kwargs)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/","title":"Existence","text":"<p>The filtering module contains the object representations of the existence-category FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.All","title":"<code>All</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>all()</code> function.</p> <p>Attributes:</p> Name Type Description <code>criteria</code> <code>FHIRPath</code> <p>Optional criteria to be applied to the collection prior to the evalution.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class All(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`all()`](https://hl7.org/fhirpath/N1/#allcriteria-expression-boolean) function.\n\n    Attributes:\n        criteria (FHIRPath): Optional criteria to be applied to the collection prior to the evalution.\n    \"\"\"\n    def __init__(self, criteria: FHIRPath):\n        self.criteria = criteria\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if for every element in the input collection, criteria evaluates to `True`.\n        Otherwise, the result is `False`. If the input collection is empty (`{}`), the result is `True`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\" \n        if len(collection) == 0:\n            return True\n        return all([self.criteria.evaluate([item], create=False) for item in collection])\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.criteria.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.criteria.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.criteria == other.criteria\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.All.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if for every element in the input collection, criteria evaluates to <code>True</code>. Otherwise, the result is <code>False</code>. If the input collection is empty (<code>{}</code>), the result is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if for every element in the input collection, criteria evaluates to `True`.\n    Otherwise, the result is `False`. If the input collection is empty (`{}`), the result is `True`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\" \n    if len(collection) == 0:\n        return True\n    return all([self.criteria.evaluate([item], create=False) for item in collection])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AllFalse","title":"<code>AllFalse</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>allFalse()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class AllFalse(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`allFalse()`](https://hl7.org/fhirpath/N1/#allfalse-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Takes a collection of Boolean values and returns `True` if all the items are `False`. \n        If any items are `True`, the result is `False`. If the input is empty (`{}`), the result is `True`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\"     \n        return _all_or_any_boolean(collection, all, False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AllFalse.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Takes a collection of Boolean values and returns <code>True</code> if all the items are <code>False</code>.  If any items are <code>True</code>, the result is <code>False</code>. If the input is empty (<code>{}</code>), the result is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Takes a collection of Boolean values and returns `True` if all the items are `False`. \n    If any items are `True`, the result is `False`. If the input is empty (`{}`), the result is `True`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\"     \n    return _all_or_any_boolean(collection, all, False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AllTrue","title":"<code>AllTrue</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>allTrue()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class AllTrue(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`allTrue()`](https://hl7.org/fhirpath/N1/#alltrue-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Takes a collection of Boolean values and returns `True` if all the items are `True`. If any \n        items are `False`, the result is `False`. If the input is empty (`{}`), the result is `True`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\" \n        return _all_or_any_boolean(collection, all, True)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AllTrue.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Takes a collection of Boolean values and returns <code>True</code> if all the items are <code>True</code>. If any  items are <code>False</code>, the result is <code>False</code>. If the input is empty (<code>{}</code>), the result is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Takes a collection of Boolean values and returns `True` if all the items are `True`. If any \n    items are `False`, the result is `False`. If the input is empty (`{}`), the result is `True`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\" \n    return _all_or_any_boolean(collection, all, True)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AnyFalse","title":"<code>AnyFalse</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>anyFalse()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class AnyFalse(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`anyFalse()`](https://hl7.org/fhirpath/N1/#anyfalse-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Takes a collection of Boolean values and returns `True` if any of the items are `False`. If all \n        the items are `True`, or if the input is empty (`{}`), the result is `False`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\"          \n        return _all_or_any_boolean(collection, any, False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AnyFalse.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Takes a collection of Boolean values and returns <code>True</code> if any of the items are <code>False</code>. If all  the items are <code>True</code>, or if the input is empty (<code>{}</code>), the result is <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Takes a collection of Boolean values and returns `True` if any of the items are `False`. If all \n    the items are `True`, or if the input is empty (`{}`), the result is `False`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\"          \n    return _all_or_any_boolean(collection, any, False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AnyTrue","title":"<code>AnyTrue</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>anyTrue()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class AnyTrue(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`anyTrue()`](https://hl7.org/fhirpath/N1/#anytrue-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Takes a collection of Boolean values and returns `True` if any of the items are `True`. \n        If all the items are `False`, or if the input is empty (`{}`), the result is `False`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\"         \n        return _all_or_any_boolean(collection, any, True)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.AnyTrue.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Takes a collection of Boolean values and returns <code>True</code> if any of the items are <code>True</code>.  If all the items are <code>False</code>, or if the input is empty (<code>{}</code>), the result is <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Takes a collection of Boolean values and returns `True` if any of the items are `True`. \n    If all the items are `False`, or if the input is empty (`{}`), the result is `False`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\"         \n    return _all_or_any_boolean(collection, any, True)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Count","title":"<code>Count</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>count()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class Count(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`count()`](https://hl7.org/fhirpath/N1/#count-integer) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the integer count of the number of items in the input collection. Returns 0 when the input collection is empty.\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            count (int): THe number of items in the collection        \n        \"\"\"   \n        return len(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Count.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the integer count of the number of items in the input collection. Returns 0 when the input collection is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Name Type Description <code>count</code> <code>int</code> <p>THe number of items in the collection</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the integer count of the number of items in the input collection. Returns 0 when the input collection is empty.\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        count (int): THe number of items in the collection        \n    \"\"\"   \n    return len(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Distinct","title":"<code>Distinct</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>distinct()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class Distinct(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`distinct()`](https://hl7.org/fhirpath/N1/#distinct-collection) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing only the unique items in the input collection. If the input collection is empty (`[]`), the result is empty.\n        Note that the order of elements in the input collection is not guaranteed to be preserved in the result.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            collection (List[FHIRPathCollectionItem])): The output collection      \n        \"\"\"   \n        return list(set(collection))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Distinct.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing only the unique items in the input collection. If the input collection is empty (<code>[]</code>), the result is empty. Note that the order of elements in the input collection is not guaranteed to be preserved in the result.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem])</code> <p>The output collection</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing only the unique items in the input collection. If the input collection is empty (`[]`), the result is empty.\n    Note that the order of elements in the input collection is not guaranteed to be preserved in the result.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        collection (List[FHIRPathCollectionItem])): The output collection      \n    \"\"\"   \n    return list(set(collection))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Empty","title":"<code>Empty</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>empty()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class Empty(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`empty()`](http://hl7.org/fhirpath/N1/#empty-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if the input collection is empty (`{}`) and `False` otherwise.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\"\n        return len(collection) == 0\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Empty.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if the input collection is empty (<code>{}</code>) and <code>False</code> otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if the input collection is empty (`{}`) and `False` otherwise.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\"\n    return len(collection) == 0\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Exists","title":"<code>Exists</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>exists()</code> function.</p> <p>Attributes:</p> Name Type Description <code>criteria</code> <code>FHIRPath</code> <p>Optional criteria to be applied to the collection prior to the determination of the exists</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class Exists(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`exists()`](http://hl7.org/fhirpath/N1/#existscriteria-expression-boolean) function.\n\n    Attributes:\n        criteria (FHIRPath): Optional criteria to be applied to the collection prior to the determination of the exists\n    \"\"\"\n\n    def __init__(self, criteria: FHIRPath = None):\n        self.criteria = criteria\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if the collection has any elements, and `False` otherwise. \n        This is the opposite of empty(), and as such is a shorthand for empty().not().\n        If the input collection is empty (`{}`), the result is `False`.\n        The function can also take an optional criteria to be applied to the collection\n        prior to the determination of the exists. In this case, the function is \n        shorthand for where(criteria).exists().\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n        \"\"\"    \n        if self.criteria:\n            collection = Where(self.criteria).evaluate(collection, create=False)\n        return len(collection) &gt; 0\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.criteria.__str__() if self.criteria else \"\"})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.criteria.__repr__() if self.criteria else \"\"})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.criteria == other.criteria\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.Exists.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if the collection has any elements, and <code>False</code> otherwise.  This is the opposite of empty(), and as such is a shorthand for empty().not(). If the input collection is empty (<code>{}</code>), the result is <code>False</code>. The function can also take an optional criteria to be applied to the collection prior to the determination of the exists. In this case, the function is  shorthand for where(criteria).exists().</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if the collection has any elements, and `False` otherwise. \n    This is the opposite of empty(), and as such is a shorthand for empty().not().\n    If the input collection is empty (`{}`), the result is `False`.\n    The function can also take an optional criteria to be applied to the collection\n    prior to the determination of the exists. In this case, the function is \n    shorthand for where(criteria).exists().\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n    \"\"\"    \n    if self.criteria:\n        collection = Where(self.criteria).evaluate(collection, create=False)\n    return len(collection) &gt; 0\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.IsDistinct","title":"<code>IsDistinct</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>isDistinct()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class IsDistinct(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`isDistinct()`](https://hl7.org/fhirpath/N1/#isdistinct-boolean) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if all the items in the input collection are distinct. \n        If the input collection is empty (`[]`), the result is `True`.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool \n        \"\"\"           \n        return len(list(set(collection))) == len(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.IsDistinct.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if all the items in the input collection are distinct.  If the input collection is empty (<code>[]</code>), the result is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if all the items in the input collection are distinct. \n    If the input collection is empty (`[]`), the result is `True`.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool \n    \"\"\"           \n    return len(list(set(collection))) == len(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.SubsetOf","title":"<code>SubsetOf</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>subsetOf()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other</code> <code>Union[List[FHIRPathCollectionItem], FHIRPath]</code> <p>Other collection to which to determine whether input is a subset of.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class SubsetOf(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`subsetOf()`](https://hl7.org/fhirpath/N1/#subsetofother-collection-boolean) function.\n\n    Attributes:\n        other (Union[List[FHIRPathCollectionItem], FHIRPath]): Other collection to which to determine whether input is a subset of.\n    \"\"\"\n    def __init__(self, other: Union[List[FHIRPathCollectionItem], FHIRPath] = None):\n        self.other = other\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` if all items in the input collection are members of the collection passed as the \n        other argument.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n\n        Note:\n            Conceptually, this function is evaluated by testing each element in the input collection for \n            membership in the other collection, with a default of `True`. This means that if the input collection\n            is empty (`[]`), the result is `True`, otherwise if the other collection is empty, the result is `False`.\n        \"\"\"      \n        if len(collection) == 0:\n            return True\n        if isinstance(self.other, FHIRPath):\n            other_collection = self.other.evaluate(**kwargs)\n        else:\n            other_collection = self.other\n        if len(other_collection) == 0:\n            return False\n        for item in collection:\n            if item not in other_collection:\n                return False\n        else:\n            return True\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.other.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.other.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.other == other.other\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.SubsetOf.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> if all items in the input collection are members of the collection passed as the  other argument.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Note <p>Conceptually, this function is evaluated by testing each element in the input collection for  membership in the other collection, with a default of <code>True</code>. This means that if the input collection is empty (<code>[]</code>), the result is <code>True</code>, otherwise if the other collection is empty, the result is <code>False</code>.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` if all items in the input collection are members of the collection passed as the \n    other argument.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n\n    Note:\n        Conceptually, this function is evaluated by testing each element in the input collection for \n        membership in the other collection, with a default of `True`. This means that if the input collection\n        is empty (`[]`), the result is `True`, otherwise if the other collection is empty, the result is `False`.\n    \"\"\"      \n    if len(collection) == 0:\n        return True\n    if isinstance(self.other, FHIRPath):\n        other_collection = self.other.evaluate(**kwargs)\n    else:\n        other_collection = self.other\n    if len(other_collection) == 0:\n        return False\n    for item in collection:\n        if item not in other_collection:\n            return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.SupersetOf","title":"<code>SupersetOf</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>supersetOf()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other</code> <code>Union[List[FHIRPathCollectionItem], FHIRPath]</code> <p>Other collection to which to determine whether input is a superset of.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>class SupersetOf(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`supersetOf()`](https://hl7.org/fhirpath/N1/#supersetofother-collection-boolean) function.\n\n    Attributes:\n        other (Union[List[FHIRPathCollectionItem], FHIRPath]): Other collection to which to determine whether input is a superset of.\n    \"\"\"\n    def __init__(self, other: Union[List[FHIRPathCollectionItem], FHIRPath] = None):\n        self.other = other\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true if all items in the collection passed as the other argument are \n        members of the input collection. Membership is determined using the = (Equals) (=) operation.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection\n\n        Returns:\n            bool\n\n        Note:\n            Conceptually, this function is evaluated by testing each element in the other collection for \n            membership in the input collection, with a default of `True`. This means that if the other collection\n            is empty (`[]`), the result is `True`, otherwise if the other collection is empty, the result is `False`.\n        \"\"\"   \n        if len(collection) == 0:\n            return True\n        if isinstance(self.other, FHIRPath):\n            other_collection = self.other.evaluate()\n        else:\n            other_collection = self.other\n        if len(other_collection) == 0:\n            return True\n        for item in other_collection:\n            if item not in collection:\n                return False\n        else:\n            return True\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.other.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.other.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.other == other.other\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/existence/#fhircraft.fhir.path.engine.existence.SupersetOf.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true if all items in the collection passed as the other argument are  members of the input collection. Membership is determined using the = (Equals) (=) operation.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> Note <p>Conceptually, this function is evaluated by testing each element in the other collection for  membership in the input collection, with a default of <code>True</code>. This means that if the other collection is empty (<code>[]</code>), the result is <code>True</code>, otherwise if the other collection is empty, the result is <code>False</code>.</p> Source code in <code>fhircraft/fhir/path/engine/existence.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true if all items in the collection passed as the other argument are \n    members of the input collection. Membership is determined using the = (Equals) (=) operation.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection\n\n    Returns:\n        bool\n\n    Note:\n        Conceptually, this function is evaluated by testing each element in the other collection for \n        membership in the input collection, with a default of `True`. This means that if the other collection\n        is empty (`[]`), the result is `True`, otherwise if the other collection is empty, the result is `False`.\n    \"\"\"   \n    if len(collection) == 0:\n        return True\n    if isinstance(self.other, FHIRPath):\n        other_collection = self.other.evaluate()\n    else:\n        other_collection = self.other\n    if len(other_collection) == 0:\n        return True\n    for item in other_collection:\n        if item not in collection:\n            return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/","title":"Filtering","text":"<p>The filtering module contains the object representations of the filtering-category FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.OfType","title":"<code>OfType</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>ofType()</code> function.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>class</code> <p>Type class</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>class OfType(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`ofType()`](http://hl7.org/fhirpath/N1/#oftypetype-type-specifier-collection) function.\n\n    Attributes:\n        type (class): Type class \n    \"\"\"\n    def __init__(self, type: FHIRPath):\n        self.type = type\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem]) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection that contains all items in the input collection that are of the given type\n        or a subclass thereof. If the input collection is empty (`[]`), the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return [item for item in collection if isinstance(item.value, self.type)]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.type.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.type.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, OfType) and other.type == self.type\n\n    def __hash__(self):\n        return hash((self.type))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.OfType.evaluate","title":"<code>evaluate(collection)</code>","text":"<p>Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof. If the input collection is empty (<code>[]</code>), the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem]) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection that contains all items in the input collection that are of the given type\n    or a subclass thereof. If the input collection is empty (`[]`), the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return [item for item in collection if isinstance(item.value, self.type)]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Repeat","title":"<code>Repeat</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>repeat()</code> function.</p> <p>Attributes:</p> Name Type Description <code>projection</code> <code>FHIRPath</code> <p>Expression to evaluate for each collection item.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>class Repeat(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`repeat()`](http://hl7.org/fhirpath/N1/#repeatprojection-expression-collection) function.\n\n    Attributes:\n        projection (FHIRPath): Expression to evaluate for each collection item. \n    \"\"\"\n    def __init__(self, projection: FHIRPath):\n        self.projection = projection\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        A version of select that will repeat the projection and add it to the output collection, as\n        long as the projection yields new items (as determined by the = (Equals) (=) operator).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n            create (bool): Whether to auto-generate missing path segments.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        def project_recursively(input_collection):\n            output_collection = []\n            for item in input_collection:\n                new_collection = self.projection.evaluate(item, create)\n                output_collection.extend(new_collection)\n                if len(new_collection)&gt;0:\n                    output_collection.extend(project_recursively(new_collection))\n            return output_collection\n        return project_recursively(collection)\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.projection.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.projection.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Repeat) and other.projection == self.projection\n\n    def __hash__(self):\n        return hash((self.projection))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Repeat.evaluate","title":"<code>evaluate(collection, create=False)</code>","text":"<p>A version of select that will repeat the projection and add it to the output collection, as long as the projection yields new items (as determined by the = (Equals) (=) operator).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <code>create</code> <code>bool</code> <p>Whether to auto-generate missing path segments.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    A version of select that will repeat the projection and add it to the output collection, as\n    long as the projection yields new items (as determined by the = (Equals) (=) operator).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n        create (bool): Whether to auto-generate missing path segments.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    def project_recursively(input_collection):\n        output_collection = []\n        for item in input_collection:\n            new_collection = self.projection.evaluate(item, create)\n            output_collection.extend(new_collection)\n            if len(new_collection)&gt;0:\n                output_collection.extend(project_recursively(new_collection))\n        return output_collection\n    return project_recursively(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Select","title":"<code>Select</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>select()</code> function.</p> <p>Attributes:</p> Name Type Description <code>projection</code> <code>FHIRPath</code> <p>Expression to evaluate for each collection item.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>class Select(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`select()`](http://hl7.org/fhirpath/N1/#selectprojection-expression-collection) function.\n\n    Attributes:\n        projection (FHIRPath): Expression to evaluate for each collection item. \n    \"\"\"\n    def __init__(self, projection: FHIRPath):\n        self.projection = projection\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Evaluates the projection expression for each item in the input collection. The result of each\n        evaluation is added to the output collection. If the evaluation results in a collection with\n        multiple items, all items are added to the output collection (collections resulting from \n        evaluation of projection are flattened). This means that if the evaluation for an element \n        results in the empty collection (`[]`), no element is added to the result, and that if the \n        input collection is empty (`[]`), the result is empty as well.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n            create (bool): Whether to auto-generate missing path segments.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\"    \n        collection = ensure_list(collection)\n        return [projected_item for item in collection for projected_item in ensure_list(self.projection.evaluate(item, create))]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.projection.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.projection.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Select) and other.projection == self.projection\n\n    def __hash__(self):\n        return hash((self.projection))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Select.evaluate","title":"<code>evaluate(collection, create=False)</code>","text":"<p>Evaluates the projection expression for each item in the input collection. The result of each evaluation is added to the output collection. If the evaluation results in a collection with multiple items, all items are added to the output collection (collections resulting from  evaluation of projection are flattened). This means that if the evaluation for an element  results in the empty collection (<code>[]</code>), no element is added to the result, and that if the  input collection is empty (<code>[]</code>), the result is empty as well.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <code>create</code> <code>bool</code> <p>Whether to auto-generate missing path segments.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Evaluates the projection expression for each item in the input collection. The result of each\n    evaluation is added to the output collection. If the evaluation results in a collection with\n    multiple items, all items are added to the output collection (collections resulting from \n    evaluation of projection are flattened). This means that if the evaluation for an element \n    results in the empty collection (`[]`), no element is added to the result, and that if the \n    input collection is empty (`[]`), the result is empty as well.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n        create (bool): Whether to auto-generate missing path segments.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\"    \n    collection = ensure_list(collection)\n    return [projected_item for item in collection for projected_item in ensure_list(self.projection.evaluate(item, create))]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Where","title":"<code>Where</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>where()</code> function.</p> <p>Attributes:</p> Name Type Description <code>expression</code> <code>FHIRPath</code> <p>Expression to evaluate for each collection item.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>class Where(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`where()`](http://hl7.org/fhirpath/N1/#wherecriteria-expression-collection) function.\n\n    Attributes:\n        expression (FHIRPath): Expression to evaluate for each collection item. \n    \"\"\"\n    def __init__(self, expression: FHIRPath):\n        self.expression = expression\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing only those elements in the input collection for which\n        the stated criteria expression evaluates to `True`. Elements for which the expression\n        evaluates to false or empty (`[]`) are not included in the result.\n        If the input collection is empty (`[]`), the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n            create (bool): Whether to auto-generate missing path segments.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\"    \n        collection = ensure_list(collection)\n        return [item for item in collection if self.expression.evaluate(item, create)]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.expression.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.expression.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, Where) and other.expression == self.expression\n\n    def __hash__(self):\n        return hash((self.expression))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/filtering/#fhircraft.fhir.path.engine.filtering.Where.evaluate","title":"<code>evaluate(collection, create=False)</code>","text":"<p>Returns a collection containing only those elements in the input collection for which the stated criteria expression evaluates to <code>True</code>. Elements for which the expression evaluates to false or empty (<code>[]</code>) are not included in the result. If the input collection is empty (<code>[]</code>), the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <code>create</code> <code>bool</code> <p>Whether to auto-generate missing path segments.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/filtering.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing only those elements in the input collection for which\n    the stated criteria expression evaluates to `True`. Elements for which the expression\n    evaluates to false or empty (`[]`) are not included in the result.\n    If the input collection is empty (`[]`), the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n        create (bool): Whether to auto-generate missing path segments.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\"    \n    collection = ensure_list(collection)\n    return [item for item in collection if self.expression.evaluate(item, create)]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/literals/","title":"Literals","text":""},{"location":"reference/fhircraft/fhir/path/engine/math/","title":"Math","text":"<p>The tree navigation module contains the object representations of the math category FHIRPath operators/functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Addition","title":"<code>Addition</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>+</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Addition(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`+`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        For Integer, Decimal, and quantity, adds the operands. For strings, concatenates the right \n        operand to the left operand.\n        When adding quantities, the units of each quantity must be the same.\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Addition result\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float, str, Quantity)) or not isinstance(right, (int, float, str, Quantity)):\n            return []\n        try:\n            return left + right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Addition.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>For Integer, Decimal, and quantity, adds the operands. For strings, concatenates the right  operand to the left operand. When adding quantities, the units of each quantity must be the same.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Addition result</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    For Integer, Decimal, and quantity, adds the operands. For strings, concatenates the right \n    operand to the left operand.\n    When adding quantities, the units of each quantity must be the same.\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Addition result\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float, str, Quantity)) or not isinstance(right, (int, float, str, Quantity)):\n        return []\n    try:\n        return left + right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Div","title":"<code>Div</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>div</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Div(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`div`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Performs truncated division of the left operand by the right operand (supported for Integer and Decimal). \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Truncated division result\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float)) or not isinstance(right, (int, float)):\n            return []\n        if right == 0:\n            return []\n        try:\n            return left // right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Div.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Performs truncated division of the left operand by the right operand (supported for Integer and Decimal). </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Truncated division result</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Performs truncated division of the left operand by the right operand (supported for Integer and Decimal). \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Truncated division result\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float)) or not isinstance(right, (int, float)):\n        return []\n    if right == 0:\n        return []\n    try:\n        return left // right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Division","title":"<code>Division</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>/</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Division(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`/`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Divides the left operand by the right operand (supported for Integer, Decimal, and Quantity). \n        The result of a division is always Decimal, even if the inputs are both Integer. For integer division,\n        use the `div` operator.\n        If an attempt is made to divide by zero, the result is empty.\n        For division involving quantities, the resulting quantity will have the appropriate unit.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Division result\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n            return []\n        if right == 0:\n            return []\n        try:\n            return left / right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Division.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Divides the left operand by the right operand (supported for Integer, Decimal, and Quantity).  The result of a division is always Decimal, even if the inputs are both Integer. For integer division, use the <code>div</code> operator. If an attempt is made to divide by zero, the result is empty. For division involving quantities, the resulting quantity will have the appropriate unit.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Division result</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Divides the left operand by the right operand (supported for Integer, Decimal, and Quantity). \n    The result of a division is always Decimal, even if the inputs are both Integer. For integer division,\n    use the `div` operator.\n    If an attempt is made to divide by zero, the result is empty.\n    For division involving quantities, the resulting quantity will have the appropriate unit.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Division result\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n        return []\n    if right == 0:\n        return []\n    try:\n        return left / right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.FHIRMathOperator","title":"<code>FHIRMathOperator</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>Abstract class definition for the category of math FHIRPath operators.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class FHIRMathOperator(FHIRPath):\n    \"\"\"\n    Abstract class definition for the category of math FHIRPath operators. \n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def convert_to_fhirpath_types(self, item):\n        from fhircraft.fhir.resources.datatypes import get_complex_FHIR_type\n        if isinstance(item, get_complex_FHIR_type('Quantity')):\n            return Quantity(item.value, item.code)\n        else:\n            return item \n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        create = kwargs.get('create')\n        left_collection = [\n            item.value if isinstance(item, FHIRPathCollectionItem) else item \n                for item in ensure_list(self.left.evaluate(collection, create))\n        ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n        left_collection = [self.convert_to_fhirpath_types(item) for item in left_collection]\n\n        right_collection = [ \n            item.value if isinstance(item, FHIRPathCollectionItem) else item  \n                for item in ensure_list(self.right.evaluate(collection, create))\n        ] if isinstance(self.right, FHIRPath) else ensure_list(self.right)\n        right_collection = [self.convert_to_fhirpath_types(item) for item in right_collection]\n\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the left expression, instead got a {len(collection)}-items collection.')\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the right expression, instead got a {len(collection)}-items collection.')\n        return left_collection[0], right_collection[0]\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Mod","title":"<code>Mod</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>mod</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Mod(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`mod`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Computes the remainder of the truncated division of its arguments (supported for Integer and Decimal).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Truncated division remainder\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float)) or not isinstance(right, (int, float)):\n            return []\n        if right == 0:\n            return []\n        try:\n            return left % right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Mod.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Computes the remainder of the truncated division of its arguments (supported for Integer and Decimal).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Truncated division remainder</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Computes the remainder of the truncated division of its arguments (supported for Integer and Decimal).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Truncated division remainder\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float)) or not isinstance(right, (int, float)):\n        return []\n    if right == 0:\n        return []\n    try:\n        return left % right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Multiplication","title":"<code>Multiplication</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>*</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Multiplication(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`*`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Multiplies both arguments (supported for Integer, Decimal, and Quantity). For multiplication\n        involving quantities, the resulting quantity will have the appropriate unit.\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Multiplication result\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n            return []\n        try:\n            return left * right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Multiplication.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Multiplies both arguments (supported for Integer, Decimal, and Quantity). For multiplication involving quantities, the resulting quantity will have the appropriate unit.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Multiplication result</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Multiplies both arguments (supported for Integer, Decimal, and Quantity). For multiplication\n    involving quantities, the resulting quantity will have the appropriate unit.\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Multiplication result\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n        return []\n    try:\n        return left * right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Subtraction","title":"<code>Subtraction</code>","text":"<p>               Bases: <code>FHIRMathOperator</code></p> <p>A representation of the FHIRPath <code>-</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>class Subtraction(FHIRMathOperator):\n    \"\"\"\n    A representation of the FHIRPath [`-`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Subtracts the right operand from the left operand (supported for Integer, Decimal, and Quantity).\n        When subtracting quantities, the units of each quantity must be the same.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (Any): Subtraction result\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        left, right = super().evaluate(collection,  *args, **kwargs)\n        if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n            return []\n        try:\n            return left - right\n        except TypeError:\n            return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/math/#fhircraft.fhir.path.engine.math.Subtraction.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Subtracts the right operand from the left operand (supported for Integer, Decimal, and Quantity). When subtracting quantities, the units of each quantity must be the same.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>Any</code> <p>Subtraction result</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/math.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Subtracts the right operand from the left operand (supported for Integer, Decimal, and Quantity).\n    When subtracting quantities, the units of each quantity must be the same.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (Any): Subtraction result\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    left, right = super().evaluate(collection,  *args, **kwargs)\n    if not isinstance(left, (int, float, Quantity)) or not isinstance(right, (int, float, Quantity)):\n        return []\n    try:\n        return left - right\n    except TypeError:\n        return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/navigation/","title":"Navigation","text":"<p>The tree navigation module contains the object representations of the tree-navigation category FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/navigation/#fhircraft.fhir.path.engine.navigation.Children","title":"<code>Children</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>children()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/navigation.py</code> <pre><code>class Children(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`children()`](https://hl7.org/fhirpath/N1/#children-collection) function.\n    \"\"\"        \n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection with all immediate child nodes of all items in the input collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The collection of child items.\n        \"\"\"\n        collection = ensure_list(collection)\n        children_collection = []\n        for item in collection:\n            if isinstance(item.value, BaseModel):\n                fields = item.value.model_fields\n            elif isinstance(item.value, dict):\n                fields = list(item.value.keys())\n            else:\n                fields = []\n            for field in fields:\n                children_collection.extend(\n                    Element(field).evaluate(item, create)\n                )\n        return children_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/navigation/#fhircraft.fhir.path.engine.navigation.Children.evaluate","title":"<code>evaluate(collection, create=False)</code>","text":"<p>Returns a collection with all immediate child nodes of all items in the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The collection of child items.</p> Source code in <code>fhircraft/fhir/path/engine/navigation.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection with all immediate child nodes of all items in the input collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The collection of child items.\n    \"\"\"\n    collection = ensure_list(collection)\n    children_collection = []\n    for item in collection:\n        if isinstance(item.value, BaseModel):\n            fields = item.value.model_fields\n        elif isinstance(item.value, dict):\n            fields = list(item.value.keys())\n        else:\n            fields = []\n        for field in fields:\n            children_collection.extend(\n                Element(field).evaluate(item, create)\n            )\n    return children_collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/navigation/#fhircraft.fhir.path.engine.navigation.Descendants","title":"<code>Descendants</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Representation of the FHIRPath <code>descendants()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/navigation.py</code> <pre><code>class Descendants(FHIRPathFunction):\n    \"\"\"\n    Representation of the FHIRPath [`descendants()`](https://hl7.org/fhirpath/N1/#descendants-collection) function.\n    \"\"\"        \n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection with all descendant nodes of all items in the input collection. The result does not include\n        the nodes in the input collection themselves. \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The collection of descendant items.\n\n        Note:\n            This function is a shorthand for `repeat(children())`.\n        \"\"\"    \n        return Repeat(Children()).evaluate(collection, create)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/navigation/#fhircraft.fhir.path.engine.navigation.Descendants.evaluate","title":"<code>evaluate(collection, create=False)</code>","text":"<p>Returns a collection with all descendant nodes of all items in the input collection. The result does not include the nodes in the input collection themselves. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The collection of descendant items.</p> Note <p>This function is a shorthand for <code>repeat(children())</code>.</p> Source code in <code>fhircraft/fhir/path/engine/navigation.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool = False) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection with all descendant nodes of all items in the input collection. The result does not include\n    the nodes in the input collection themselves. \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The collection of descendant items.\n\n    Note:\n        This function is a shorthand for `repeat(children())`.\n    \"\"\"    \n    return Repeat(Children()).evaluate(collection, create)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/","title":"Strings","text":"<p>The functions in this section operate on collections with a single item. If there is more than one item, or an item that is not a String, the evaluation of the expression will end and signal an error to the calling environment.</p> <p>To use these functions over a collection with multiple items, one may use filters like <code>where()</code> and <code>select()</code>:</p> <pre><code>Patient.name.given.select(substring(0))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Concatenation","title":"<code>Concatenation</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath <code>&amp;</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>right</code> <code>FHIRPath</code> <p>Right operand.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Concatenation(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath [`&amp;`](https://hl7.org/fhirpath/N1/#and) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        right (FHIRPath): Right operand.\n    \"\"\"\n    def __init__(self, left: FHIRPath, right:FHIRPath):\n        self.left = left\n        self.right = right\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        For strings, will concatenate the strings, where an empty operand is taken to be the empty string.\n        This differs from + on two strings, which will result in an empty collection when one of the operands\n        is empty. This operator is specifically included to simplify treating an empty collection as an empty\n        string, a common use case in string manipulation.\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            result (str): Concatenated string\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        create = kwargs.get('create')\n        left_collection = [\n            item.value if isinstance(item, FHIRPathCollectionItem) else item \n                for item in ensure_list(self.left.evaluate(collection, create))\n        ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n\n        right_collection = [ \n            item.value if isinstance(item, FHIRPathCollectionItem) else item  \n                for item in ensure_list(self.right.evaluate(collection, create))\n        ] if isinstance(self.right, FHIRPath) else ensure_list(self.right)\n\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the left expression, instead got a {len(collection)}-items collection.')\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the right expression, instead got a {len(collection)}-items collection.')\n\n        left =  left_collection[0] if len(left_collection) &gt; 0 else '' \n        right =  right_collection[0] if len(right_collection) &gt; 0 else ''\n\n        return f'{left}{right}'\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.right.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.right.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and other.left == self.left and other.right == self.right\n\n    def __hash__(self):\n        return hash((self.left, self.right))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Concatenation.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>For strings, will concatenate the strings, where an empty operand is taken to be the empty string. This differs from + on two strings, which will result in an empty collection when one of the operands is empty. This operator is specifically included to simplify treating an empty collection as an empty string, a common use case in string manipulation.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>str</code> <p>Concatenated string</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    For strings, will concatenate the strings, where an empty operand is taken to be the empty string.\n    This differs from + on two strings, which will result in an empty collection when one of the operands\n    is empty. This operator is specifically included to simplify treating an empty collection as an empty\n    string, a common use case in string manipulation.\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        result (str): Concatenated string\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    create = kwargs.get('create')\n    left_collection = [\n        item.value if isinstance(item, FHIRPathCollectionItem) else item \n            for item in ensure_list(self.left.evaluate(collection, create))\n    ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n\n    right_collection = [ \n        item.value if isinstance(item, FHIRPathCollectionItem) else item  \n            for item in ensure_list(self.right.evaluate(collection, create))\n    ] if isinstance(self.right, FHIRPath) else ensure_list(self.right)\n\n    if len(left_collection)&gt;1:\n        raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the left expression, instead got a {len(collection)}-items collection.')\n    if len(left_collection)&gt;1:\n        raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the right expression, instead got a {len(collection)}-items collection.')\n\n    left =  left_collection[0] if len(left_collection) &gt; 0 else '' \n    right =  right_collection[0] if len(right_collection) &gt; 0 else ''\n\n    return f'{left}{right}'\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Contains","title":"<code>Contains</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>contains()</code> function.</p> <p>Attributes:</p> Name Type Description <code>substring</code> <code>str</code> <p>Substring to query.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Contains(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`contains()`](https://hl7.org/fhirpath/N1/#containssubstring-string-boolean) function.\n\n    Attributes:\n        substring (str): Substring to query.\n    \"\"\"\n    def __init__(self, substring: str):\n        self.substring = substring\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true when the given substring is a substring of the input string.\n        If substring is the empty string (`''`), the result is `True`.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            (bool): Whether the string contains `substring`.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n\n        Note:\n            Note: The FHIRPath `.contains()` function described here is a string function that looks\n            for a substring in a string. This is different than the `contains` FHIRPath operator, which\n            is a list operator that looks for an element in a list.   \n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.substring:\n            return []\n        return self.substring in collection[0].value \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Contains.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true when the given substring is a substring of the input string. If substring is the empty string (<code>''</code>), the result is <code>True</code>. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the string contains <code>substring</code>.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Note <p>Note: The FHIRPath <code>.contains()</code> function described here is a string function that looks for a substring in a string. This is different than the <code>contains</code> FHIRPath operator, which is a list operator that looks for an element in a list.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true when the given substring is a substring of the input string.\n    If substring is the empty string (`''`), the result is `True`.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        (bool): Whether the string contains `substring`.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n\n    Note:\n        Note: The FHIRPath `.contains()` function described here is a string function that looks\n        for a substring in a string. This is different than the `contains` FHIRPath operator, which\n        is a list operator that looks for an element in a list.   \n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.substring:\n        return []\n    return self.substring in collection[0].value \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.EndsWith","title":"<code>EndsWith</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>endsWith()</code> function.</p> <p>Attributes:</p> Name Type Description <code>suffix</code> <code>str</code> <p>String suffix to query.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class EndsWith(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`endsWith()`](https://hl7.org/fhirpath/N1/#endswithsuffix-string-boolean) function.\n\n    Attributes:\n        suffix (str): String suffix to query.\n    \"\"\"\n    def __init__(self, suffix: str):\n        self.suffix = suffix\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true when the input string ends with the given suffix.\n        If suffix is the empty string (`''`), the result is `True`.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            (bool): Whether the string ends with `suffix`.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.suffix:\n            return []\n        return collection[0].value.endswith(self.suffix)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.EndsWith.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true when the input string ends with the given suffix. If suffix is the empty string (<code>''</code>), the result is <code>True</code>. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the string ends with <code>suffix</code>.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true when the input string ends with the given suffix.\n    If suffix is the empty string (`''`), the result is `True`.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        (bool): Whether the string ends with `suffix`.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.suffix:\n        return []\n    return collection[0].value.endswith(self.suffix)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.IndexOf","title":"<code>IndexOf</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>indexOf()</code> function.</p> <p>Attributes:</p> Name Type Description <code>substring</code> <code>str</code> <p>Subtring query.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class IndexOf(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`indexOf()`](https://hl7.org/fhirpath/N1/#indexofsubstring-string-integer) function.\n\n    Attributes:\n        substring (str): Subtring query.\n    \"\"\"\n    def __init__(self, substring: str):\n        self.substring =substring\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the 0-based index of the first position substring is found in the input string, \n        or `-1` if it is not found.\n        If substring is an empty string (`''`), the function returns `0`.\n        If the input or substring is empty (`[]`), the result is empty (`[]`).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            index (int): Index of the first position of `substring`.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if len(collection)==0:\n            return []\n        return collection[0].value.find(self.substring)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.IndexOf.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the 0-based index of the first position substring is found in the input string,  or <code>-1</code> if it is not found. If substring is an empty string (<code>''</code>), the function returns <code>0</code>. If the input or substring is empty (<code>[]</code>), the result is empty (<code>[]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>index</code> <code>int</code> <p>Index of the first position of <code>substring</code>.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the 0-based index of the first position substring is found in the input string, \n    or `-1` if it is not found.\n    If substring is an empty string (`''`), the function returns `0`.\n    If the input or substring is empty (`[]`), the result is empty (`[]`).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        index (int): Index of the first position of `substring`.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if len(collection)==0:\n        return []\n    return collection[0].value.find(self.substring)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Length","title":"<code>Length</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>length()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Length(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`length()`](https://hl7.org/fhirpath/N1/#length-integer) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the length of the input string. If the input collection is empty (`[]`), the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            length (int): Length of the string\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return len(collection[0].value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Length.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the length of the input string. If the input collection is empty (<code>[]</code>), the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>length</code> <code>int</code> <p>Length of the string</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the length of the input string. If the input collection is empty (`[]`), the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        length (int): Length of the string\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return len(collection[0].value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Lower","title":"<code>Lower</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>lower()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Lower(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`lower()`](https://hl7.org/fhirpath/N1/#lower-string) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the input string with all characters converted to lower case.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            string (str): Lower case string.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return collection[0].value.lower()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Lower.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the input string with all characters converted to lower case. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>Lower case string.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n    \"\"\"\n    Returns the input string with all characters converted to lower case.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        string (str): Lower case string.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return collection[0].value.lower()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Matches","title":"<code>Matches</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>matches()</code> function.</p> <p>Attributes:</p> Name Type Description <code>regex</code> <code>str</code> <p>Regular expression to match.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Matches(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`matches()`](https://hl7.org/fhirpath/N1/#matchesregex-string-boolean) function.\n\n    Attributes:\n        regex (str): Regular expression to match. \n    \"\"\"\n    def __init__(self, regex: str):\n        self.regex = regex\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns `True` when the value matches the given regular expression. Regular expressions\n        should function consistently, regardless of any culture- and locale-specific settings\n        in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.\n        If the input collection or regex are empty, the result is empty (`[]`).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            (bool): Whether string matches the regular expression `regex`.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.regex:\n            return []\n        return bool(re.match(self.regex, collection[0].value))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Matches.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns <code>True</code> when the value matches the given regular expression. Regular expressions should function consistently, regardless of any culture- and locale-specific settings in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters. If the input collection or regex are empty, the result is empty (<code>[]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether string matches the regular expression <code>regex</code>.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns `True` when the value matches the given regular expression. Regular expressions\n    should function consistently, regardless of any culture- and locale-specific settings\n    in the environment, should be case-sensitive, use 'single line' mode and allow Unicode characters.\n    If the input collection or regex are empty, the result is empty (`[]`).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        (bool): Whether string matches the regular expression `regex`.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.regex:\n        return []\n    return bool(re.match(self.regex, collection[0].value))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Replace","title":"<code>Replace</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>replace()</code> function.</p> <p>Attributes:</p> Name Type Description <code>pattern</code> <code>str</code> <p>Substring to substitute. </p> <code>substitution</code> <code>str</code> <p>String to substitute <code>pattern</code> with.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Replace(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`replace()`](https://hl7.org/fhirpath/N1/#replacepattern-string-substitution-string-string) function.\n\n    Attributes:\n        pattern (str): Substring to substitute. \n        substitution (str): String to substitute `pattern` with.\n    \"\"\"\n    def __init__(self, pattern: str, substitution: str):\n        self.pattern = pattern\n        self.substitution = substitution\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the input string with all instances of `pattern` replaced with `substitution`. \n        If the substitution is the empty string (`''`), instances of pattern are removed from the result.\n        If pattern is the empty string (`''`), every character in the input string is surrounded by \n        the substitution, e.g. `'abc'.replace('','x')` becomes `'xaxbxcx'`.\n        If the input collection, pattern, or substitution are empty, the result is empty ({ }).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            string (str): Substituted string\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.substitution:\n            return []\n        return collection[0].value.replace(self.pattern, self.substitution)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Replace.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the input string with all instances of <code>pattern</code> replaced with <code>substitution</code>.  If the substitution is the empty string (<code>''</code>), instances of pattern are removed from the result. If pattern is the empty string (<code>''</code>), every character in the input string is surrounded by  the substitution, e.g. <code>'abc'.replace('','x')</code> becomes <code>'xaxbxcx'</code>. If the input collection, pattern, or substitution are empty, the result is empty ({ }).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>Substituted string</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n    \"\"\"\n    Returns the input string with all instances of `pattern` replaced with `substitution`. \n    If the substitution is the empty string (`''`), instances of pattern are removed from the result.\n    If pattern is the empty string (`''`), every character in the input string is surrounded by \n    the substitution, e.g. `'abc'.replace('','x')` becomes `'xaxbxcx'`.\n    If the input collection, pattern, or substitution are empty, the result is empty ({ }).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        string (str): Substituted string\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.substitution:\n        return []\n    return collection[0].value.replace(self.pattern, self.substitution)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.ReplaceMatches","title":"<code>ReplaceMatches</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>replaceMatches()</code> function.</p> <p>Attributes:</p> Name Type Description <code>regex</code> <code>str</code> <p>Regular expression to substitute. </p> <code>substitution</code> <code>str</code> <p>String to substitute <code>regex</code> with.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class ReplaceMatches(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`replaceMatches()`](https://hl7.org/fhirpath/N1/#replacematchesregex-string-substitution-string-string) function.\n\n    Attributes:\n        regex (str): Regular expression to substitute. \n        substitution (str): String to substitute `regex` with.\n    \"\"\"\n    def __init__(self, regex: str, substitution: str):\n        self.regex = regex\n        self.substitution = substitution\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n        \"\"\"\n        Matches the input using the regular expression in regex and replaces each match with the \n        substitution string. The substitution may refer to identified match groups in the regular expression.\n        If the input collection, regex, or substitution are empty, the result is empty (`[]`).\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            string (str): Substituted string\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.regex or not self.substitution:\n            return []\n        return re.sub(self.regex, self.substitution, collection[0].value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.ReplaceMatches.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Matches the input using the regular expression in regex and replaces each match with the  substitution string. The substitution may refer to identified match groups in the regular expression. If the input collection, regex, or substitution are empty, the result is empty (<code>[]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>Substituted string</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n    \"\"\"\n    Matches the input using the regular expression in regex and replaces each match with the \n    substitution string. The substitution may refer to identified match groups in the regular expression.\n    If the input collection, regex, or substitution are empty, the result is empty (`[]`).\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        string (str): Substituted string\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.regex or not self.substitution:\n        return []\n    return re.sub(self.regex, self.substitution, collection[0].value)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.StartsWith","title":"<code>StartsWith</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>startsWith()</code> function.</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <code>str</code> <p>String prefix to query.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class StartsWith(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`startsWith()`](https://hl7.org/fhirpath/N1/#startswithprefix-string-boolean) function.\n\n    Attributes:\n        prefix (str): String prefix to query.\n    \"\"\"\n    def __init__(self, prefix: str):\n        self.prefix = prefix\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        Returns true when the input string starts with the given prefix.\n        If prefix is the empty string (`''`), the result is `True`.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            (bool): Whether the string starts with `prefix`.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.prefix:\n            return []\n        return collection[0].value.startswith(self.prefix)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.StartsWith.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns true when the input string starts with the given prefix. If prefix is the empty string (<code>''</code>), the result is <code>True</code>. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the string starts with <code>prefix</code>.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Returns true when the input string starts with the given prefix.\n    If prefix is the empty string (`''`), the result is `True`.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        (bool): Whether the string starts with `prefix`.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.prefix:\n        return []\n    return collection[0].value.startswith(self.prefix)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.StringManipulationFunction","title":"<code>StringManipulationFunction</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>Abstract class definition for category of string manipulation FHIRPath functions.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class StringManipulationFunction(FHIRPathFunction):    \n    \"\"\"\n    Abstract class definition for category of string manipulation FHIRPath functions. \n    \"\"\"\n    def validate_collection(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Validates the input collection of a FHIRPath string manipulation function. \n\n        Args: \n            collection (List[FHIRPathCollectionItem]): Collection to be validated.\n\n        Returns: \n            collection (List[FHIRPathCollectionItem]): Validated collection.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\"\n        collection = ensure_list(collection)\n        if len(collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n        if len(collection) == 1 and not isinstance(collection[0].value, str):\n            raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a string, instead got a {type(collection[0])}')\n        return collection \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.StringManipulationFunction.validate_collection","title":"<code>validate_collection(collection, *args, **kwargs)</code>","text":"<p>Validates the input collection of a FHIRPath string manipulation function. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>Collection to be validated.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>Validated collection.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def validate_collection(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Validates the input collection of a FHIRPath string manipulation function. \n\n    Args: \n        collection (List[FHIRPathCollectionItem]): Collection to be validated.\n\n    Returns: \n        collection (List[FHIRPathCollectionItem]): Validated collection.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\"\n    collection = ensure_list(collection)\n    if len(collection)&gt;1:\n        raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a single-item collection, instead got a {len(collection)}-items collection.')\n    if len(collection) == 1 and not isinstance(collection[0].value, str):\n        raise FHIRPathError(f'FHIRPath function {self.__str__()} expected a string, instead got a {type(collection[0])}')\n    return collection \n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Substring","title":"<code>Substring</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>substring()</code> function.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>Start index of the substring.</p> <code>end</code> <code>Optional[int]</code> <p>End index of the substring.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Substring(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`substring()`](https://hl7.org/fhirpath/N1/#substringstart-integer-length-integer-string) function.\n\n    Attributes:\n        start (int): Start index of the substring.\n        end (Optional[int]): End index of the substring.\n    \"\"\"\n    def __init__(self, start: int, end: Optional[int]=None):\n        self.start = start\n        self.end = end\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the part of the string starting at position start (zero-based). If length is given, will\n        return at most length number of characters from the input string.\n        If start lies outside the length of the string, the function returns empty (`[]`). If there are\n        less remaining characters in the string than indicated by length, the function returns just the \n        remaining characters.\n        If the input or start is empty, the result is empty.\n        If an empty length is provided, the behavior is the same as if length had not been provided.\n\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            substring (str): The substring indexed by the `start` and `end` indices.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection or not self.start:\n            return []\n        if not self.end:\n            return collection[0].value[self.start:]\n        return collection[0].value[self.start:self.end]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Substring.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the part of the string starting at position start (zero-based). If length is given, will return at most length number of characters from the input string. If start lies outside the length of the string, the function returns empty (<code>[]</code>). If there are less remaining characters in the string than indicated by length, the function returns just the  remaining characters. If the input or start is empty, the result is empty. If an empty length is provided, the behavior is the same as if length had not been provided.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>substring</code> <code>str</code> <p>The substring indexed by the <code>start</code> and <code>end</code> indices.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n    \"\"\"\n    Returns the part of the string starting at position start (zero-based). If length is given, will\n    return at most length number of characters from the input string.\n    If start lies outside the length of the string, the function returns empty (`[]`). If there are\n    less remaining characters in the string than indicated by length, the function returns just the \n    remaining characters.\n    If the input or start is empty, the result is empty.\n    If an empty length is provided, the behavior is the same as if length had not been provided.\n\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        substring (str): The substring indexed by the `start` and `end` indices.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection or not self.start:\n        return []\n    if not self.end:\n        return collection[0].value[self.start:]\n    return collection[0].value[self.start:self.end]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.ToChars","title":"<code>ToChars</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>toChars()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class ToChars(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`toChars()`](https://hl7.org/fhirpath/N1/#length-integer) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the list of characters in the input string. If the input collection is empty (`[]`), the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            characters (List[FHIRPathCollectionItem])): Collection of characters in the string\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return [FHIRPathCollectionItem(character, parent=collection[0]) for character in collection[0].value]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.ToChars.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the list of characters in the input string. If the input collection is empty (<code>[]</code>), the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>characters</code> <code>List[FHIRPathCollectionItem])</code> <p>Collection of characters in the string</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the list of characters in the input string. If the input collection is empty (`[]`), the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        characters (List[FHIRPathCollectionItem])): Collection of characters in the string\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return [FHIRPathCollectionItem(character, parent=collection[0]) for character in collection[0].value]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Upper","title":"<code>Upper</code>","text":"<p>               Bases: <code>StringManipulationFunction</code></p> <p>A representation of the FHIRPath <code>upper()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>class Upper(StringManipulationFunction):\n    \"\"\"\n    A representation of the FHIRPath [`upper()`](https://hl7.org/fhirpath/N1/#upper-string) function.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n        \"\"\"\n        Returns the input string with all characters converted to upper case.\n        If the input collection is empty, the result is empty.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            string (str): Upper case string.\n\n        Raises:\n            FHIRPathError: If input collection has more than one item.\n            FHIRPathError: If the item in the input collection is not a string.\n        \"\"\" \n        collection = super().validate_collection(collection)\n        if not collection:\n            return []\n        return collection[0].value.upper()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/strings/#fhircraft.fhir.path.engine.strings.Upper.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the input string with all characters converted to upper case. If the input collection is empty, the result is empty.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> <p>Upper case string.</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If input collection has more than one item.</p> <code>FHIRPathError</code> <p>If the item in the input collection is not a string.</p> Source code in <code>fhircraft/fhir/path/engine/strings.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; str:\n    \"\"\"\n    Returns the input string with all characters converted to upper case.\n    If the input collection is empty, the result is empty.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        string (str): Upper case string.\n\n    Raises:\n        FHIRPathError: If input collection has more than one item.\n        FHIRPathError: If the item in the input collection is not a string.\n    \"\"\" \n    collection = super().validate_collection(collection)\n    if not collection:\n        return []\n    return collection[0].value.upper()\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/","title":"Subsetting","text":"<p>The filtering module contains the object representations of the subsetting-category FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Exclude","title":"<code>Exclude</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>exclude()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other_collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The other collection to compute the exclusion with.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Exclude(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`exclude()`](https://hl7.org/fhirpath/N1/#excludeother-collection-collection) function.\n\n    Attributes:\n        other_collection (List[FHIRPathCollectionItem]): The other collection to compute the exclusion with.\n    \"\"\"\n    def __init__(self, other_collection: List[FHIRPathCollectionItem]):\n        self.other_collection = ensure_list(other_collection)\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns the set of elements that are not in the other collection. Duplicate items will not be\n        eliminated by this function, and order will be preserved.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return [item for item in collection if item not in self.other_collection]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Exclude.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the set of elements that are not in the other collection. Duplicate items will not be eliminated by this function, and order will be preserved.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns the set of elements that are not in the other collection. Duplicate items will not be\n    eliminated by this function, and order will be preserved.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return [item for item in collection if item not in self.other_collection]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.First","title":"<code>First</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>first()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class First(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`first()`](https://hl7.org/fhirpath/N1/#first-collection) function.\n    \"\"\"\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing only the first item in the input collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n\n        Info:\n            Equivalent to `Index(0)`.\n        \"\"\" \n        collection = ensure_list(collection)\n        return Index(0).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.First.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing only the first item in the input collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Info <p>Equivalent to <code>Index(0)</code>.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing only the first item in the input collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n\n    Info:\n        Equivalent to `Index(0)`.\n    \"\"\" \n    collection = ensure_list(collection)\n    return Index(0).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Index","title":"<code>Index</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>A representation of the FHIRPath index <code>[idx]</code> operator.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>The index value for the FHIRPath index.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Index(FHIRPath):\n    \"\"\"\n    A representation of the FHIRPath index [`[idx]`](https://hl7.org/fhirpath/N1/#index-integer-collection) operator.\n\n    Attributes:\n        index (int): The index value for the FHIRPath index.\n    \"\"\"\n    def __init__(self, index: int):\n        if not isinstance(index, int):\n            raise FHIRPathError('Index() argument must be an integer number.')\n        self.index = index\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        The indexer operation returns a collection with only the index-th item (0-based index). If the input\n        collection is empty (`[]`), or the index lies outside the boundaries of the input collection, \n        an empty collection is returned.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n            create (bool): Pad the collection array if the index lies out of bounds of the collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The indexed collection item.\n\n        Raises:\n            FhirPathError: If `create=True` and collection is composed of items with different parent elements.\n\n        Notes:\n            The collection padding with `create=True` allows the function to create and later access new elements. \n            The padded object is initialized based on the collection items' common parent (if exists).\n            Therefore, this option is only available for a homogeneous collection of items.  \n        \"\"\"        \n        # Ensure that we are working with an array            \n        collection = ensure_list(collection)\n        # Check wheter array is too short and it can be extended \n        if len(collection) &lt;= self.index and create:\n            # Calculate how many elements must be padded\n            pad = self.index - len(collection) + 1\n            # if collection.parent:\n            #     collection.extend([collection.construct_resource() for __ in range(pad)])   \n            # else:\n            print(collection)\n            all_same_parent = collection and all([item.parent.value in [subitem.parent.value for subitem in collection] if item.parent else True for item in collection])\n            if all_same_parent:\n                parent_array = collection[0]\n                if parent_array.parent:\n                    new_values = ensure_list(getattr(parent_array.parent.value, parent_array.path.label))\n                    new_values.extend([parent_array.construct_resource() for __ in range(pad)])   \n                else:\n                    new_values = collection\n                    new_values.extend([None for __ in range(pad)])\n                return [FHIRPathCollectionItem(\n                    new_values[self.index], \n                    path=Element(parent_array.element), \n                    setter=partial(parent_array.setter, index=self.index) if parent_array.setter else None, \n                    parent=parent_array.parent\n                )]\n            else:\n                raise FHIRPathError(f'Cannot create new array element due to inhomogeneity in parents')\n        # If index is within array bounds, get element\n        if collection and len(collection) &gt; self.index:\n            return [collection[self.index]]\n        # Else return empty list\n        return []\n\n    def __eq__(self, other):\n        return isinstance(other, Index) and self.index == other.index\n\n    def __str__(self):\n        return '[%i]' % self.index\n\n    def __repr__(self):\n        return '%s(index=%r)' % (self.__class__.__name__, self.index)\n\n    def __hash__(self):\n        return hash(self.index)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Index.evaluate","title":"<code>evaluate(collection, create)</code>","text":"<p>The indexer operation returns a collection with only the index-th item (0-based index). If the input collection is empty (<code>[]</code>), or the index lies outside the boundaries of the input collection,  an empty collection is returned.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <code>create</code> <code>bool</code> <p>Pad the collection array if the index lies out of bounds of the collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The indexed collection item.</p> <p>Raises:</p> Type Description <code>FhirPathError</code> <p>If <code>create=True</code> and collection is composed of items with different parent elements.</p> Notes <p>The collection padding with <code>create=True</code> allows the function to create and later access new elements.  The padded object is initialized based on the collection items' common parent (if exists). Therefore, this option is only available for a homogeneous collection of items.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], create: bool) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    The indexer operation returns a collection with only the index-th item (0-based index). If the input\n    collection is empty (`[]`), or the index lies outside the boundaries of the input collection, \n    an empty collection is returned.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n        create (bool): Pad the collection array if the index lies out of bounds of the collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The indexed collection item.\n\n    Raises:\n        FhirPathError: If `create=True` and collection is composed of items with different parent elements.\n\n    Notes:\n        The collection padding with `create=True` allows the function to create and later access new elements. \n        The padded object is initialized based on the collection items' common parent (if exists).\n        Therefore, this option is only available for a homogeneous collection of items.  \n    \"\"\"        \n    # Ensure that we are working with an array            \n    collection = ensure_list(collection)\n    # Check wheter array is too short and it can be extended \n    if len(collection) &lt;= self.index and create:\n        # Calculate how many elements must be padded\n        pad = self.index - len(collection) + 1\n        # if collection.parent:\n        #     collection.extend([collection.construct_resource() for __ in range(pad)])   \n        # else:\n        print(collection)\n        all_same_parent = collection and all([item.parent.value in [subitem.parent.value for subitem in collection] if item.parent else True for item in collection])\n        if all_same_parent:\n            parent_array = collection[0]\n            if parent_array.parent:\n                new_values = ensure_list(getattr(parent_array.parent.value, parent_array.path.label))\n                new_values.extend([parent_array.construct_resource() for __ in range(pad)])   \n            else:\n                new_values = collection\n                new_values.extend([None for __ in range(pad)])\n            return [FHIRPathCollectionItem(\n                new_values[self.index], \n                path=Element(parent_array.element), \n                setter=partial(parent_array.setter, index=self.index) if parent_array.setter else None, \n                parent=parent_array.parent\n            )]\n        else:\n            raise FHIRPathError(f'Cannot create new array element due to inhomogeneity in parents')\n    # If index is within array bounds, get element\n    if collection and len(collection) &gt; self.index:\n        return [collection[self.index]]\n    # Else return empty list\n    return []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Intersect","title":"<code>Intersect</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>intersect()</code> function.</p> <p>Attributes:</p> Name Type Description <code>other_collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The other collection to compute the intersection with.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Intersect(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`intersect()`](https://hl7.org/fhirpath/N1/#intersectother-collection-collection) function.\n\n    Attributes:\n        other_collection (List[FHIRPathCollectionItem]): The other collection to compute the intersection with.\n    \"\"\"\n    def __init__(self, other_collection: List[FHIRPathCollectionItem]):\n        self.other_collection = ensure_list(other_collection)\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns the set of elements that are in both collections. Duplicate items will be eliminated\n        by this function. Order of items is preserved in the result of this function.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return [item for item in collection if item in self.other_collection]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Intersect.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns the set of elements that are in both collections. Duplicate items will be eliminated by this function. Order of items is preserved in the result of this function.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns the set of elements that are in both collections. Duplicate items will be eliminated\n    by this function. Order of items is preserved in the result of this function.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return [item for item in collection if item in self.other_collection]\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Last","title":"<code>Last</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>last()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Last(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`last()`](https://hl7.org/fhirpath/N1/#last-collection) function.\n    \"\"\"\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing only the last item in the input collection. \n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n\n        Info:\n            Equivalent to `Index(-1)`.\n        \"\"\" \n        collection = ensure_list(collection)\n        return Index(-1).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Last.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing only the last item in the input collection. </p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Info <p>Equivalent to <code>Index(-1)</code>.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing only the last item in the input collection. \n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n\n    Info:\n        Equivalent to `Index(-1)`.\n    \"\"\" \n    collection = ensure_list(collection)\n    return Index(-1).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Single","title":"<code>Single</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>single()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Single(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`single()`](https://hl7.org/fhirpath/N1/#single-collection) function.\n    \"\"\"\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Will return the single item in the input if there is just one item. If the input collection is empty (`[]`), the result is empty. \n        If there are multiple items, an error is signaled to the evaluation environment. This function is useful for ensuring that an \n        error is returned if an assumption about cardinality is violated at run-time.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n\n        Info:\n            Equivalent to `Index(0)` with additional error raising in case of non-singleton input collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        if len(collection) &gt; 1:\n            raise FHIRPathError(f'Expected single value for single(), instead got {len(collection)} items in the collection')\n        return Index(0).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Single.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Will return the single item in the input if there is just one item. If the input collection is empty (<code>[]</code>), the result is empty.  If there are multiple items, an error is signaled to the evaluation environment. This function is useful for ensuring that an  error is returned if an assumption about cardinality is violated at run-time.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Info <p>Equivalent to <code>Index(0)</code> with additional error raising in case of non-singleton input collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Will return the single item in the input if there is just one item. If the input collection is empty (`[]`), the result is empty. \n    If there are multiple items, an error is signaled to the evaluation environment. This function is useful for ensuring that an \n    error is returned if an assumption about cardinality is violated at run-time.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n\n    Info:\n        Equivalent to `Index(0)` with additional error raising in case of non-singleton input collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    if len(collection) &gt; 1:\n        raise FHIRPathError(f'Expected single value for single(), instead got {len(collection)} items in the collection')\n    return Index(0).evaluate(collection, create=False)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Skip","title":"<code>Skip</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>skip()</code> function.</p> <p>Attributes:</p> Name Type Description <code>num</code> <code>int</code> <p>The number of items to skip.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Skip(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`skip()`](https://hl7.org/fhirpath/N1/#skipnum-integer-collection) function.\n\n    Attributes:\n        num (int): The number of items to skip.\n    \"\"\"\n    def __init__(self, num: int):\n        if not isinstance(num, int):\n            raise FHIRPathError('Skip() argument must be an integer number.')\n        self.num = num\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing all but the first `num` items in the input collection. Will return\n        an empty collection if there are no items remaining after the indicated number of items have \n        been skipped, or if the input collection is empty. If `num` is less than or equal to zero, the \n        input collection is simply returned.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        if self.num&lt;=0:\n            return []\n        return ensure_list(collection[self.num:])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Skip.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing all but the first <code>num</code> items in the input collection. Will return an empty collection if there are no items remaining after the indicated number of items have  been skipped, or if the input collection is empty. If <code>num</code> is less than or equal to zero, the  input collection is simply returned.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing all but the first `num` items in the input collection. Will return\n    an empty collection if there are no items remaining after the indicated number of items have \n    been skipped, or if the input collection is empty. If `num` is less than or equal to zero, the \n    input collection is simply returned.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    if self.num&lt;=0:\n        return []\n    return ensure_list(collection[self.num:])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Tail","title":"<code>Tail</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>tail()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Tail(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`tail()`](https://hl7.org/fhirpath/N1/#tail-collection) function.\n    \"\"\"\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing all but the first item in the input collection. Will return\n        an empty collection if the input collection has no items, or only one item.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        return ensure_list(collection[1:])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Tail.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing all but the first item in the input collection. Will return an empty collection if the input collection has no items, or only one item.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing all but the first item in the input collection. Will return\n    an empty collection if the input collection has no items, or only one item.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    return ensure_list(collection[1:])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Take","title":"<code>Take</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>take()</code> function.</p> <p>Attributes:</p> Name Type Description <code>num</code> <code>int</code> <p>The number of items to take.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>class Take(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`take()`](https://hl7.org/fhirpath/N1/#takenum-integer-collection) function.\n\n    Attributes:\n        num (int): The number of items to take.\n    \"\"\"\n    def __init__(self, num: int):\n        if not isinstance(num, int):\n            raise FHIRPathError('Take() argument must be an integer number.')\n        self.num = num\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n        \"\"\"\n        Returns a collection containing the first `num` items in the input collection, or less if there \n        are less than `num` items. If num is less than or equal to 0, or if the input collection \n        is empty (`[]`), take returns an empty collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            List[FHIRPathCollectionItem]): The output collection.\n        \"\"\" \n        collection = ensure_list(collection)\n        if self.num&lt;=0:\n            return []\n        return ensure_list(collection[:self.num])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/subsetting/#fhircraft.fhir.path.engine.subsetting.Take.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Returns a collection containing the first <code>num</code> items in the input collection, or less if there  are less than <code>num</code> items. If num is less than or equal to 0, or if the input collection  is empty (<code>[]</code>), take returns an empty collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>List[FHIRPathCollectionItem]</code> <p>List[FHIRPathCollectionItem]): The output collection.</p> Source code in <code>fhircraft/fhir/path/engine/subsetting.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; List[FHIRPathCollectionItem]:\n    \"\"\"\n    Returns a collection containing the first `num` items in the input collection, or less if there \n    are less than `num` items. If num is less than or equal to 0, or if the input collection \n    is empty (`[]`), take returns an empty collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        List[FHIRPathCollectionItem]): The output collection.\n    \"\"\" \n    collection = ensure_list(collection)\n    if self.num&lt;=0:\n        return []\n    return ensure_list(collection[:self.num])\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/","title":"Types","text":"<p>The tree navigation module contains the object representations of the types category FHIRPath operators/functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.As","title":"<code>As</code>","text":"<p>               Bases: <code>FHIRTypesOperator</code></p> <p>A representation of the FHIRPath <code>as</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>type_specifier</code> <code>str</code> <p>Type specifier.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>class As(FHIRTypesOperator):\n    \"\"\"\n    A representation of the FHIRPath [`as`](https://hl7.org/fhirpath/N1/#as) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        type_specifier (str): Type specifier.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        If the left operand is a collection with a single item and the second operand is an identifier,\n        this operator returns the value of the left operand if it is of the type specified in the second\n        operand, or a subclass thereof. If the identifier cannot be resolved to a valid type identifier,\n        the evaluator will throw an error. If there is more than one item in the input collection, the \n        evaluator will throw an error. Otherwise, this operator returns the empty collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        # TODO: Implement propert type specifier handling\n        value, type = super().evaluate(collection,  *args, **kwargs)\n        return value if type is not None and isinstance(value, type) else []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.As.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the left operand is a collection with a single item and the second operand is an identifier, this operator returns the value of the left operand if it is of the type specified in the second operand, or a subclass thereof. If the identifier cannot be resolved to a valid type identifier, the evaluator will throw an error. If there is more than one item in the input collection, the  evaluator will throw an error. Otherwise, this operator returns the empty collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    If the left operand is a collection with a single item and the second operand is an identifier,\n    this operator returns the value of the left operand if it is of the type specified in the second\n    operand, or a subclass thereof. If the identifier cannot be resolved to a valid type identifier,\n    the evaluator will throw an error. If there is more than one item in the input collection, the \n    evaluator will throw an error. Otherwise, this operator returns the empty collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    # TODO: Implement propert type specifier handling\n    value, type = super().evaluate(collection,  *args, **kwargs)\n    return value if type is not None and isinstance(value, type) else []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.FHIRTypesOperator","title":"<code>FHIRTypesOperator</code>","text":"<p>               Bases: <code>FHIRPath</code></p> <p>Abstract class definition for the category of types FHIRPath operators.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>class FHIRTypesOperator(FHIRPath):\n    \"\"\"\n    Abstract class definition for the category of types FHIRPath operators. \n    \"\"\"\n    def __init__(self, left: FHIRPath, type_specifier: str):\n        self.left = left\n        self.type_specifier = type_specifier\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        create = kwargs.get('create')\n        left_collection = [\n            item.value if isinstance(item, FHIRPathCollectionItem) else item \n                for item in ensure_list(self.left.evaluate(collection, create))\n        ]  if isinstance(self.left, FHIRPath) else ensure_list(self.left)\n\n        if len(left_collection)&gt;1:\n            raise FHIRPathError(f'FHIRPath operator {self.__str__()} expected a single-item collection for the left expression, instead got a {len(collection)}-items collection.')\n\n        type = {\n            'String': str,\n            'Decimal': (int, float),\n            'Integer': int,\n            'Quantity': Quantity,\n            'DateTime': DateTime,\n            'Boolean': bool,\n            'Time': Time,\n            'Date': Date,\n\n        }.get(self.type_specifier)\n\n        return left_collection[0], type\n\n    def __str__(self):\n        return f'{self.__class__.__name__.lower()}({self.left.__str__(), self.type_specifier.__str__()})'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self.left.__repr__(), self.type_specifier.__repr__()})'\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and other.left == self.left and other.type_specifier == self.type_specifier\n\n    def __hash__(self):\n        return hash((self.left, self.type_specifier))\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.Is","title":"<code>Is</code>","text":"<p>               Bases: <code>FHIRTypesOperator</code></p> <p>A representation of the FHIRPath <code>is</code> operator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>FHIRPath</code> <p>Left operand.</p> <code>type_specifier</code> <code>str</code> <p>Type specifier.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>class Is(FHIRTypesOperator):\n    \"\"\"\n    A representation of the FHIRPath [`is`](https://hl7.org/fhirpath/N1/#is) operator.\n\n    Attributes:\n        left (FHIRPath): Left operand.\n        type_specifier (str): Type specifier.\n    \"\"\"\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        \"\"\"\n        If the left operand is a collection with a single item and the second operand is a type identifier,\n        this operator returns true if the type of the left operand is the type specified in the second operand,\n        or a subclass thereof. If the input value is not of the type, this operator returns false. If the identifier\n        cannot be resolved to a valid type identifier, the evaluator will throw an error. If the input collections \n        contains more than one item, the evaluator will throw an error. In all other cases this operator returns the empty collection.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            bool\n\n        Raises:\n            FHIRPathError: If either expression evaluates to a non-singleton collection.\n        \"\"\"\n        # TODO: Implement propert type specifier handling\n        value, type = super().evaluate(collection,  *args, **kwargs)\n        return isinstance(value, type) if type else []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.Is.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>If the left operand is a collection with a single item and the second operand is a type identifier, this operator returns true if the type of the left operand is the type specified in the second operand, or a subclass thereof. If the input value is not of the type, this operator returns false. If the identifier cannot be resolved to a valid type identifier, the evaluator will throw an error. If the input collections  contains more than one item, the evaluator will throw an error. In all other cases this operator returns the empty collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Raises:</p> Type Description <code>FHIRPathError</code> <p>If either expression evaluates to a non-singleton collection.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n    \"\"\"\n    If the left operand is a collection with a single item and the second operand is a type identifier,\n    this operator returns true if the type of the left operand is the type specified in the second operand,\n    or a subclass thereof. If the input value is not of the type, this operator returns false. If the identifier\n    cannot be resolved to a valid type identifier, the evaluator will throw an error. If the input collections \n    contains more than one item, the evaluator will throw an error. In all other cases this operator returns the empty collection.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        bool\n\n    Raises:\n        FHIRPathError: If either expression evaluates to a non-singleton collection.\n    \"\"\"\n    # TODO: Implement propert type specifier handling\n    value, type = super().evaluate(collection,  *args, **kwargs)\n    return isinstance(value, type) if type else []\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.LegacyAs","title":"<code>LegacyAs</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>The as() function is supported for backwards compatibility with previous implementations of FHIRPath. Just as with the as keyword, the type argument is an identifier that must resolve to the name of a type  in a model.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>class LegacyAs(FHIRPathFunction):\n    \"\"\" \n    The as() function is supported for backwards compatibility with previous implementations of FHIRPath.\n    Just as with the as keyword, the type argument is an identifier that must resolve to the name of a type \n    in a model.  \n    \"\"\"\n    def __init__(self, type_specifier:str):\n        self.type_specifier = type_specifier\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        return As(This(), self.type_specifier).evaluate(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/types/#fhircraft.fhir.path.engine.types.LegacyIs","title":"<code>LegacyIs</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>The is() function is supported for backwards compatibility with previous implementations of FHIRPath.  Just as with the is keyword, the type argument is an identifier that must resolve to the name of a type in a model.</p> Source code in <code>fhircraft/fhir/path/engine/types.py</code> <pre><code>class LegacyIs(FHIRPathFunction):\n    \"\"\" \n    The is() function is supported for backwards compatibility with previous implementations of FHIRPath. \n    Just as with the is keyword, the type argument is an identifier that must resolve to the name of a type\n    in a model.\n    \"\"\"\n    def __init__(self, type_specifier:str):\n        self.type_specifier = type_specifier\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; bool:\n        return Is(This(), self.type_specifier).evaluate(collection)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/","title":"Utility","text":"<p>The utility module contains the object representations of the utility FHIRPath functions.</p>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Now","title":"<code>Now</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>now()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>class Now(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`now()`](http://hl7.org/fhirpath/N1/#now-datetime) function.\n    \"\"\"\n    def evaluate(self, *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the current date and time, including timezone offset.\n\n        Returns:\n            DateTime: The current date and time, including timezone offset.        \n        \"\"\" \n        now = datetime.now()\n        return DateTime(now.year, now.month, now.day, now.hour, now.minute)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Now.evaluate","title":"<code>evaluate(*args, **kwargs)</code>","text":"<p>Returns the current date and time, including timezone offset.</p> <p>Returns:</p> Name Type Description <code>DateTime</code> <code>int</code> <p>The current date and time, including timezone offset.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>def evaluate(self, *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the current date and time, including timezone offset.\n\n    Returns:\n        DateTime: The current date and time, including timezone offset.        \n    \"\"\" \n    now = datetime.now()\n    return DateTime(now.year, now.month, now.day, now.hour, now.minute)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.TimeOfDay","title":"<code>TimeOfDay</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>timeOfDay()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>class TimeOfDay(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`timeOfDay()`](http://hl7.org/fhirpath/N1/#timeOfDay-time) function.\n    \"\"\"\n    def evaluate(self, *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the current time.\n\n        Returns:\n            Time: The current time.        \n        \"\"\" \n        now = datetime.now()\n        return Time(now.hour, now.minute)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.TimeOfDay.evaluate","title":"<code>evaluate(*args, **kwargs)</code>","text":"<p>Returns the current time.</p> <p>Returns:</p> Name Type Description <code>Time</code> <code>int</code> <p>The current time.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>def evaluate(self, *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the current time.\n\n    Returns:\n        Time: The current time.        \n    \"\"\" \n    now = datetime.now()\n    return Time(now.hour, now.minute)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Today","title":"<code>Today</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>Today()</code> function.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>class Today(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`Today()`](http://hl7.org/fhirpath/N1/#today-date) function.\n    \"\"\"\n    def evaluate(self, *args, **kwargs) -&gt; int:\n        \"\"\"\n        Returns the current date.\n\n        Returns:\n            Date: The current date.        \n        \"\"\" \n        now = datetime.now()\n        return DateTime(now.year, now.month, now.day)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Today.evaluate","title":"<code>evaluate(*args, **kwargs)</code>","text":"<p>Returns the current date.</p> <p>Returns:</p> Name Type Description <code>Date</code> <code>int</code> <p>The current date.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>def evaluate(self, *args, **kwargs) -&gt; int:\n    \"\"\"\n    Returns the current date.\n\n    Returns:\n        Date: The current date.        \n    \"\"\" \n    now = datetime.now()\n    return DateTime(now.year, now.month, now.day)\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Trace","title":"<code>Trace</code>","text":"<p>               Bases: <code>FHIRPathFunction</code></p> <p>A representation of the FHIRPath <code>trace()</code> function.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code> (str</code> <p>Subtring query.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>class Trace(FHIRPathFunction):\n    \"\"\"\n    A representation of the FHIRPath [`trace()`](http://hl7.org/fhirpath/N1/#tracename-string-projection-expression-collection) function.\n\n    Attributes:\n        name  (str): Subtring query.\n    \"\"\"\n    def __init__(self, name: str, projection: Optional[FHIRPath] = None):\n        self.name = name\n        self.projection = projection\n\n    def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n        \"\"\"\n        Adds a `String` representation of the input collection to the diagnostic log, using the `name` argument\n        as the name in the log. This log should be made available to the user in some appropriate fashion. Does not\n        change the input, so returns the input collection as output.\n\n        If the `projection` argument is used, the trace would log the result of evaluating the project expression on the input,\n        but still return the input to the trace function unchanged.\n\n        Args: \n            collection (List[FHIRPathCollectionItem])): The input collection.\n\n        Returns:\n            collection (List[FHIRPathCollectionItem])): The input collection.            \n        \"\"\" \n        log_collection = collection\n        if self.projection:\n            log_collection = Select(self.projection).evaluate(collection, *args, **kwargs)\n        logger.debug(f'{self.name} - {[str(item.value) if isinstance(item, FHIRPathCollectionItem) else str(item) for item in ensure_list(log_collection)]}')        \n        return collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/path/engine/utility/#fhircraft.fhir.path.engine.utility.Trace.evaluate","title":"<code>evaluate(collection, *args, **kwargs)</code>","text":"<p>Adds a <code>String</code> representation of the input collection to the diagnostic log, using the <code>name</code> argument as the name in the log. This log should be made available to the user in some appropriate fashion. Does not change the input, so returns the input collection as output.</p> <p>If the <code>projection</code> argument is used, the trace would log the result of evaluating the project expression on the input, but still return the input to the trace function unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>List[FHIRPathCollectionItem]</code> <p>The input collection.</p> required <p>Returns:</p> Name Type Description <code>collection</code> <code>List[FHIRPathCollectionItem])</code> <p>The input collection.</p> Source code in <code>fhircraft/fhir/path/engine/utility.py</code> <pre><code>def evaluate(self, collection: List[FHIRPathCollectionItem], *args, **kwargs) -&gt; int:\n    \"\"\"\n    Adds a `String` representation of the input collection to the diagnostic log, using the `name` argument\n    as the name in the log. This log should be made available to the user in some appropriate fashion. Does not\n    change the input, so returns the input collection as output.\n\n    If the `projection` argument is used, the trace would log the result of evaluating the project expression on the input,\n    but still return the input to the trace function unchanged.\n\n    Args: \n        collection (List[FHIRPathCollectionItem])): The input collection.\n\n    Returns:\n        collection (List[FHIRPathCollectionItem])): The input collection.            \n    \"\"\" \n    log_collection = collection\n    if self.projection:\n        log_collection = Select(self.projection).evaluate(collection, *args, **kwargs)\n    logger.debug(f'{self.name} - {[str(item.value) if isinstance(item, FHIRPathCollectionItem) else str(item) for item in ensure_list(log_collection)]}')        \n    return collection\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/","title":"Base","text":""},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRBaseModel","title":"<code>FHIRBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>FHIRPathMixin</code></p> <p>Base class for representation of FHIR resources as Pydantic objects. </p> <p>Expands the Pydantic BaseModel class with FHIR-specific methods.</p> Source code in <code>fhircraft/fhir/resources/base.py</code> <pre><code>class FHIRBaseModel(BaseModel, FHIRPathMixin):\n    \"\"\"\n    Base class for representation of FHIR resources as Pydantic objects. \n\n    Expands the Pydantic [BaseModel](https://docs.pydantic.dev/latest/api/base_model/) class with FHIR-specific methods.    \n    \"\"\"    \n    def model_dump(self, *args, **kwargs):\n        kwargs.update({'by_alias': True, 'exclude_none': True})\n        return super().model_dump(*args, **kwargs)\n\n    def model_dump_json(self, *args, **kwargs):\n        kwargs.update({'by_alias': True, 'exclude_none': True})\n        return super().model_dump_json(*args, **kwargs)\n\n    @classmethod \n    def model_construct_with_slices(cls, slice_copies:int=9) -&gt; object:\n        '''\n        Constructs a model with sliced elements by creating empty slice instances based on the specified number of slice copies. \n        The method iterates over the sliced elements of the class, generates slice resources, and sets them in the resource collection. \n\n        Args:\n            slice_copies (int): Optional, an integer specifying the number of copies for each slice (default is 9).\n\n        Returns:\n            instance (Self): An instance of the model with the sliced elements constructed.\n        ''' \n        from fhircraft.fhir.path import fhirpath\n        instance = super().model_construct()\n        for element, slices in cls.get_sliced_elements().items():\n            slice_resources = []\n            for slice in slices:\n                # Add empty slice instances\n                slice_resources.extend([\n                    slice.model_construct_with_slices()\n                        for _ in range(min(slice.max_cardinality, slice_copies))\n                ])\n            # Set the whole list of slices in the resource\n            collection = fhirpath.parse(element).find_or_create(instance)\n            [col.set_literal(slice_resources) for col in collection]\n        return instance\n\n    @classmethod \n    def get_sliced_elements(cls):\n        '''\n        Get the sliced elements from the model fields and their extension fields.\n        Sliced elements are filtered based on being instances of `FHIRSliceModel`.\n\n        Returns:\n            slices (dict): A dictionary with field names as keys and corresponding sliced elements as values.\n        '''        \n        # Get model elements' fields\n        fields = copy(cls.model_fields)\n        # Get model elements' extension fields \n        fields.update({ \n            f'{field_name}.extension': next((arg.model_fields.get('extension')\n                    for arg in get_all_models_from_field(field) if arg.model_fields.get('extension'))\n            , None) for field_name, field in cls.model_fields.items()  if field_name != 'extension'\n        })\n        # Compile the sliced elements in the model\n        return {\n            field_name: slices for field_name, field in fields.items() \n                if field and bool(slices := list(get_all_models_from_field(field, issubclass_of=FHIRSliceModel))) \n        } \n\n    @classmethod\n    def clean_unusued_slice_instances(cls, resource):\n        '''\n        Cleans up unused or incomplete slice instances within the given FHIR resource by iterating through the \n        sliced elements of the class, identifying valid elements, and updating the resource with only the valid slices. \n        '''\n        from fhircraft.fhir.path import fhirpath\n        # Remove unused/incomplete slices\n        for element, slices in cls.get_sliced_elements().items():\n            valid_elements = [col.value for col in fhirpath.parse(element).find_or_create(resource) if col.value is not None]        \n            new_valid_elements = []\n            if not valid_elements:\n                continue\n            for slice in slices:\n                # Get all the elements that conform to this slice's definition           \n                sliced_entries = [entry for entry in valid_elements if isinstance(entry, slice)] \n                for entry in sliced_entries:\n                    if slice.get_sliced_elements():\n                        entry = slice.clean_unusued_slice_instances(entry) \n                    if (entry.is_FHIR_complete and entry.has_been_modified) \\\n                        or (entry.is_FHIR_complete  and not entry.has_been_modified and slice.min_cardinality&gt;0):\n                        if entry not in new_valid_elements:\n                            new_valid_elements.append(entry)                \n            # Set the new list with only the valid slices\n            collection = fhirpath.parse(element).find_or_create(resource)\n            [col.set_literal(new_valid_elements) for col in collection]\n        return resource\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRBaseModel.clean_unusued_slice_instances","title":"<code>clean_unusued_slice_instances(resource)</code>  <code>classmethod</code>","text":"<p>Cleans up unused or incomplete slice instances within the given FHIR resource by iterating through the  sliced elements of the class, identifying valid elements, and updating the resource with only the valid slices.</p> Source code in <code>fhircraft/fhir/resources/base.py</code> <pre><code>@classmethod\ndef clean_unusued_slice_instances(cls, resource):\n    '''\n    Cleans up unused or incomplete slice instances within the given FHIR resource by iterating through the \n    sliced elements of the class, identifying valid elements, and updating the resource with only the valid slices. \n    '''\n    from fhircraft.fhir.path import fhirpath\n    # Remove unused/incomplete slices\n    for element, slices in cls.get_sliced_elements().items():\n        valid_elements = [col.value for col in fhirpath.parse(element).find_or_create(resource) if col.value is not None]        \n        new_valid_elements = []\n        if not valid_elements:\n            continue\n        for slice in slices:\n            # Get all the elements that conform to this slice's definition           \n            sliced_entries = [entry for entry in valid_elements if isinstance(entry, slice)] \n            for entry in sliced_entries:\n                if slice.get_sliced_elements():\n                    entry = slice.clean_unusued_slice_instances(entry) \n                if (entry.is_FHIR_complete and entry.has_been_modified) \\\n                    or (entry.is_FHIR_complete  and not entry.has_been_modified and slice.min_cardinality&gt;0):\n                    if entry not in new_valid_elements:\n                        new_valid_elements.append(entry)                \n        # Set the new list with only the valid slices\n        collection = fhirpath.parse(element).find_or_create(resource)\n        [col.set_literal(new_valid_elements) for col in collection]\n    return resource\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRBaseModel.get_sliced_elements","title":"<code>get_sliced_elements()</code>  <code>classmethod</code>","text":"<p>Get the sliced elements from the model fields and their extension fields. Sliced elements are filtered based on being instances of <code>FHIRSliceModel</code>.</p> <p>Returns:</p> Name Type Description <code>slices</code> <code>dict</code> <p>A dictionary with field names as keys and corresponding sliced elements as values.</p> Source code in <code>fhircraft/fhir/resources/base.py</code> <pre><code>@classmethod \ndef get_sliced_elements(cls):\n    '''\n    Get the sliced elements from the model fields and their extension fields.\n    Sliced elements are filtered based on being instances of `FHIRSliceModel`.\n\n    Returns:\n        slices (dict): A dictionary with field names as keys and corresponding sliced elements as values.\n    '''        \n    # Get model elements' fields\n    fields = copy(cls.model_fields)\n    # Get model elements' extension fields \n    fields.update({ \n        f'{field_name}.extension': next((arg.model_fields.get('extension')\n                for arg in get_all_models_from_field(field) if arg.model_fields.get('extension'))\n        , None) for field_name, field in cls.model_fields.items()  if field_name != 'extension'\n    })\n    # Compile the sliced elements in the model\n    return {\n        field_name: slices for field_name, field in fields.items() \n            if field and bool(slices := list(get_all_models_from_field(field, issubclass_of=FHIRSliceModel))) \n    } \n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRBaseModel.model_construct_with_slices","title":"<code>model_construct_with_slices(slice_copies=9)</code>  <code>classmethod</code>","text":"<p>Constructs a model with sliced elements by creating empty slice instances based on the specified number of slice copies.  The method iterates over the sliced elements of the class, generates slice resources, and sets them in the resource collection. </p> <p>Parameters:</p> Name Type Description Default <code>slice_copies</code> <code>int</code> <p>Optional, an integer specifying the number of copies for each slice (default is 9).</p> <code>9</code> <p>Returns:</p> Name Type Description <code>instance</code> <code>Self</code> <p>An instance of the model with the sliced elements constructed.</p> Source code in <code>fhircraft/fhir/resources/base.py</code> <pre><code>@classmethod \ndef model_construct_with_slices(cls, slice_copies:int=9) -&gt; object:\n    '''\n    Constructs a model with sliced elements by creating empty slice instances based on the specified number of slice copies. \n    The method iterates over the sliced elements of the class, generates slice resources, and sets them in the resource collection. \n\n    Args:\n        slice_copies (int): Optional, an integer specifying the number of copies for each slice (default is 9).\n\n    Returns:\n        instance (Self): An instance of the model with the sliced elements constructed.\n    ''' \n    from fhircraft.fhir.path import fhirpath\n    instance = super().model_construct()\n    for element, slices in cls.get_sliced_elements().items():\n        slice_resources = []\n        for slice in slices:\n            # Add empty slice instances\n            slice_resources.extend([\n                slice.model_construct_with_slices()\n                    for _ in range(min(slice.max_cardinality, slice_copies))\n            ])\n        # Set the whole list of slices in the resource\n        collection = fhirpath.parse(element).find_or_create(instance)\n        [col.set_literal(slice_resources) for col in collection]\n    return instance\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRSliceModel","title":"<code>FHIRSliceModel</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base class for representation of FHIR profiled slices as Pydantic objects. </p> <p>Expands the <code>FHIRBaseModel</code> class with slice-specific methods.</p> Source code in <code>fhircraft/fhir/resources/base.py</code> <pre><code>class FHIRSliceModel(FHIRBaseModel):\n    \"\"\"\n    Base class for representation of FHIR profiled slices as Pydantic objects. \n\n    Expands the `FHIRBaseModel` class with slice-specific methods.    \n    \"\"\"\n    min_cardinality: ClassVar[int] = 0\n    max_cardinality: ClassVar[int] = 1\n\n    @property\n    def is_FHIR_complete(self):\n        \"\"\"\n        Validates if the FHIR model is complete by attempting to validate the model dump.\n        Returns `True` if the model is complete, `False` otherwise.\n        \"\"\"        \n        model = self.__class__ \n        try:\n            model.model_validate(self.model_dump())\n            return True \n        except ValidationError:\n            return False\n\n    @property\n    def has_been_modified(self):\n        \"\"\"\n        Checks if the FHIRSliceModel instance has been modified by comparing it with a new instance constructed with slices.\n        Returns `True` if the instance has been modified, `False` otherwise.\n        \"\"\"        \n        return self != self.__class__.model_construct_with_slices()\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRSliceModel.has_been_modified","title":"<code>has_been_modified</code>  <code>property</code>","text":"<p>Checks if the FHIRSliceModel instance has been modified by comparing it with a new instance constructed with slices. Returns <code>True</code> if the instance has been modified, <code>False</code> otherwise.</p>"},{"location":"reference/fhircraft/fhir/resources/base/#fhircraft.fhir.resources.base.FHIRSliceModel.is_FHIR_complete","title":"<code>is_FHIR_complete</code>  <code>property</code>","text":"<p>Validates if the FHIR model is complete by attempting to validate the model dump. Returns <code>True</code> if the model is complete, <code>False</code> otherwise.</p>"},{"location":"reference/fhircraft/fhir/resources/factory/","title":"Factory","text":"<p>Pydantic FHIR Model Factory</p>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory","title":"<code>ResourceFactory</code>","text":"Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>class ResourceFactory:\n\n    @dataclass\n    class FactoryConfig:\n        \"\"\"Represents the configuration for the Factory class.\n\n        Attributes:\n            FHIR_release (str): The FHIR release version.\n            resource_name (str): The name of the resource.\n        \"\"\"\n        FHIR_release: str\n        resource_name: str\n\n    Config: Optional[FactoryConfig]\n    construction_cache : Dict[str, BaseModel] = {}\n\n    def download_structure_definition(self, profile_url: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves the structure definition of a FHIR resource from the provided profile URL.\n\n        Parameters:\n            profile_url (str): The URL of the FHIR profile from which to retrieve the structure definition.\n\n        Returns:\n            Dict[str, Any]: A dictionary representing the structure definition of the FHIR resource.\n        \"\"\"       \n\n        if not profile_url.endswith('.json'):\n            # Construct endpoint URL for the StructureDefinition JSON\n            if profile_url.startswith('http://hl7.org/fhir/StructureDefinition'):\n                domain, resource = profile_url.rsplit('/', 1)\n                domain = domain.replace('http://hl7.org/fhir/StructureDefinition','https://hl7.org/fhir/R4/extension')\n                resource = resource.lower()\n            else:\n                domain, resource = profile_url.rsplit('/', 1)\n            json_url = f\"{domain}-{resource}.json\"\n        else:\n            json_url = profile_url\n\n        # Configure proxy if needed\n        settings = load_env_variables()\n        proxies = {\n            'https': settings.get('PROXY_URL_HTTPS'), \n            'http': settings.get('PROXY_URL_HTTP')\n        } if settings.get('PROXY_URL_HTTPS') or settings.get('PROXY_URL_HTTP') else None\n        headers = {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n        }\n        # Download the StructureDefinition JSON            \n        response = requests.get(json_url, proxies=proxies, verify=settings.get('CERTIFICATE_BUNDLE_PATH'), headers=headers)     \n        response.raise_for_status()\n        return response.json()\n\n\n    def build_tree_structure(self, elements: List[Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Builds a tree from a list of ElementDefinitions.\n\n        Parameters:\n            elements (List[Dict[str, Any]]): A list of ElementDefinitions to build the tree from.\n\n        Returns:\n            Dict[str, Any]: A tree structure representing the ElementDefinitions.\n        \"\"\"\n        tree = defaultdict(dict)\n        for element in elements:\n            current = tree\n            for part in element['id'].split('.'):\n                if ':' in part:\n                    # Handle slice definitions\n                    part, sliceName = part.split(':')\n                    current = current['children'][part]\n                    current['slices'] = current.get('slices', {})\n                    current = current['slices'].setdefault(sliceName, {})\n                else:\n                    # Handle children elements\n                    current['children'] = current.get('children', {})\n                    current = current['children'].setdefault(part, {})\n            current.update(element)\n        return tree\n\n    def _get_complex_FHIR_type(self, field_type_name: str) -&gt; Union[type,str]:     \n        \"\"\"\n        Parses and loads the FHIR element type based on the provided field type name.\n\n        Args:\n            field_type_name (str): The name of the field type to be parsed.\n\n        Returns:\n            Union[type, str]: The parsed FHIR element type, returns input string if type not found.\n        \"\"\"         \n        FHIR_COMPLEX_TYPE_PREFIX = 'http://hl7.org/fhir/StructureDefinition/'\n        FHIRPATH_TYPE_PREFIX = 'http://hl7.org/fhirpath/System.'\n        # Pre-process the type string\n        field_type_name = str(field_type_name)\n        field_type_name = field_type_name.removeprefix(FHIR_COMPLEX_TYPE_PREFIX)\n        field_type_name = field_type_name.removeprefix(FHIRPATH_TYPE_PREFIX)\n        field_type_name = capitalize(field_type_name)\n        # Check if type is a FHIR primitive datatype\n        field_type = getattr(primitives, field_type_name, None)\n        if not field_type:\n            # Check if type is a FHIR complex datatype\n            field_type = get_complex_FHIR_type(field_type_name, self.Config.FHIR_release)\n        if not field_type:\n            return field_type_name\n        return field_type\n\n    def _create_model_with_properties(self, name: str, fields: dict, base: Union[Tuple[type], type], validators: dict, properties: dict) -&gt; BaseModel:\n        \"\"\"\n        Constructs a Pydantic model with specified fields, base, validators, and properties.\n\n        Parameters:\n            name (str): The name of the model to be created.\n            fields (dict): Dictionary of fields for the model.\n            base (Union[Tuple[type], type]): Base type or tuple of base types for the model.\n            validators (dict): Dictionary of validators for the model.\n            properties (dict): Dictionary of properties to be set for the model.\n\n        Returns:\n            BaseModel: The constructed Pydantic model.\n        \"\"\"\n        # Construct the slice model\n        model = create_model(name, **fields, __base__=base, __validators__=validators)                                   \n        # Set the properties\n        for attribute, property_getter in properties.items():\n            setattr(model, attribute, property(property_getter))  \n        return model \n\n    def _construct_Pydantic_field(self, field_type: type, min_card: int, max_card: int, \n                default: Any=_Unset, description: Optional[str]=None, alias: Optional[str]=None\n        ) -&gt; Field:\n        \"\"\" \n        Constructs a Pydantic field based on the provided parameters.\n\n        Args:\n            field_type (type): The type of the field.\n            min_card (int): The minimum cardinality of the field.\n            max_card (int): The maximum cardinality of the field.\n            default (Any, optional): The default value of the field. Defaults to _Unset.\n            description (str, optional): The description of the field. Defaults to None.\n            alias (str, optional): The alias of the field. Defaults to None.\n\n        Returns:\n            Field: The constructed Pydantic field.\n        \"\"\"        \n        # Determine whether typing should be a list based on max. cardinality\n        is_list_type = max_card is None or max_card&gt;1\n        if is_list_type:\n            field_type = List[field_type]\n            default = ensure_list(default) if default is not _Unset else default\n        # Determine whether the field is optional\n        if min_card==0:\n            field_type = Optional[field_type]\n            default = None\n        # Construct the Pydantic field\n        return (    \n            field_type, Field(\n                default,\n                alias=alias,\n                description=description,\n                min_length=min_card if is_list_type else None,\n                max_length=max_card if is_list_type else None\n            )\n        )    \n\n    def _process_pattern_or_fixed_values(self, element: Dict[str, Any], constraint_prefix: str) -&gt; Any:\n        \"\"\"\n        Process the pattern or fixed values of a StructureDefinition element.\n\n        Parameters:\n            element (Dict[str, Any]): The element to process.\n            constraint_prefix (str): The prefix indicating pattern or fixed values.\n\n        Returns:\n            Any: The constrained value after processing.\n        \"\"\"        \n        # Determine the name of the StructureDefinition element's attribute that starts with either the prefix 'fixed[x]' or 'pattern[x]' \n        constraint_attribute = next((attribute for attribute in element if attribute.startswith(constraint_prefix)), None)\n        if (constrained_value := element.get(constraint_attribute)) is not None:\n            # Get the type of value that is constrained to a preset value\n            constrained_type = self._get_complex_FHIR_type(constraint_attribute.replace(constraint_prefix,''))\n            # Parse the value\n            constrained_value = constrained_type.model_validate(constrained_value) \\\n                                if inspect.isclass(constrained_type) and issubclass(constrained_type, BaseModel) \\\n                                    else constrained_value    \n        return constrained_value\n\n    def _process_choice_type_field(self, name, field_types, cardinality, fields, validators, properties, description=None):\n        \"\"\" \n        Processes choice type fields by creating Pydantic fields for each type, adding validators, and setting properties.\n\n        Args:\n            name (str): The name of the field.\n            field_types (List[type]): The types of the field.\n            cardinality (List[int]): The cardinality constraints of the field.\n            fields (dict): Dictionary of fields for the model.\n            validators (dict): Dictionary of validators for the model.\n            properties (dict): Dictionary of properties to be set for the model.\n            description (str, optional): The description of the field. Defaults to None.\n\n        Returns:\n            Tuple[dict, dict, dict]: A tuple containing updated fields, validators, and properties.\n        \"\"\"\n        # Get base name\n        name = name.replace('[x]','')\n        # Create a field for each type\n        for field_type in field_types:\n            typed_field_name = name + (field_type if isinstance(field_type, str) else field_type.__name__)\n            fields[typed_field_name] = self._construct_Pydantic_field(field_type, cardinality[0], cardinality[1], description=description)\n        # Add validator to ensure only one of these fields is set                \n        validators[f'{name}_type_choice_validator'] = model_validator(mode='after')(\n            partial(\n                fhir_validators.validate_type_choice_element, \n                field_types=field_types, \n                field_name_base=name\n            )\n        )\n        properties[name] = partial(fhir_validators.get_type_choice_value_by_base, base=name)\n        return fields, validators, properties\n\n    def _process_element_slices(self, element: dict, field_type: type) -&gt; Annotated:\n        \"\"\"\n        Process the FHIR element slices to construct Pydantic models.\n\n        Args:\n            element (dict): The element containing slice information.\n            field_type (type): The type of the field.\n\n        Returns:\n            Annotated:  A union of slice models and the original type.\n        \"\"\"\n        slice_types = []\n        for slice_name, slice_element in element['slices'].items():\n            if (slice_element_types := slice_element.get('type')) and (slice_element_canonical_urls := slice_element_types[0].get('profile')):\n                # Construct the slice model from the canonical URL\n                slice_model = ResourceFactory().construct_resource_model(slice_element_canonical_urls[0], base_model=FHIRSliceModel)\n            else:\n                # Construct the slice model's name\n                slice_name = ''.join([capitalize(word) for word in slice_name.split('-')])\n                slice_model_name = capitalize(slice_name)\n                # Process and compile all subfields of the slice\n                slice_subfields, slice_validators, slice_properties = self._process_FHIR_structure_into_Pydantic_components(slice_element, FHIRSliceModel)\n                # Construct the slice model\n                slice_model = self._create_model_with_properties(slice_model_name, \n                                    fields=slice_subfields, \n                                    base=(field_type, FHIRSliceModel), \n                                    validators=slice_validators, \n                                    properties=slice_properties\n                )\n            # Store the specific slice cardinality\n            slice_model.min_cardinality, slice_model.max_cardinality = self._process_cardinality_constraints(slice_element)\n            # Store the slice model in the list of slices of the element\n            slice_types.append(slice_model)    \n        # Create annotated type as union of slice models and original type (important, last in the definition) \n        return Annotated[\n            Union[tuple([*slice_types, field_type])], \n            Field(union_mode='left_to_right')\n        ]\n\n    def _process_cardinality_constraints(self, element):\n        \"\"\"\n        Process the cardinality constraints of a FHIR element.\n\n        Args:\n            element (Dict[str, Any]): The element containing cardinality information.\n\n        Returns:\n            Tuple[int, int]: A tuple containing the minimum and maximum cardinality values.\n        \"\"\"\n        min_card = int(element['min']) if str(element['min']).isnumeric() else None\n        max_card = int(max_string) if (max_string := str(element['max']).replace('*','99999')).isnumeric() else None\n        return min_card, max_card\n\n    def _add_model_constraint_validator(self, constraint: dict, validators: dict) -&gt; dict:\n        \"\"\"\n        Adds a model constraint validator based on the provided constraint.\n\n        Args:\n            constraint (dict): The constraint details including expression, human-readable description, key, and severity.\n            validators (dict): The dictionary of validators to update with the new constraint validator.\n\n        Returns:\n            dict: The updated dictionary of validators.\n        \"\"\"        \n        # Construct function name for validator\n        constraint_name = constraint['key'].replace('-','_')\n        validator_name = f\"FHIR_{constraint_name}_constraint_model_validator\"\n        # Add the current field to the list of validated fields\n        validators[validator_name] = model_validator(mode='after')(partial(\n            fhir_validators.validate_model_constraint, \n            expression=constraint['expression'],\n            human=constraint['human'],\n            key=constraint['key'],\n            severity=constraint['severity'],\n        ))\n        return validators\n\n    def _add_element_constraint_validator(self, field: str, constraint: dict, base: Any, validators: dict) -&gt; dict:\n        \"\"\"\n        Adds a validator for a specific element constraint to the validators dictionary.\n\n        Args:\n            field (str): The field to validate.\n            constraint (dict): The details of the constraint including expression, human-readable description, key, and severity.\n            base (Any): The base model to check for existing validators.\n            validators (dict): The dictionary of validators to update.\n\n        Returns:\n            dict: The updated dictionary of validators.\n        \"\"\"\n        # Construct function name for validator\n        constraint_name = constraint['key'].replace('-','_')\n        validator_name = f\"FHIR_{constraint_name}_constraint_validator\"\n        # Check if validator has already been constructed for another field\n        validate_fields = [field]\n        # Get the list of fields already being validated by this constraint\n        if validator_name in validators:\n            validate_fields.extend(validators.get(validator_name).decorator_info.fields)\n        # Get the list of fields already being validated by this constraint in base model\n        if base and validator_name in base.__pydantic_decorators__.field_validators:\n            validate_fields.extend(base.__pydantic_decorators__.field_validators[validator_name].info.fields) \n        # Add the current field to the list of validated fields\n        validators[validator_name] = field_validator(*validate_fields, mode='after')(partial(\n            fhir_validators.validate_element_constraint, \n            expression=constraint['expression'],\n            human=constraint['human'],\n            key=constraint['key'],\n            severity=constraint['severity'],\n        ))\n        return validators\n\n    def _process_FHIR_structure_into_Pydantic_components(self, structure: dict, base: BaseModel=None):\n        \"\"\"\n        Processes the FHIR structure elements into Pydantic components.\n\n        Args:\n            structure (dict): The structure containing FHIR elements.\n            base (BaseModel, optional): The base model to check for existing validators. Defaults to None.\n\n        Returns:\n            Tuple[dict, dict, dict]: A tuple containing fields, validators, and properties.\n        \"\"\"        \n        fields = {}\n        validators = {}\n        properties = {}\n        for name, element in structure.get('children',{}).items():\n            if base and name in base.model_fields:\n                continue \n            # Get cardinality of element\n            min_card, max_card = self._process_cardinality_constraints(element)\n            # Parse the FHIR types of the element\n            field_types = [self._get_complex_FHIR_type(field_type['code']) for field_type in element.get('type', [])]\n            # If has no type, skip element\n            if not field_types:\n                continue \n            # Handle type choice elements\n            if '[x]' in name: \n                fields, validators, properties = self._process_choice_type_field(\n                    name, field_types, [min_card, max_card], fields, validators, properties, \n                    description=element.get('short')\n                )\n                continue\n            # Handle number of element types\n            if len(field_types) &gt; 1:\n                # Accept all types \n                field_type = Union[tuple(field_types)]                 \n            else:\n                # Get single type\n                field_type = field_types[0]\n            # Start by not setting any default value (important, 'None' implies optional in Pydantic)\n            field_default = _Unset \n            # Check for pattern value constraints\n            if pattern_value := self._process_pattern_or_fixed_values(element, 'pattern'):\n                field_default = pattern_value\n                # Add the current field to the list of validated fields\n                validators[f'FHIR_{name}_pattern_constraint'] = field_validator(name, mode='after')(partial(\n                    fhir_validators.validate_FHIR_element_pattern, \n                    pattern=pattern_value,\n                ))\n            # Check for fixed value constraints\n            if fixed_value := self._process_pattern_or_fixed_values(element, 'fixed'):\n                # Use enum with single choice since Literal definition does not work at runtime\n                singleChoice = Enum(\n                    f\"{name}FixedValue\",\n                    [('fixedValue',fixed_value)],\n                    type=type(fixed_value),\n                )\n                field_default = singleChoice.fixedValue \n                field_type = singleChoice\n            # Process FHIR constraint invariants on the element\n            if constraints := element.get('constraint'):\n                for constraint in constraints:\n                    validators = self._add_element_constraint_validator(name, constraint, base, validators)\n            # Process FHIR slicing on the element, if present\n            if element.get('slices'):\n                field_type = self._process_element_slices(element, field_type)\n                # Add slicing cardinality validator for field\n                validators[f'{name}_slicing_cardinality_validator'] = field_validator(name, mode='after')(partial(\n                    fhir_validators.validate_slicing_cardinalities, field_name=name)\n                )                \n            # Process element children, if present\n            elif element.get('children'):\n                backbone_model_name = capitalize(self.Config.resource_name).strip() + capitalize(name).strip()\n                field_subfields, subfield_validators, subfield_properties = self._process_FHIR_structure_into_Pydantic_components(element, field_type)\n                for attribute, property_getter in subfield_properties.items():\n                    setattr(field_type, attribute, property(property_getter))      \n                if element['children']['extension'].get('slices'):\n                    extension_type = self._process_element_slices(element['children']['extension'], get_complex_FHIR_type('Extension', self.Config.FHIR_release))\n                    # Get cardinality of extension element\n                    extension_min_card, extension_max_card = self._process_cardinality_constraints(element['children']['extension'])\n                    # Add slicing cardinality validator for field\n                    subfield_validators[f'extension_slicing_cardinality_validator'] = field_validator('extension', mode='after')(partial(\n                        fhir_validators.validate_slicing_cardinalities, field_name='extension')\n                    )                               \n                    field_subfields['extension'] = self._construct_Pydantic_field(extension_type, extension_min_card, extension_max_card)\n                field_type = create_model(backbone_model_name, **field_subfields, __base__=field_type, __validators__=subfield_validators)                \n            # Create and add the Pydantic field for the FHIR element\n            fields[name] = self._construct_Pydantic_field(\n                field_type, min_card, max_card, \n                default=field_default, \n                description=element.get('short')\n            )\n            # IF the field is of primitive type, add aliased field to accomodate their extensions\n            if hasattr(primitives, str(field_type)):\n                fields[f'{name}_ext'] = self._construct_Pydantic_field(\n                    get_complex_FHIR_type('Element'), \n                    min_card=0, max_card=1, \n                    alias=f'_{name}', \n                    default=field_default, \n                    description=f'Placeholder element for {name} extensions'\n                )\n        return fields, validators, properties\n\n\n    def construct_resource_model(self, canonical_url: str=None, structure_definition: dict=None, base_model: type=FHIRBaseModel) -&gt; FHIRBaseModel:\n        \"\"\"\n        Constructs a Pydantic model based on the provided FHIR structure definition.\n\n        Args:\n            canonical_url (dict): The FHIR resource's or profile's canonical URL from which to download the StructureDefinition.\n            structure_definition (dict): The FHIR StructureDefinition to build the model from.\n\n        Returns:\n            model (BaseModel): The constructed Pydantic model representing the FHIR resource.\n        \"\"\"\n        # If the model has been constructed before, return the cached model\n        if canonical_url in self.construction_cache:\n            return self.construction_cache[canonical_url]\n        # Download the FHIR structure definition if the canonical URL has been specified        \n        if not structure_definition and canonical_url:\n            structure_definition = self.download_structure_definition(canonical_url)\n        # Check that the snapshot is available in the FHIR structure definition\n        if 'snapshot' not in structure_definition or 'element' not in structure_definition['snapshot']:\n            raise ValueError(\"Invalid StructureDefinition: Missing 'snapshot' or 'element' field\")\n        # Pre-process the snapshort elements into a tree structure to simplify model construction later\n        tree = self.build_tree_structure(structure_definition['snapshot']['element'])\n        resource_type = structure_definition['type']\n        structure = tree['children'][resource_type]\n        # Configure the factory for the current FHIR environment\n        self.Config = self.FactoryConfig(\n            FHIR_release = get_FHIR_release_from_version(structure_definition['fhirVersion']), \n            resource_name = structure_definition['name'], \n        )\n        # Process the FHIR resource's elements &amp; constraints into Pydantic fields &amp; validators\n        fields, validators, properties = self._process_FHIR_structure_into_Pydantic_components(structure)\n        # Process resource-level constraints \n        for constraint in structure['constraint']:\n            validators = self._add_model_constraint_validator(constraint, validators)\n        # If the resource has metadata, prefill the information       \n        if 'meta' in fields:\n            fields['resourceType'] = (\n                Literal[f'{resource_type}'], resource_type\n            )\n            fields['meta'] = (\n                Optional[get_complex_FHIR_type('Meta', self.Config.FHIR_release)], \n                get_complex_FHIR_type('Meta', self.Config.FHIR_release)(\n                    profile=[structure_definition['url']], \n                    versionId=structure_definition['version']\n                )\n            )\n        # Construct the Pydantic model representing the FHIR resource\n        model = self._create_model_with_properties(self.Config.resource_name, \n            fields=fields, \n            base=base_model, \n            validators=validators, \n            properties=properties\n        )            \n        # Add the current model to the cache\n        self.construction_cache[canonical_url] = model\n        return model \n\n\n    def construct_dataelement_model(self, structure_definition):\n        if 'snapshot' not in structure_definition or 'element' not in structure_definition['snapshot']:\n            raise ValueError(\"Invalid StructureDefinition: Missing 'snapshot' or 'element' field\")\n        resource_type = structure_definition['type']\n        elements = structure_definition['snapshot']['element']\n        tree = self.build_tree_structure(elements)        \n        # Configure the factory for the current FHIR environment\n        self.Config = self.FactoryConfig(\n            FHIR_release = get_FHIR_release_from_version(structure_definition['fhirVersion']), \n            resource_name = structure_definition['name'], \n        )\n        structure = tree['children'][resource_type]\n        if 'baseDefinition' in structure_definition:\n            base_name = structure_definition['baseDefinition'].replace('http://hl7.org/fhir/StructureDefinition/','')\n            base = self.construction_cache.get(base_name)\n        else:\n            base = FHIRBaseModel\n        fields, validators, properties = self._process_FHIR_structure_into_Pydantic_components(structure, base)\n        for constraint in structure.get('constraint',[]):\n            validators = self._add_model_constraint_validator(constraint, validators)\n        model = create_model(self.Config.resource_name, **fields, __base__=base, __validators__=validators)\n        model.__doc__ = structure['short']\n        for attribute, property_getter in properties.items():\n            setattr(model, attribute, property(property_getter))\n        return model \n\n    def clear_chache(self):\n        \"\"\"\n        Clears the factory cache.\n        \"\"\"\n        self.construction_cache = {}\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory.FactoryConfig","title":"<code>FactoryConfig</code>","text":"<p>Represents the configuration for the Factory class.</p> <p>Attributes:</p> Name Type Description <code>FHIR_release</code> <code>str</code> <p>The FHIR release version.</p> <code>resource_name</code> <code>str</code> <p>The name of the resource.</p> Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>@dataclass\nclass FactoryConfig:\n    \"\"\"Represents the configuration for the Factory class.\n\n    Attributes:\n        FHIR_release (str): The FHIR release version.\n        resource_name (str): The name of the resource.\n    \"\"\"\n    FHIR_release: str\n    resource_name: str\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory.build_tree_structure","title":"<code>build_tree_structure(elements)</code>","text":"<p>Builds a tree from a list of ElementDefinitions.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Dict[str, Any]]</code> <p>A list of ElementDefinitions to build the tree from.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A tree structure representing the ElementDefinitions.</p> Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>def build_tree_structure(self, elements: List[Dict[str, Any]]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Builds a tree from a list of ElementDefinitions.\n\n    Parameters:\n        elements (List[Dict[str, Any]]): A list of ElementDefinitions to build the tree from.\n\n    Returns:\n        Dict[str, Any]: A tree structure representing the ElementDefinitions.\n    \"\"\"\n    tree = defaultdict(dict)\n    for element in elements:\n        current = tree\n        for part in element['id'].split('.'):\n            if ':' in part:\n                # Handle slice definitions\n                part, sliceName = part.split(':')\n                current = current['children'][part]\n                current['slices'] = current.get('slices', {})\n                current = current['slices'].setdefault(sliceName, {})\n            else:\n                # Handle children elements\n                current['children'] = current.get('children', {})\n                current = current['children'].setdefault(part, {})\n        current.update(element)\n    return tree\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory.clear_chache","title":"<code>clear_chache()</code>","text":"<p>Clears the factory cache.</p> Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>def clear_chache(self):\n    \"\"\"\n    Clears the factory cache.\n    \"\"\"\n    self.construction_cache = {}\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory.construct_resource_model","title":"<code>construct_resource_model(canonical_url=None, structure_definition=None, base_model=FHIRBaseModel)</code>","text":"<p>Constructs a Pydantic model based on the provided FHIR structure definition.</p> <p>Parameters:</p> Name Type Description Default <code>canonical_url</code> <code>dict</code> <p>The FHIR resource's or profile's canonical URL from which to download the StructureDefinition.</p> <code>None</code> <code>structure_definition</code> <code>dict</code> <p>The FHIR StructureDefinition to build the model from.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>model</code> <code>BaseModel</code> <p>The constructed Pydantic model representing the FHIR resource.</p> Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>def construct_resource_model(self, canonical_url: str=None, structure_definition: dict=None, base_model: type=FHIRBaseModel) -&gt; FHIRBaseModel:\n    \"\"\"\n    Constructs a Pydantic model based on the provided FHIR structure definition.\n\n    Args:\n        canonical_url (dict): The FHIR resource's or profile's canonical URL from which to download the StructureDefinition.\n        structure_definition (dict): The FHIR StructureDefinition to build the model from.\n\n    Returns:\n        model (BaseModel): The constructed Pydantic model representing the FHIR resource.\n    \"\"\"\n    # If the model has been constructed before, return the cached model\n    if canonical_url in self.construction_cache:\n        return self.construction_cache[canonical_url]\n    # Download the FHIR structure definition if the canonical URL has been specified        \n    if not structure_definition and canonical_url:\n        structure_definition = self.download_structure_definition(canonical_url)\n    # Check that the snapshot is available in the FHIR structure definition\n    if 'snapshot' not in structure_definition or 'element' not in structure_definition['snapshot']:\n        raise ValueError(\"Invalid StructureDefinition: Missing 'snapshot' or 'element' field\")\n    # Pre-process the snapshort elements into a tree structure to simplify model construction later\n    tree = self.build_tree_structure(structure_definition['snapshot']['element'])\n    resource_type = structure_definition['type']\n    structure = tree['children'][resource_type]\n    # Configure the factory for the current FHIR environment\n    self.Config = self.FactoryConfig(\n        FHIR_release = get_FHIR_release_from_version(structure_definition['fhirVersion']), \n        resource_name = structure_definition['name'], \n    )\n    # Process the FHIR resource's elements &amp; constraints into Pydantic fields &amp; validators\n    fields, validators, properties = self._process_FHIR_structure_into_Pydantic_components(structure)\n    # Process resource-level constraints \n    for constraint in structure['constraint']:\n        validators = self._add_model_constraint_validator(constraint, validators)\n    # If the resource has metadata, prefill the information       \n    if 'meta' in fields:\n        fields['resourceType'] = (\n            Literal[f'{resource_type}'], resource_type\n        )\n        fields['meta'] = (\n            Optional[get_complex_FHIR_type('Meta', self.Config.FHIR_release)], \n            get_complex_FHIR_type('Meta', self.Config.FHIR_release)(\n                profile=[structure_definition['url']], \n                versionId=structure_definition['version']\n            )\n        )\n    # Construct the Pydantic model representing the FHIR resource\n    model = self._create_model_with_properties(self.Config.resource_name, \n        fields=fields, \n        base=base_model, \n        validators=validators, \n        properties=properties\n    )            \n    # Add the current model to the cache\n    self.construction_cache[canonical_url] = model\n    return model \n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/factory/#fhircraft.fhir.resources.factory.ResourceFactory.download_structure_definition","title":"<code>download_structure_definition(profile_url)</code>","text":"<p>Retrieves the structure definition of a FHIR resource from the provided profile URL.</p> <p>Parameters:</p> Name Type Description Default <code>profile_url</code> <code>str</code> <p>The URL of the FHIR profile from which to retrieve the structure definition.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representing the structure definition of the FHIR resource.</p> Source code in <code>fhircraft/fhir/resources/factory.py</code> <pre><code>def download_structure_definition(self, profile_url: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves the structure definition of a FHIR resource from the provided profile URL.\n\n    Parameters:\n        profile_url (str): The URL of the FHIR profile from which to retrieve the structure definition.\n\n    Returns:\n        Dict[str, Any]: A dictionary representing the structure definition of the FHIR resource.\n    \"\"\"       \n\n    if not profile_url.endswith('.json'):\n        # Construct endpoint URL for the StructureDefinition JSON\n        if profile_url.startswith('http://hl7.org/fhir/StructureDefinition'):\n            domain, resource = profile_url.rsplit('/', 1)\n            domain = domain.replace('http://hl7.org/fhir/StructureDefinition','https://hl7.org/fhir/R4/extension')\n            resource = resource.lower()\n        else:\n            domain, resource = profile_url.rsplit('/', 1)\n        json_url = f\"{domain}-{resource}.json\"\n    else:\n        json_url = profile_url\n\n    # Configure proxy if needed\n    settings = load_env_variables()\n    proxies = {\n        'https': settings.get('PROXY_URL_HTTPS'), \n        'http': settings.get('PROXY_URL_HTTP')\n    } if settings.get('PROXY_URL_HTTPS') or settings.get('PROXY_URL_HTTP') else None\n    headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n    }\n    # Download the StructureDefinition JSON            \n    response = requests.get(json_url, proxies=proxies, verify=settings.get('CERTIFICATE_BUNDLE_PATH'), headers=headers)     \n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/generator/","title":"Generator","text":""},{"location":"reference/fhircraft/fhir/resources/generator/#fhircraft.fhir.resources.generator.CodeGenerator","title":"<code>CodeGenerator</code>","text":"Source code in <code>fhircraft/fhir/resources/generator.py</code> <pre><code>class CodeGenerator:\n\n    import_statements: Dict[str, List[str]]\n    data: Dict \n\n    def __init__(self):\n        # Prepare the templating engine environment\n        file_loader = FileSystemLoader('fhircraft/fhir/resources/')\n        env = Environment(loader=file_loader, trim_blocks=True, lstrip_blocks=True)\n        env.filters['escapequotes'] = lambda s: s.replace('\"','\\\\\"')\n        self.template = env.get_template('resource_template.py.j2')\n\n    def _add_import_statement(self, obj: Any) -&gt; None:\n        \"\"\"\n        Adds an import statement for the given object.\n\n        This method inspects the module of the given object and adds an import \n        statement to the `import_statements` dictionary if the module is not \n        already present and the object is not a built-in.\n\n        Args:\n            obj (Any): The object for which to add an import statement.\n\n        Raises:\n            ValueError: If the object does not belong to a module.\n        \"\"\"        \n        # Get the module of the object\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise ValueError(f\"The object {obj} does not belong to a module\")        \n        # Get the name of the module and the object\n        module_name = module.__name__\n        if (object_name := getattr(obj,'__name__', None)) is None:\n            if (object_name := getattr(obj,'_name', None)) is None:\n                return\n        # Generate the import statement\n        if module_name not in [FACTORY_MODULE, 'builtins'] and object_name not in self.import_statements[module_name]:\n            self.import_statements[module_name].append(object_name)\n\n    def _recursively_import_annotation_types(self, annotation: _UnionGenericAlias) -&gt; None:\n        '''\n        Recursively imports annotation types and their modules for serialization or import statements.\n\n        Args:\n            annotation (_UnionGenericAlias): The annotation type to process.\n\n        Raises:\n            ValueError: If the object does not belong to a module.\n        '''        \n        # Get the type object \n        if hasattr(annotation, 'annotation'):\n            type_obj = annotation.annotation\n        else:\n            type_obj = annotation\n        # Ignore NoneType and strings\n        if type_obj is not None and not isinstance(type_obj, str):\n            if inspect.getmodule(type_obj).__name__ == FACTORY_MODULE and issubclass(type_obj, BaseModel):     \n                # If object was created by ResourceFactory, then serialize the model \n                self._serialize_model(type_obj)\n            else:\n                # Otherwise, import the model's module\n                self._add_import_statement(type_obj)\n        # Repeat for any nested annotations\n        for nested_annotation in get_args(annotation): \n            self._recursively_import_annotation_types(nested_annotation)\n\n    def _serialize_model(self, model: BaseModel) -&gt; None:\n        '''\n        Serialize the model by extracting information about its fields and properties.\n\n        Args:\n            model (BaseModel): The model to be serialized.\n        '''         \n        model_base = model.__base__ \n        # Add import statement for the base class the the model inherits\n        if model_base and model_base != BaseModel:\n            self._add_import_statement(model.__base__)\n\n        subdata = {}\n        for field, info in model.model_fields.items():\n            if model.__base__ and field in model.__base__.model_fields and all([getattr(info, slot) == getattr(model.__base__.model_fields[field], slot) for slot in info.__slots__ if not slot.startswith('_')]):\n                continue\n            self._recursively_import_annotation_types(info.annotation)\n            annotation_string = repr(info.annotation)\n\n            if isinstance(info.annotation, type(Enum)):\n                if 'Literal' not in self.import_statements['typing']:\n                    self.import_statements['typing'].append('Literal')\n                annotation_string = f\"Literal['{info.annotation['fixedValue'].value}']\"\n\n            subdata[field] = {\n                'annotation': annotation_string,\n                'description': info.description, \n                'alias': info.alias, \n                'default': info.default,\n            }\n        model_properties = {\n            key: value.fget\n            for key, value in model.__dict__.items()\n            if isinstance(value, property)\n        }\n        self.data.update({model: {'fields': subdata, 'properties': model_properties}})\n\n    def generate_resource_model_code(self, resources: Union[BaseModel, List[BaseModel]]) -&gt; str:\n        '''\n        Generate the source code for resource model(s) based on the input resources.\n\n        Args:\n            resources (Union[BaseModel, List[BaseModel]]): The resource(s) to generate the model code for.\n\n        Returns:\n            str: The generated source code for the resource model(s).\n        '''         \n        # Reset the internal state of the generator\n        self.import_statements = defaultdict(list)\n        self.data = {}\n        # Serialize the model information of the input resources\n        for resource in ensure_list(resources):\n            self._serialize_model(resource)\n        # Render the source code using Jinja2\n        source_code = self.template.render(\n            data=self.data, \n            imports=self.import_statements, \n        )\n        # Replace the full module specification for any modules imported\n        for module, objects in self.import_statements.items():\n            module = module.replace('.',r'\\.')\n            for regex in [fr\"(\\&lt;class \\'{module}\\.(\\w*)\\'\\&gt;)\", r\"(\\&lt;class \\'(\\w*)\\'\\&gt;)\"]:\n                for match in re.finditer(regex, source_code):\n                    source_code = source_code.replace(match.group(1), match.group(2))\n            for match in re.finditer(fr\"({module}\\.)({'|'.join(objects)})\", source_code):\n                source_code = source_code.replace(match.group(1), '')\n            source_code = source_code.replace(f'{FACTORY_MODULE}.', '')\n        source_code = source_code.replace(LEFT_TO_RIGHT_COMPLEX, LEFT_TO_RIGHT_SIMPLE)\n\n        return source_code\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/generator/#fhircraft.fhir.resources.generator.CodeGenerator.generate_resource_model_code","title":"<code>generate_resource_model_code(resources)</code>","text":"<p>Generate the source code for resource model(s) based on the input resources.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>Union[BaseModel, List[BaseModel]]</code> <p>The resource(s) to generate the model code for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated source code for the resource model(s).</p> Source code in <code>fhircraft/fhir/resources/generator.py</code> <pre><code>def generate_resource_model_code(self, resources: Union[BaseModel, List[BaseModel]]) -&gt; str:\n    '''\n    Generate the source code for resource model(s) based on the input resources.\n\n    Args:\n        resources (Union[BaseModel, List[BaseModel]]): The resource(s) to generate the model code for.\n\n    Returns:\n        str: The generated source code for the resource model(s).\n    '''         \n    # Reset the internal state of the generator\n    self.import_statements = defaultdict(list)\n    self.data = {}\n    # Serialize the model information of the input resources\n    for resource in ensure_list(resources):\n        self._serialize_model(resource)\n    # Render the source code using Jinja2\n    source_code = self.template.render(\n        data=self.data, \n        imports=self.import_statements, \n    )\n    # Replace the full module specification for any modules imported\n    for module, objects in self.import_statements.items():\n        module = module.replace('.',r'\\.')\n        for regex in [fr\"(\\&lt;class \\'{module}\\.(\\w*)\\'\\&gt;)\", r\"(\\&lt;class \\'(\\w*)\\'\\&gt;)\"]:\n            for match in re.finditer(regex, source_code):\n                source_code = source_code.replace(match.group(1), match.group(2))\n        for match in re.finditer(fr\"({module}\\.)({'|'.join(objects)})\", source_code):\n            source_code = source_code.replace(match.group(1), '')\n        source_code = source_code.replace(f'{FACTORY_MODULE}.', '')\n    source_code = source_code.replace(LEFT_TO_RIGHT_COMPLEX, LEFT_TO_RIGHT_SIMPLE)\n\n    return source_code\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/","title":"Validators","text":""},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.get_type_choice_value_by_base","title":"<code>get_type_choice_value_by_base(instance, base)</code>","text":"<p>Retrieve the value of a type-choice field in an instance based on the field  name starting with a specific base string.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>The instance object to retrieve the value from.</p> required <code>base</code> <code>str</code> <p>The base string that the field name should start with.</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>Any</code> <p>The value of the first field found in the instance that starts with the specified base string,         or <code>None</code> if no such field exists or the value is <code>None</code>.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def get_type_choice_value_by_base(instance:object, base:str) -&gt; Any:\n    '''\n    Retrieve the value of a type-choice field in an instance based on the field \n    name starting with a specific base string.\n\n    Args:\n        instance (object): The instance object to retrieve the value from.\n        base (str): The base string that the field name should start with.\n\n    Returns:\n        value (Any): The value of the first field found in the instance that starts with the specified base string,\n                    or `None` if no such field exists or the value is `None`.\n    '''\n    for field in instance.model_fields:\n        if field.startswith(base):\n            value = getattr(instance, field)\n            if value is not None:\n                return value\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.validate_FHIR_element_pattern","title":"<code>validate_FHIR_element_pattern(cls, element, pattern)</code>","text":"<p>Validate the FHIR element against a specified pattern and return the element if it fulfills the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>Placeholder for an argument that is not used in the function.</p> required <code>element</code> <code>Union[FHIRBaseModel, List[FHIRBaseModel]]</code> <p>The FHIR element to validate against the pattern.</p> required <code>pattern</code> <code>Union[FHIRBaseModel, List[FHIRBaseModel]]</code> <p>The pattern to validate the element against.</p> required <p>Returns:</p> Type Description <code>Union[FHIRBaseModel, List[FHIRBaseModel]]</code> <p>Union[FHIRBaseModel, List[FHIRBaseModel]]: The validated FHIR element.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the element does not fulfill the specified pattern.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def validate_FHIR_element_pattern(cls:Any, element:Union[FHIRBaseModel,List[FHIRBaseModel]], pattern:Union[FHIRBaseModel,List[FHIRBaseModel]]) -&gt; Union[FHIRBaseModel, List[FHIRBaseModel]]:\n    '''\n    Validate the FHIR element against a specified pattern and return the element if it fulfills the pattern.\n\n    Args:\n        cls (Any): Placeholder for an argument that is not used in the function.\n        element (Union[FHIRBaseModel, List[FHIRBaseModel]]): The FHIR element to validate against the pattern.\n        pattern (Union[FHIRBaseModel, List[FHIRBaseModel]]): The pattern to validate the element against.\n\n    Returns:\n        Union[FHIRBaseModel, List[FHIRBaseModel]]: The validated FHIR element.\n\n    Raises:\n        AssertionError: If the element does not fulfill the specified pattern.\n    '''\n    if isinstance(pattern, list): pattern = pattern[0]\n    _element = element[0] if isinstance(element, list) else element\n    assert merge_dicts(_element.model_dump(), pattern.model_dump()) == _element.model_dump(), \\\n            f'Value does not fulfill pattern:\\n{pattern.model_dump_json(indent=2)}'\n    return element\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.validate_element_constraint","title":"<code>validate_element_constraint(cls, value, expression, human, key, severity)</code>","text":"<p>Validates a FHIR element constraint based on a FHIRPath expression.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>Placeholder for an argument that is not used in the function.</p> required <code>value</code> <code>Any</code> <p>The value to be validated.</p> required <code>expression</code> <code>str</code> <p>The FHIRPath expression to evaluate.</p> required <code>human</code> <code>str</code> <p>A human-readable description of the constraint.</p> required <code>key</code> <code>str</code> <p>The key associated with the constraint.</p> required <code>severity</code> <code>str</code> <p>The severity level of the constraint ('warning' or 'error').</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The validated value.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the validation fails and severity is not <code>warning</code>.</p> <code>Warning</code> <p>If the validation fails and severity is <code>warning</code>.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def validate_element_constraint(cls, value:Any, expression:str, human:str, key:str, severity:str) -&gt; Any:\n    \"\"\"\n    Validates a FHIR element constraint based on a FHIRPath expression.\n\n    Args:\n        cls (Any): Placeholder for an argument that is not used in the function.\n        value (Any): The value to be validated.\n        expression (str): The FHIRPath expression to evaluate.\n        human (str): A human-readable description of the constraint.\n        key (str): The key associated with the constraint.\n        severity (str): The severity level of the constraint ('warning' or 'error').\n\n    Returns:\n        Any: The validated value.\n\n    Raises:\n        AssertionError: If the validation fails and severity is not `warning`.\n        Warning: If the validation fails and severity is `warning`.\n    \"\"\"    \n    return _validate_FHIR_element_constraint(value, expression, human, key, severity)\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.validate_model_constraint","title":"<code>validate_model_constraint(instance, expression, human, key, severity)</code>","text":"<p>Validates a FHIR model constraint based on a FHIRPath expression.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>Instance of the model to be validated.</p> required <code>expression</code> <code>str</code> <p>The FHIRPath expression to evaluate.</p> required <code>human</code> <code>str</code> <p>A human-readable description of the constraint.</p> required <code>key</code> <code>str</code> <p>The key associated with the constraint.</p> required <code>severity</code> <code>str</code> <p>The severity level of the constraint ('warning' or 'error').</p> required <p>Returns:</p> Name Type Description <code>instance</code> <code>object</code> <p>The validated model instance.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the validation fails and severity is not <code>warning</code>.</p> <code>Warning</code> <p>If the validation fails and severity is <code>warning</code>.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def validate_model_constraint(instance:object, expression:str, human:str, key:str, severity:str) -&gt; object:\n    \"\"\"\n    Validates a FHIR model constraint based on a FHIRPath expression.\n\n    Args:\n        instance (object): Instance of the model to be validated.\n        expression (str): The FHIRPath expression to evaluate.\n        human (str): A human-readable description of the constraint.\n        key (str): The key associated with the constraint.\n        severity (str): The severity level of the constraint ('warning' or 'error').\n\n    Returns:\n        instance (object): The validated model instance.\n\n    Raises:\n        AssertionError: If the validation fails and severity is not `warning`.\n        Warning: If the validation fails and severity is `warning`.\n    \"\"\"       \n    return _validate_FHIR_element_constraint(instance, expression, human, key, severity)\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.validate_slicing_cardinalities","title":"<code>validate_slicing_cardinalities(cls, values, field_name)</code>","text":"<p>Validates the cardinalities of FHIR slices for a specific field within a FHIR resource.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>The Pydantic FHIR model class.</p> required <code>values</code> <code>List[Any]</code> <p>List of values for the field.</p> required <code>field_name</code> <code>str</code> <p>The name of the field to validate.</p> required <p>Returns:</p> Type Description <code>List[FHIRSliceModel]</code> <p>List[FHIRSliceModel]: The validated list of values.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If cardinality constraints are violated for any slice.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def validate_slicing_cardinalities(cls:Any, values:List[Any], field_name:str) -&gt; List[FHIRSliceModel]:\n    \"\"\"\n    Validates the cardinalities of FHIR slices for a specific field within a FHIR resource.\n\n    Args:\n        cls (Any): The Pydantic FHIR model class.\n        values (List[Any]): List of values for the field.\n        field_name (str): The name of the field to validate.\n\n    Returns:\n        List[FHIRSliceModel]: The validated list of values.\n\n    Raises:\n        AssertionError: If cardinality constraints are violated for any slice.\n    \"\"\"    \n    slices =  get_all_models_from_field(cls.model_fields[field_name], issubclass_of=FHIRSliceModel)\n    for slice in slices:\n        slice_instances_count = sum([isinstance(value, slice) for value in values])\n        assert slice_instances_count &gt;= slice.min_cardinality, \\\n            f\"Slice '{slice.__name__}' for field '{field_name}' violates its min. cardinality. \\\n                Requires min. cardinality of {slice.min_cardinality}, but got {slice_instances_count}\"\n        assert slice_instances_count &lt;= slice.max_cardinality, \\\n            f\"Slice '{slice.__name__}' for field '{field_name}' violates its max. cardinality. \\\n                Requires max. cardinality of {slice.max_cardinality}, but got {slice_instances_count}\"\n    return values\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/validators/#fhircraft.fhir.resources.validators.validate_type_choice_element","title":"<code>validate_type_choice_element(instance, field_types, field_name_base)</code>","text":"<p>Validate the type choice element for a given instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>The instance to validate.</p> required <code>field_types</code> <code>List[str]</code> <p>List of field types to check.</p> required <code>field_name_base</code> <code>str</code> <p>Base name of the field.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The validated instance.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If more than one value is set for the type choice element.</p> Source code in <code>fhircraft/fhir/resources/validators.py</code> <pre><code>def validate_type_choice_element(instance: object, field_types: List[str], field_name_base: str) -&gt; object:\n    \"\"\"\n    Validate the type choice element for a given instance.\n\n    Args:\n        instance (object): The instance to validate.\n        field_types (List[str]): List of field types to check.\n        field_name_base (str): Base name of the field.\n\n    Returns:\n        object: The validated instance.\n\n    Raises:\n        AssertionError: If more than one value is set for the type choice element.\n    \"\"\"\n    assert sum(\n        getattr(instance, field_name_base + field_type if isinstance(field_type, str) else field_type.__name__, None) is not None \n            for field_type in field_types \n    ) &lt;= 1, f'Type choice element {field_name_base}[x] can only have one value set.'\n    return instance\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/primitives/","title":"Primitives","text":""},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/","title":"Complex types","text":""},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>Element</code></p> <p>An address expressed using postal conventions (as opposed to GPS or other location definition formats)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Address(Element):\n    \"\"\"\n    An address expressed using postal conventions (as opposed to GPS or other location definition formats)\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | billing - purpose of this address\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional[Code] = Field(\n        description=\"postal | physical | both\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the address\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    line: typing.Optional[typing.List[String]] = Field(\n        description=\"Street name, number, direction \\u0026 P.O. Box etc.\",\n        default=None,\n    )\n    line_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for line extensions\",\n        default=None,\n        alias=\"_line\",\n    )\n    city: typing.Optional[String] = Field(\n        description=\"Name of city, town etc.\",\n        default=None,\n    )\n    city_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for city extensions\",\n        default=None,\n        alias=\"_city\",\n    )\n    district: typing.Optional[String] = Field(\n        description=\"District name (aka county)\",\n        default=None,\n    )\n    district_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for district extensions\",\n        default=None,\n        alias=\"_district\",\n    )\n    state: typing.Optional[String] = Field(\n        description=\"Sub-unit of country (abbreviations ok)\",\n        default=None,\n    )\n    state_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for state extensions\",\n        default=None,\n        alias=\"_state\",\n    )\n    postalCode: typing.Optional[String] = Field(\n        description=\"Postal code for area\",\n        default=None,\n    )\n    postalCode_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for postalCode extensions\",\n        default=None,\n        alias=\"_postalCode\",\n    )\n    country: typing.Optional[String] = Field(\n        description=\"Country (e.g. can be ISO 3166 2 or 3 letter code)\",\n        default=None,\n    )\n    country_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for country extensions\",\n        default=None,\n        alias=\"_country\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when address was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'country', 'postalCode', 'state', 'district', 'city', 'line', 'text', 'type', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Age","title":"<code>Age</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>A duration of time during which an organism (or a process) has existed</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Age(FHIRBaseModel):\n    \"\"\"\n    A duration of time during which an organism (or a process) has existed\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_age_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (value.empty() or value.hasValue().not() or value &gt; 0)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.  If value is present, it SHALL be positive.\",\n            key=\"age-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Annotation","title":"<code>Annotation</code>","text":"<p>               Bases: <code>Element</code></p> <p>Text node with attribution</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Annotation(Element):\n    \"\"\"\n    Text node with attribution\n    \"\"\"\n    authorReference: typing.Optional['Reference'] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    authorString: typing.Optional[String] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    time: typing.Optional[DateTime] = Field(\n        description=\"When the annotation was made\",\n        default=None,\n    )\n    time_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for time extensions\",\n        default=None,\n        alias=\"_time\",\n    )\n    text: Markdown = Field(\n        description=\"The annotation  - text content (as markdown)\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'time', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def author_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Reference', String],\n            field_name_base=\"author\",\n        )\n\n    @property \n    def author(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"author\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>Element</code></p> <p>Content in a format defined elsewhere</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Attachment(Element):\n    \"\"\"\n    Content in a format defined elsewhere\n    \"\"\"\n    contentType: typing.Optional[Code] = Field(\n        description=\"Mime type of the content, with charset etc.\",\n        default=None,\n    )\n    contentType_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentType extensions\",\n        default=None,\n        alias=\"_contentType\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Human language of the content (BCP-47)\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"Data inline, base64ed\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    url: typing.Optional[Url] = Field(\n        description=\"Uri where the data can be found\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    size: typing.Optional[UnsignedInt] = Field(\n        description=\"Number of bytes of content (if url provided)\",\n        default=None,\n    )\n    size_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for size extensions\",\n        default=None,\n        alias=\"_size\",\n    )\n    hash: typing.Optional[Base64Binary] = Field(\n        description=\"Hash of the data (sha-1, base64ed)\",\n        default=None,\n    )\n    hash_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for hash extensions\",\n        default=None,\n        alias=\"_hash\",\n    )\n    title: typing.Optional[String] = Field(\n        description=\"Label to display in place of the data\",\n        default=None,\n    )\n    title_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for title extensions\",\n        default=None,\n        alias=\"_title\",\n    )\n    creation: typing.Optional[DateTime] = Field(\n        description=\"Date attachment was first created\",\n        default=None,\n    )\n    creation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for creation extensions\",\n        default=None,\n        alias=\"_creation\",\n    )\n    @field_validator(*('creation', 'title', 'hash', 'size', 'url', 'data', 'language', 'contentType', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_att_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or contentType.exists()\",\n            human=\"If the Attachment has data, it SHALL have a contentType\",\n            key=\"att-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.BackboneElement","title":"<code>BackboneElement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Base for elements defined inside a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class BackboneElement(Element):\n    \"\"\"\n    Base for elements defined inside a resource\n    \"\"\"\n    modifierExtension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Extensions that cannot be ignored even if unrecognized\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.CodeableConcept","title":"<code>CodeableConcept</code>","text":"<p>               Bases: <code>Element</code></p> <p>Concept - reference to a terminology or just  text</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class CodeableConcept(Element):\n    \"\"\"\n    Concept - reference to a terminology or just  text\n    \"\"\"\n    coding: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Code defined by a terminology system\",\n        default=None,\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Plain text representation of the concept\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'coding', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Coding","title":"<code>Coding</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference to a code defined by a terminology system</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Coding(Element):\n    \"\"\"\n    A reference to a code defined by a terminology system\n    \"\"\"\n    system: typing.Optional[Uri] = Field(\n        description=\"Identity of the terminology system\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    version: typing.Optional[String] = Field(\n        description=\"Version of the system - if relevant\",\n        default=None,\n    )\n    version_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for version extensions\",\n        default=None,\n        alias=\"_version\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Symbol in syntax defined by the system\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Representation defined by the system\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    userSelected: typing.Optional[Boolean] = Field(\n        description=\"If this coding was chosen directly by the user\",\n        default=None,\n    )\n    userSelected_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for userSelected extensions\",\n        default=None,\n        alias=\"_userSelected\",\n    )\n    @field_validator(*('userSelected', 'display', 'code', 'version', 'system', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ContactDetail","title":"<code>ContactDetail</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contact information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ContactDetail(Element):\n    \"\"\"\n    Contact information\n    \"\"\"\n    name: typing.Optional[String] = Field(\n        description=\"Name of an individual to contact\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    telecom: typing.Optional[typing.List['ContactPoint']] = Field(\n        description=\"Contact details for individual or organization\",\n        default=None,\n    )\n    @field_validator(*('telecom', 'name', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ContactPoint","title":"<code>ContactPoint</code>","text":"<p>               Bases: <code>Element</code></p> <p>Details of a Technology mediated contact point (phone, fax, email, etc.)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ContactPoint(Element):\n    \"\"\"\n    Details of a Technology mediated contact point (phone, fax, email, etc.)\n    \"\"\"\n    system: typing.Optional[Code] = Field(\n        description=\"phone | fax | email | pager | url | sms | other\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The actual contact point details\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | mobile - purpose of this contact point\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    rank: typing.Optional[PositiveInt] = Field(\n        description=\"Specify preferred order of use (1 = highest)\",\n        default=None,\n    )\n    rank_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for rank extensions\",\n        default=None,\n        alias=\"_rank\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when the contact point was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'rank', 'use', 'value', 'system', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cpt_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"value.empty() or system.exists()\",\n            human=\"A system is required if a value is provided.\",\n            key=\"cpt-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Contributor","title":"<code>Contributor</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contributor information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Contributor(Element):\n    \"\"\"\n    Contributor information\n    \"\"\"\n    type: Code = Field(\n        description=\"author | editor | reviewer | endorser\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: String = Field(\n        description=\"Who contributed the content\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    contact: typing.Optional[typing.List['ContactDetail']] = Field(\n        description=\"Contact details of the contributor\",\n        default=None,\n    )\n    @field_validator(*('contact', 'name', 'type', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Count","title":"<code>Count</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Count(FHIRBaseModel):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cnt_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (code.empty() or code = '1') and (value.empty() or value.hasValue().not() or value.toString().contains('.').not())\",\n            human=\"There SHALL be a code with a value of \\\"1\\\" if there is a value. If system is present, it SHALL be UCUM.  If present, the value SHALL be a whole number.\",\n            key=\"cnt-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.DataRequirement","title":"<code>DataRequirement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Describes a required data item</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class DataRequirement(Element):\n    \"\"\"\n    Describes a required data item\n    \"\"\"\n    type: Code = Field(\n        description=\"The type of the required data\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"The profile of the required data\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    subjectCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    subjectReference: typing.Optional['Reference'] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    mustSupport: typing.Optional[typing.List[String]] = Field(\n        description=\"Indicates specific structure elements that are referenced by the knowledge module\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    codeFilter: typing.Optional[typing.List['Element']] = Field(\n        description=\"What codes are expected\",\n        default=None,\n    )\n    dateFilter: typing.Optional[typing.List['Element']] = Field(\n        description=\"What dates/date ranges are expected\",\n        default=None,\n    )\n    limit: typing.Optional[PositiveInt] = Field(\n        description=\"Number of results\",\n        default=None,\n    )\n    limit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for limit extensions\",\n        default=None,\n        alias=\"_limit\",\n    )\n    sort: typing.Optional[typing.List['Element']] = Field(\n        description=\"Order of the results\",\n        default=None,\n    )\n    @field_validator(*('sort', 'limit', 'dateFilter', 'codeFilter', 'mustSupport', 'profile', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('codeFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('dateFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def subject_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['CodeableConcept', 'Reference'],\n            field_name_base=\"subject\",\n        )\n\n    @property \n    def subject(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"subject\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>A length - a value with a unit that is a physical distance</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Distance(FHIRBaseModel):\n    \"\"\"\n    A length - a value with a unit that is a physical distance\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dis_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of length.  If system is present, it SHALL be UCUM.\",\n            key=\"dis-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.DomainResource","title":"<code>DomainResource</code>","text":"<p>               Bases: <code>Resource</code></p> <p>A resource with narrative, extensions, and contained resources</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class DomainResource(Resource):\n    \"\"\"\n    A resource with narrative, extensions, and contained resources\n    \"\"\"\n    text: typing.Optional['Narrative'] = Field(\n        description=\"Text summary of the resource, for human interpretation\",\n        default=None,\n    )\n    contained: typing.Optional[typing.List['Resource']] = Field(\n        description=\"Contained, inline Resources\",\n        default=None,\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    modifierExtension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Extensions that cannot be ignored\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.contained.empty()\",\n            human=\"If the resource is contained in another resource, it SHALL NOT contain nested Resources\",\n            key=\"dom-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(canonical) = '#').exists()).not()).trace('unmatched', id).empty()\",\n            human=\"If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource\",\n            key=\"dom-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_4_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated\",\n            key=\"dom-4\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.security.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a security label\",\n            key=\"dom-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"text.`div`.exists()\",\n            human=\"A resource should have narrative for robust management\",\n            key=\"dom-6\",\n            severity=\"warning\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Dosage","title":"<code>Dosage</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>How the medication is/was taken or should be taken</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Dosage(BackboneElement):\n    \"\"\"\n    How the medication is/was taken or should be taken\n    \"\"\"\n    sequence: typing.Optional[Integer] = Field(\n        description=\"The order of the dosage instructions\",\n        default=None,\n    )\n    sequence_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sequence extensions\",\n        default=None,\n        alias=\"_sequence\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Free text dosage instructions e.g. SIG\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    additionalInstruction: typing.Optional[typing.List['CodeableConcept']] = Field(\n        description=\"Supplemental instruction or warnings to the patient - e.g. \\\"with meals\\\", \\\"may cause drowsiness\\\"\",\n        default=None,\n    )\n    patientInstruction: typing.Optional[String] = Field(\n        description=\"Patient or consumer oriented instructions\",\n        default=None,\n    )\n    patientInstruction_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for patientInstruction extensions\",\n        default=None,\n        alias=\"_patientInstruction\",\n    )\n    timing: typing.Optional['Timing'] = Field(\n        description=\"When medication should be administered\",\n        default=None,\n    )\n    asNeededBoolean: typing.Optional[Boolean] = Field(\n        description=\"Take \\\"as needed\\\" (for x)\",\n        default=None,\n    )\n    asNeededCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Take \\\"as needed\\\" (for x)\",\n        default=None,\n    )\n    site: typing.Optional['CodeableConcept'] = Field(\n        description=\"Body site to administer to\",\n        default=None,\n    )\n    route: typing.Optional['CodeableConcept'] = Field(\n        description=\"How drug should enter body\",\n        default=None,\n    )\n    method: typing.Optional['CodeableConcept'] = Field(\n        description=\"Technique for administering medication\",\n        default=None,\n    )\n    doseAndRate: typing.Optional[typing.List['Element']] = Field(\n        description=\"Amount of medication administered\",\n        default=None,\n    )\n    maxDosePerPeriod: typing.Optional['Ratio'] = Field(\n        description=\"Upper limit on medication per unit of time\",\n        default=None,\n    )\n    maxDosePerAdministration: typing.Optional['Quantity'] = Field(\n        description=\"Upper limit on medication per administration\",\n        default=None,\n    )\n    maxDosePerLifetime: typing.Optional['Quantity'] = Field(\n        description=\"Upper limit on medication per lifetime of the patient\",\n        default=None,\n    )\n    @field_validator(*('maxDosePerLifetime', 'maxDosePerAdministration', 'maxDosePerPeriod', 'doseAndRate', 'method', 'route', 'site', 'timing', 'patientInstruction', 'additionalInstruction', 'text', 'sequence', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def asNeeded_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Boolean, 'CodeableConcept'],\n            field_name_base=\"asNeeded\",\n        )\n\n    @property \n    def asNeeded(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"asNeeded\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>A length of time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Duration(FHIRBaseModel):\n    \"\"\"\n    A length of time\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_drt_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.exists() implies ((system = %ucum) and value.exists())\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.\",\n            key=\"drt-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base for all elements</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Element(FHIRBaseModel):\n    \"\"\"\n    Base for all elements\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ElementDefinition","title":"<code>ElementDefinition</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>Definition of an element in a resource or extension</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ElementDefinition(BackboneElement):\n    \"\"\"\n    Definition of an element in a resource or extension\n    \"\"\"\n    path: String = Field(\n        description=\"Path of the element in the hierarchy of elements\",\n        default=None,\n    )\n    path_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for path extensions\",\n        default=None,\n        alias=\"_path\",\n    )\n    representation: typing.Optional[typing.List[Code]] = Field(\n        description=\"xmlAttr | xmlText | typeAttr | cdaText | xhtml\",\n        default=None,\n    )\n    representation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for representation extensions\",\n        default=None,\n        alias=\"_representation\",\n    )\n    sliceName: typing.Optional[String] = Field(\n        description=\"Name for this particular element (in a set of slices)\",\n        default=None,\n    )\n    sliceName_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceName extensions\",\n        default=None,\n        alias=\"_sliceName\",\n    )\n    sliceIsConstraining: typing.Optional[Boolean] = Field(\n        description=\"If this slice definition constrains an inherited slice definition (or not)\",\n        default=None,\n    )\n    sliceIsConstraining_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceIsConstraining extensions\",\n        default=None,\n        alias=\"_sliceIsConstraining\",\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Name for element to display with or prompt for element\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    code: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Corresponding codes in terminologies\",\n        default=None,\n    )\n    slicing: typing.Optional['Element'] = Field(\n        description=\"This element is sliced - slices follow\",\n        default=None,\n    )\n    short: typing.Optional[String] = Field(\n        description=\"Concise definition for space-constrained presentation\",\n        default=None,\n    )\n    short_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for short extensions\",\n        default=None,\n        alias=\"_short\",\n    )\n    definition: typing.Optional[Markdown] = Field(\n        description=\"Full formal definition as narrative text\",\n        default=None,\n    )\n    definition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for definition extensions\",\n        default=None,\n        alias=\"_definition\",\n    )\n    comment: typing.Optional[Markdown] = Field(\n        description=\"Comments about the use of this element\",\n        default=None,\n    )\n    comment_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comment extensions\",\n        default=None,\n        alias=\"_comment\",\n    )\n    requirements: typing.Optional[Markdown] = Field(\n        description=\"Why this resource has been created\",\n        default=None,\n    )\n    requirements_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for requirements extensions\",\n        default=None,\n        alias=\"_requirements\",\n    )\n    alias: typing.Optional[typing.List[String]] = Field(\n        description=\"Other names\",\n        default=None,\n    )\n    alias_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for alias extensions\",\n        default=None,\n        alias=\"_alias\",\n    )\n    min: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum Cardinality (a number or *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    base: typing.Optional['Element'] = Field(\n        description=\"Base definition information for tools\",\n        default=None,\n    )\n    contentReference: typing.Optional[Uri] = Field(\n        description=\"Reference to definition of content for the element\",\n        default=None,\n    )\n    contentReference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentReference extensions\",\n        default=None,\n        alias=\"_contentReference\",\n    )\n    type: typing.Optional[typing.List['Element']] = Field(\n        description=\"Data type and Profile for this element\",\n        default=None,\n    )\n    defaultValueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCode: typing.Optional[Code] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDate: typing.Optional[Date] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueId: typing.Optional[Id] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInstant: typing.Optional[Instant] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInteger: typing.Optional[Integer] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueOid: typing.Optional[Oid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueString: typing.Optional[String] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTime: typing.Optional[Time] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUri: typing.Optional[Uri] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUrl: typing.Optional[Url] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUuid: typing.Optional[Uuid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAddress: typing.Optional['Address'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAge: typing.Optional['Age'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCoding: typing.Optional['Coding'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCount: typing.Optional['Count'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDistance: typing.Optional['Distance'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDuration: typing.Optional['Duration'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMoney: typing.Optional['Money'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePeriod: typing.Optional['Period'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRange: typing.Optional['Range'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRatio: typing.Optional['Ratio'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueReference: typing.Optional['Reference'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSignature: typing.Optional['Signature'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTiming: typing.Optional['Timing'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContributor: typing.Optional['Contributor'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueExpression: typing.Optional['Expression'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDosage: typing.Optional['Dosage'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMeta: typing.Optional['Meta'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    meaningWhenMissing: typing.Optional[Markdown] = Field(\n        description=\"Implicit meaning when this element is missing\",\n        default=None,\n    )\n    meaningWhenMissing_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for meaningWhenMissing extensions\",\n        default=None,\n        alias=\"_meaningWhenMissing\",\n    )\n    orderMeaning: typing.Optional[String] = Field(\n        description=\"What the order of the elements means\",\n        default=None,\n    )\n    orderMeaning_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for orderMeaning extensions\",\n        default=None,\n        alias=\"_orderMeaning\",\n    )\n    fixedBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCode: typing.Optional[Code] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDate: typing.Optional[Date] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedId: typing.Optional[Id] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInstant: typing.Optional[Instant] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInteger: typing.Optional[Integer] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedOid: typing.Optional[Oid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedString: typing.Optional[String] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTime: typing.Optional[Time] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUri: typing.Optional[Uri] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUrl: typing.Optional[Url] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAddress: typing.Optional['Address'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAge: typing.Optional['Age'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCoding: typing.Optional['Coding'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCount: typing.Optional['Count'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDistance: typing.Optional['Distance'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDuration: typing.Optional['Duration'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMoney: typing.Optional['Money'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPeriod: typing.Optional['Period'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRange: typing.Optional['Range'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedReference: typing.Optional['Reference'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSignature: typing.Optional['Signature'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTiming: typing.Optional['Timing'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedExpression: typing.Optional['Expression'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMeta: typing.Optional['Meta'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    patternBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCode: typing.Optional[Code] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDate: typing.Optional[Date] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternId: typing.Optional[Id] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInstant: typing.Optional[Instant] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInteger: typing.Optional[Integer] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternOid: typing.Optional[Oid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternString: typing.Optional[String] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTime: typing.Optional[Time] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUri: typing.Optional[Uri] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUrl: typing.Optional[Url] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAddress: typing.Optional['Address'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAge: typing.Optional['Age'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCoding: typing.Optional['Coding'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCount: typing.Optional['Count'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDistance: typing.Optional['Distance'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDuration: typing.Optional['Duration'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMoney: typing.Optional['Money'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPeriod: typing.Optional['Period'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRange: typing.Optional['Range'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternReference: typing.Optional['Reference'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSignature: typing.Optional['Signature'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTiming: typing.Optional['Timing'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternExpression: typing.Optional['Expression'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMeta: typing.Optional['Meta'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    example: typing.Optional[typing.List['Element']] = Field(\n        description=\"Example value (as defined for type)\",\n        default=None,\n    )\n    minValueDate: typing.Optional[Date] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInstant: typing.Optional[Instant] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueTime: typing.Optional[Time] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInteger: typing.Optional[Integer] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDate: typing.Optional[Date] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInstant: typing.Optional[Instant] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueTime: typing.Optional[Time] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInteger: typing.Optional[Integer] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxLength: typing.Optional[Integer] = Field(\n        description=\"Max length for strings\",\n        default=None,\n    )\n    maxLength_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for maxLength extensions\",\n        default=None,\n        alias=\"_maxLength\",\n    )\n    condition: typing.Optional[typing.List[Id]] = Field(\n        description=\"Reference to invariant about presence\",\n        default=None,\n    )\n    condition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for condition extensions\",\n        default=None,\n        alias=\"_condition\",\n    )\n    constraint: typing.Optional[typing.List['Element']] = Field(\n        description=\"Condition that must evaluate to true\",\n        default=None,\n    )\n    mustSupport: typing.Optional[Boolean] = Field(\n        description=\"If the element must be supported\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    isModifier: typing.Optional[Boolean] = Field(\n        description=\"If this modifies the meaning of other elements\",\n        default=None,\n    )\n    isModifier_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifier extensions\",\n        default=None,\n        alias=\"_isModifier\",\n    )\n    isModifierReason: typing.Optional[String] = Field(\n        description=\"Reason that this element is marked as a modifier\",\n        default=None,\n    )\n    isModifierReason_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifierReason extensions\",\n        default=None,\n        alias=\"_isModifierReason\",\n    )\n    isSummary: typing.Optional[Boolean] = Field(\n        description=\"Include when _summary = true?\",\n        default=None,\n    )\n    isSummary_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isSummary extensions\",\n        default=None,\n        alias=\"_isSummary\",\n    )\n    binding: typing.Optional['Element'] = Field(\n        description=\"ValueSet details if this is coded\",\n        default=None,\n    )\n    mapping: typing.Optional[typing.List['Element']] = Field(\n        description=\"Map element to another set of definitions\",\n        default=None,\n    )\n    @field_validator(*('mapping', 'binding', 'isSummary', 'isModifierReason', 'isModifier', 'mustSupport', 'constraint', 'condition', 'maxLength', 'example', 'orderMeaning', 'meaningWhenMissing', 'type', 'contentReference', 'base', 'max', 'min', 'alias', 'requirements', 'comment', 'definition', 'short', 'slicing', 'code', 'label', 'sliceIsConstraining', 'sliceName', 'representation', 'path', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('slicing',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"discriminator.exists() or description.exists()\",\n            human=\"If there are no discriminators, there must be a definition\",\n            key=\"eld-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('max',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_3_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"empty() or ($this = '*') or (toInteger() &gt;= 0)\",\n            human=\"Max SHALL be a number or \\\"*\\\"\",\n            key=\"eld-3\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"aggregation.empty() or (code = 'Reference') or (code = 'canonical')\",\n            human=\"Aggregation may only be specified if one of the allowed types for the element is a reference\",\n            key=\"eld-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_17_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"(code='Reference' or code = 'canonical') or targetProfile.empty()\",\n            human=\"targetProfile is only allowed if the type is Reference or canonical\",\n            key=\"eld-17\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('constraint',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_21_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"expression.exists()\",\n            human=\"Constraints should have an expression or else validators will not be able to enforce them\",\n            key=\"eld-21\",\n            severity=\"warning\",\n        )\n\n    @field_validator(*('binding',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_12_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:'))\",\n            human=\"ValueSet SHALL start with http:// or https:// or urn:\",\n            key=\"eld-12\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def defaultValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'],\n            field_name_base=\"defaultValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def fixed_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'],\n            field_name_base=\"fixed\",\n        )\n\n    @model_validator(mode=\"after\")\n    def pattern_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'],\n            field_name_base=\"pattern\",\n        )\n\n    @model_validator(mode=\"after\")\n    def minValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, PositiveInt, UnsignedInt, 'Quantity'],\n            field_name_base=\"minValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def maxValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, PositiveInt, UnsignedInt, 'Quantity'],\n            field_name_base=\"maxValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"min.empty() or max.empty() or (max = '*') or iif(max != '*', min &lt;= max.toInteger())\",\n            human=\"Min &lt;= Max\",\n            key=\"eld-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())\",\n            human=\"if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding\",\n            key=\"eld-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"fixed.empty() or (type.count()  &lt;= 1)\",\n            human=\"Fixed value may only be specified if there is one type\",\n            key=\"eld-6\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_7_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or (type.count() &lt;= 1)\",\n            human=\"Pattern may only be specified if there is one type\",\n            key=\"eld-7\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_8_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or fixed.empty()\",\n            human=\"Pattern and fixed are mutually exclusive\",\n            key=\"eld-8\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_11_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"binding.empty() or type.code.empty() or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri')).exists()\",\n            human=\"Binding can only be present for coded elements, string, and uri\",\n            key=\"eld-11\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_13_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"type.select(code).isDistinct()\",\n            human=\"Types must be unique by code\",\n            key=\"eld-13\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_14_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"constraint.select(key).isDistinct()\",\n            human=\"Constraints must be unique by key\",\n            key=\"eld-14\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_15_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"defaultValue.empty() or meaningWhenMissing.empty()\",\n            human=\"default value and meaningWhenMissing are mutually exclusive\",\n            key=\"eld-15\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_16_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\\\/\\\\-_\\\\[\\\\]\\\\@]+$')\",\n            human=\"sliceName must be composed of proper tokens separated by \\\"/\\\"\",\n            key=\"eld-16\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_18_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(isModifier.exists() and isModifier) implies isModifierReason.exists()\",\n            human=\"Must have a modifier reason if isModifier = true\",\n            key=\"eld-18\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_19_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\.[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\[x\\\\])?(\\\\:[^\\\\s\\\\.]+)?)*')\",\n            human=\"Element names cannot include some special characters\",\n            key=\"eld-19\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_20_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('[A-Za-z][A-Za-z0-9]*(\\\\.[a-z][A-Za-z0-9]*(\\\\[x])?)*')\",\n            human=\"Element names should be simple alphanumerics with a max of 64 characters, or code generation tools may be broken\",\n            key=\"eld-20\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_22_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceIsConstraining.exists() implies sliceName.exists()\",\n            human=\"sliceIsConstraining can only appear if slicename is present\",\n            key=\"eld-22\",\n            severity=\"error\",\n        )\n\n    @property \n    def defaultValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"defaultValue\",\n        )\n    @property \n    def fixed(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"fixed\",\n        )\n    @property \n    def pattern(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"pattern\",\n        )\n    @property \n    def minValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"minValue\",\n        )\n    @property \n    def maxValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"maxValue\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Expression","title":"<code>Expression</code>","text":"<p>               Bases: <code>Element</code></p> <p>An expression that can be used to generate a value</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Expression(Element):\n    \"\"\"\n    An expression that can be used to generate a value\n    \"\"\"\n    description: typing.Optional[String] = Field(\n        description=\"Natural language description of the condition\",\n        default=None,\n    )\n    description_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for description extensions\",\n        default=None,\n        alias=\"_description\",\n    )\n    name: typing.Optional[Id] = Field(\n        description=\"Short name assigned to expression for reuse\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    language: Code = Field(\n        description=\"text/cql | text/fhirpath | application/x-fhir-query | etc.\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    expression: typing.Optional[String] = Field(\n        description=\"Expression in specified language\",\n        default=None,\n    )\n    expression_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for expression extensions\",\n        default=None,\n        alias=\"_expression\",\n    )\n    reference: typing.Optional[Uri] = Field(\n        description=\"Where the expression is found\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    @field_validator(*('reference', 'expression', 'language', 'name', 'description', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_exp_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"expression.exists() or reference.exists()\",\n            human=\"An expression or a reference must be provided\",\n            key=\"exp-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>Element</code></p> <p>Optional Extensions Element</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Extension(Element):\n    \"\"\"\n    Optional Extensions Element\n    \"\"\"\n    url: String = Field(\n        description=\"identifies the meaning of the extension\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    valueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCode: typing.Optional[Code] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDate: typing.Optional[Date] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueId: typing.Optional[Id] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInstant: typing.Optional[Instant] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInteger: typing.Optional[Integer] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueOid: typing.Optional[Oid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueString: typing.Optional[String] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTime: typing.Optional[Time] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUri: typing.Optional[Uri] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUrl: typing.Optional[Url] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUuid: typing.Optional[Uuid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAddress: typing.Optional['Address'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAge: typing.Optional['Age'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCoding: typing.Optional['Coding'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCount: typing.Optional['Count'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDistance: typing.Optional['Distance'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDuration: typing.Optional['Duration'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMoney: typing.Optional['Money'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePeriod: typing.Optional['Period'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRange: typing.Optional['Range'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueReference: typing.Optional['Reference'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSignature: typing.Optional['Signature'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTiming: typing.Optional['Timing'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueExpression: typing.Optional['Expression'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMeta: typing.Optional['Meta'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'],\n            field_name_base=\"value\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ext_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.HumanName","title":"<code>HumanName</code>","text":"<p>               Bases: <code>Element</code></p> <p>Name of a human - parts and usage</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class HumanName(Element):\n    \"\"\"\n    Name of a human - parts and usage\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | nickname | anonymous | old | maiden\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the full name\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    family: typing.Optional[String] = Field(\n        description=\"Family name (often called \\u0027Surname\\u0027)\",\n        default=None,\n    )\n    family_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for family extensions\",\n        default=None,\n        alias=\"_family\",\n    )\n    given: typing.Optional[typing.List[String]] = Field(\n        description=\"Given names (not always \\u0027first\\u0027). Includes middle names\",\n        default=None,\n    )\n    given_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for given extensions\",\n        default=None,\n        alias=\"_given\",\n    )\n    prefix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come before the name\",\n        default=None,\n    )\n    prefix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for prefix extensions\",\n        default=None,\n        alias=\"_prefix\",\n    )\n    suffix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come after the name\",\n        default=None,\n    )\n    suffix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for suffix extensions\",\n        default=None,\n        alias=\"_suffix\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when name was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'suffix', 'prefix', 'given', 'family', 'text', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Identifier","title":"<code>Identifier</code>","text":"<p>               Bases: <code>Element</code></p> <p>An identifier intended for computation</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Identifier(Element):\n    \"\"\"\n    An identifier intended for computation\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | secondary | old (If known)\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional['CodeableConcept'] = Field(\n        description=\"Description of identifier\",\n        default=None,\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"The namespace for the identifier value\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The value that is unique\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when id is/was valid for use\",\n        default=None,\n    )\n    assigner: typing.Optional['Reference'] = Field(\n        description=\"Organization that issued id (may be just text)\",\n        default=None,\n    )\n    @field_validator(*('assigner', 'period', 'value', 'system', 'type', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.MarketingStatus","title":"<code>MarketingStatus</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class MarketingStatus(BackboneElement):\n    \"\"\"\n    The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available\n    \"\"\"\n    country: 'CodeableConcept' = Field(\n        description=\"The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 \\u2011 1 alpha-2 code elements\",\n        default=None,\n    )\n    jurisdiction: typing.Optional['CodeableConcept'] = Field(\n        description=\"Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    status: 'CodeableConcept' = Field(\n        description=\"This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples\",\n        default=None,\n    )\n    dateRange: 'Period' = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate: typing.Optional[DateTime] = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for restoreDate extensions\",\n        default=None,\n        alias=\"_restoreDate\",\n    )\n    @field_validator(*('restoreDate', 'dateRange', 'status', 'jurisdiction', 'country', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>Element</code></p> <p>Metadata about a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Meta(Element):\n    \"\"\"\n    Metadata about a resource\n    \"\"\"\n    versionId: typing.Optional[Id] = Field(\n        description=\"Version specific identifier\",\n        default=None,\n    )\n    versionId_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for versionId extensions\",\n        default=None,\n        alias=\"_versionId\",\n    )\n    lastUpdated: typing.Optional[Instant] = Field(\n        description=\"When the resource version last changed\",\n        default=None,\n    )\n    lastUpdated_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lastUpdated extensions\",\n        default=None,\n        alias=\"_lastUpdated\",\n    )\n    source: typing.Optional[Uri] = Field(\n        description=\"Identifies where the resource comes from\",\n        default=None,\n    )\n    source_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for source extensions\",\n        default=None,\n        alias=\"_source\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"Profiles this resource claims to conform to\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    security: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Security Labels applied to this resource\",\n        default=None,\n    )\n    tag: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Tags applied to this resource\",\n        default=None,\n    )\n    @field_validator(*('tag', 'security', 'profile', 'source', 'lastUpdated', 'versionId', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Money","title":"<code>Money</code>","text":"<p>               Bases: <code>Element</code></p> <p>An amount of economic utility in some recognized currency</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Money(Element):\n    \"\"\"\n    An amount of economic utility in some recognized currency\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    currency: typing.Optional[Code] = Field(\n        description=\"ISO 4217 Currency Code\",\n        default=None,\n    )\n    currency_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for currency extensions\",\n        default=None,\n        alias=\"_currency\",\n    )\n    @field_validator(*('currency', 'value', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.MoneyQuantity","title":"<code>MoneyQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>An amount of money. With regard to precision, see Decimal Precision</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class MoneyQuantity(Quantity):\n    \"\"\"\n    An amount of money. With regard to precision, see [Decimal Precision](datatypes.html#precision)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_mqty_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = 'urn:iso:std:iso:4217')\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of currency.  If system is present, it SHALL be ISO 4217 (system = \\\"urn:iso:std:iso:4217\\\" - currency).\",\n            key=\"mqty-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Narrative","title":"<code>Narrative</code>","text":"<p>               Bases: <code>Element</code></p> <p>Human-readable summary of the resource (essential clinical and business information)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Narrative(Element):\n    \"\"\"\n    Human-readable summary of the resource (essential clinical and business information)\n    \"\"\"\n    status: Code = Field(\n        description=\"generated | extensions | additional | empty\",\n        default=None,\n    )\n    status_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for status extensions\",\n        default=None,\n        alias=\"_status\",\n    )\n    div: str = Field(\n        description=\"Limited xhtml content\",\n        default=None,\n    )\n    @field_validator(*('div', 'status', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL contain only the basic html formatting elements and attributes described in chapters 7-11 (except section 4 of chapter 9) and 15 of the HTML 4.0 standard, &lt;a&gt; elements (either name or href), images and internally contained style attributes\",\n            key=\"txt-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL have some non-whitespace content\",\n            key=\"txt-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ParameterDefinition","title":"<code>ParameterDefinition</code>","text":"<p>               Bases: <code>Element</code></p> <p>Definition of a parameter to a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ParameterDefinition(Element):\n    \"\"\"\n    Definition of a parameter to a module\n    \"\"\"\n    name: typing.Optional[Code] = Field(\n        description=\"Name used to access the parameter value\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    use: Code = Field(\n        description=\"in | out\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    min: typing.Optional[Integer] = Field(\n        description=\"Minimum cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum cardinality (a number of *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    documentation: typing.Optional[String] = Field(\n        description=\"A brief description of the parameter\",\n        default=None,\n    )\n    documentation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for documentation extensions\",\n        default=None,\n        alias=\"_documentation\",\n    )\n    type: Code = Field(\n        description=\"What type of value\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[Canonical] = Field(\n        description=\"What profile the value is expected to be\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    @field_validator(*('profile', 'type', 'documentation', 'max', 'min', 'use', 'name', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>Element</code></p> <p>Time range defined by start and end date/time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Period(Element):\n    \"\"\"\n    Time range defined by start and end date/time\n    \"\"\"\n    start: typing.Optional[DateTime] = Field(\n        description=\"Starting time with inclusive boundary\",\n        default=None,\n    )\n    start_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for start extensions\",\n        default=None,\n        alias=\"_start\",\n    )\n    end: typing.Optional[DateTime] = Field(\n        description=\"End time with inclusive boundary, if not ongoing\",\n        default=None,\n    )\n    end_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for end extensions\",\n        default=None,\n        alias=\"_end\",\n    )\n    @field_validator(*('end', 'start', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_per_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"start.hasValue().not() or end.hasValue().not() or (start &lt;= end)\",\n            human=\"If present, start SHALL have a lower value than end\",\n            key=\"per-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Population","title":"<code>Population</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Population(BackboneElement):\n    \"\"\"\n    A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication\n    \"\"\"\n    ageRange: typing.Optional['Range'] = Field(\n        description=\"The age of the specific population\",\n        default=None,\n    )\n    ageCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"The age of the specific population\",\n        default=None,\n    )\n    gender: typing.Optional['CodeableConcept'] = Field(\n        description=\"The gender of the specific population\",\n        default=None,\n    )\n    race: typing.Optional['CodeableConcept'] = Field(\n        description=\"Race of the specific population\",\n        default=None,\n    )\n    physiologicalCondition: typing.Optional['CodeableConcept'] = Field(\n        description=\"The existing physiological conditions of the specific population to which this applies\",\n        default=None,\n    )\n    @field_validator(*('physiologicalCondition', 'race', 'gender', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def age_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Range', 'CodeableConcept'],\n            field_name_base=\"age\",\n        )\n\n    @property \n    def age(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"age\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ProdCharacteristic","title":"<code>ProdCharacteristic</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ProdCharacteristic(BackboneElement):\n    \"\"\"\n    The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available\n    \"\"\"\n    height: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    width: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    depth: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    weight: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    nominalVolume: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    externalDiameter: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    shape: typing.Optional[String] = Field(\n        description=\"Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    shape_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for shape extensions\",\n        default=None,\n        alias=\"_shape\",\n    )\n    color: typing.Optional[typing.List[String]] = Field(\n        description=\"Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    color_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for color extensions\",\n        default=None,\n        alias=\"_color\",\n    )\n    imprint: typing.Optional[typing.List[String]] = Field(\n        description=\"Where applicable, the imprint can be specified as text\",\n        default=None,\n    )\n    imprint_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for imprint extensions\",\n        default=None,\n        alias=\"_imprint\",\n    )\n    image: typing.Optional[typing.List['Attachment']] = Field(\n        description=\"Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations\",\n        default=None,\n    )\n    scoring: typing.Optional['CodeableConcept'] = Field(\n        description=\"Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    @field_validator(*('scoring', 'image', 'imprint', 'color', 'shape', 'externalDiameter', 'nominalVolume', 'weight', 'depth', 'width', 'height', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.ProductShelfLife","title":"<code>ProductShelfLife</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The shelf-life and storage information for a medicinal product item or container can be described using this class</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class ProductShelfLife(BackboneElement):\n    \"\"\"\n    The shelf-life and storage information for a medicinal product item or container can be described using this class\n    \"\"\"\n    identifier: typing.Optional['Identifier'] = Field(\n        description=\"Unique identifier for the packaged Medicinal Product\",\n        default=None,\n    )\n    type: 'CodeableConcept' = Field(\n        description=\"This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    period: 'Quantity' = Field(\n        description=\"The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    specialPrecautionsForStorage: typing.Optional[typing.List['CodeableConcept']] = Field(\n        description=\"Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    @field_validator(*('specialPrecautionsForStorage', 'period', 'type', 'identifier', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Quantity","title":"<code>Quantity</code>","text":"<p>               Bases: <code>Element</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Quantity(Element):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>Element</code></p> <p>Set of values bounded by low and high</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Range(Element):\n    \"\"\"\n    Set of values bounded by low and high\n    \"\"\"\n    low: typing.Optional['Quantity'] = Field(\n        description=\"Low limit\",\n        default=None,\n    )\n    high: typing.Optional['Quantity'] = Field(\n        description=\"High limit\",\n        default=None,\n    )\n    @field_validator(*('high', 'low', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rng_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"low.empty() or high.empty() or (low &lt;= high)\",\n            human=\"If present, low SHALL have a lower value than high\",\n            key=\"rng-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Ratio","title":"<code>Ratio</code>","text":"<p>               Bases: <code>Element</code></p> <p>A ratio of two Quantity values - a numerator and a denominator</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Ratio(Element):\n    \"\"\"\n    A ratio of two Quantity values - a numerator and a denominator\n    \"\"\"\n    numerator: typing.Optional['Quantity'] = Field(\n        description=\"Numerator value\",\n        default=None,\n    )\n    denominator: typing.Optional['Quantity'] = Field(\n        description=\"Denominator value\",\n        default=None,\n    )\n    @field_validator(*('denominator', 'numerator', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rat_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(numerator.empty() xor denominator.exists()) and (numerator.exists() or extension.exists())\",\n            human=\"Numerator and denominator SHALL both be present, or both are absent. If both are absent, there SHALL be some extension present\",\n            key=\"rat-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Reference","title":"<code>Reference</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference from one resource to another</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Reference(Element):\n    \"\"\"\n    A reference from one resource to another\n    \"\"\"\n    reference: typing.Optional[String] = Field(\n        description=\"Literal reference, Relative, internal or absolute URL\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    type: typing.Optional[Uri] = Field(\n        description=\"Type the reference refers to (e.g. \\\"Patient\\\")\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    identifier: typing.Optional['Identifier'] = Field(\n        description=\"Logical reference, when literal reference is not known\",\n        default=None,\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Text alternative for the resource\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    @field_validator(*('display', 'identifier', 'type', 'reference', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ref_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"reference.startsWith('#').not() or (reference.substring(1).trace('url') in %rootResource.contained.id.trace('ids'))\",\n            human=\"SHALL have a contained resource if a local reference is provided\",\n            key=\"ref-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.RelatedArtifact","title":"<code>RelatedArtifact</code>","text":"<p>               Bases: <code>Element</code></p> <p>Related artifacts for a knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class RelatedArtifact(Element):\n    \"\"\"\n    Related artifacts for a knowledge resource\n    \"\"\"\n    type: Code = Field(\n        description=\"documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Short label\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Brief description of the related artifact\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    citation: typing.Optional[Markdown] = Field(\n        description=\"Bibliographic citation for the artifact\",\n        default=None,\n    )\n    citation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for citation extensions\",\n        default=None,\n        alias=\"_citation\",\n    )\n    url: typing.Optional[Url] = Field(\n        description=\"Where the artifact can be accessed\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    document: typing.Optional['Attachment'] = Field(\n        description=\"What document is being referenced\",\n        default=None,\n    )\n    resource: typing.Optional[Canonical] = Field(\n        description=\"What resource is being referenced\",\n        default=None,\n    )\n    resource_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for resource extensions\",\n        default=None,\n        alias=\"_resource\",\n    )\n    @field_validator(*('resource', 'document', 'url', 'citation', 'display', 'label', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Resource","title":"<code>Resource</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base Resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Resource(FHIRBaseModel):\n    \"\"\"\n    Base Resource\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Logical id of this artifact\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    meta: typing.Optional['Meta'] = Field(\n        description=\"Metadata about the resource\",\n        default=None,\n    )\n    implicitRules: typing.Optional[Uri] = Field(\n        description=\"A set of rules under which this content was created\",\n        default=None,\n    )\n    implicitRules_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for implicitRules extensions\",\n        default=None,\n        alias=\"_implicitRules\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Language of the resource content\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    @field_validator(*('language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.SampledData","title":"<code>SampledData</code>","text":"<p>               Bases: <code>Element</code></p> <p>A series of measurements taken by a device</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class SampledData(Element):\n    \"\"\"\n    A series of measurements taken by a device\n    \"\"\"\n    origin: 'Quantity' = Field(\n        description=\"Zero value and units\",\n        default=None,\n    )\n    period: Decimal = Field(\n        description=\"Number of milliseconds between samples\",\n        default=None,\n    )\n    period_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for period extensions\",\n        default=None,\n        alias=\"_period\",\n    )\n    factor: typing.Optional[Decimal] = Field(\n        description=\"Multiply data by this before adding to origin\",\n        default=None,\n    )\n    factor_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for factor extensions\",\n        default=None,\n        alias=\"_factor\",\n    )\n    lowerLimit: typing.Optional[Decimal] = Field(\n        description=\"Lower limit of detection\",\n        default=None,\n    )\n    lowerLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lowerLimit extensions\",\n        default=None,\n        alias=\"_lowerLimit\",\n    )\n    upperLimit: typing.Optional[Decimal] = Field(\n        description=\"Upper limit of detection\",\n        default=None,\n    )\n    upperLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for upperLimit extensions\",\n        default=None,\n        alias=\"_upperLimit\",\n    )\n    dimensions: PositiveInt = Field(\n        description=\"Number of sample points at each time point\",\n        default=None,\n    )\n    dimensions_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for dimensions extensions\",\n        default=None,\n        alias=\"_dimensions\",\n    )\n    data: typing.Optional[String] = Field(\n        description=\"Decimal values with spaces, or \\\"E\\\" | \\\"U\\\" | \\\"L\\\"\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'dimensions', 'upperLimit', 'lowerLimit', 'factor', 'period', 'origin', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Signature","title":"<code>Signature</code>","text":"<p>               Bases: <code>Element</code></p> <p>A Signature - XML DigSig, JWS, Graphical image of signature, etc.</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Signature(Element):\n    \"\"\"\n    A Signature - XML DigSig, JWS, Graphical image of signature, etc.\n    \"\"\"\n    type: typing.List['Coding'] = Field(\n        description=\"Indication of the reason the entity signed the object(s)\",\n        default=None,\n    )\n    when: Instant = Field(\n        description=\"When the signature was created\",\n        default=None,\n    )\n    when_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for when extensions\",\n        default=None,\n        alias=\"_when\",\n    )\n    who: 'Reference' = Field(\n        description=\"Who signed\",\n        default=None,\n    )\n    onBehalfOf: typing.Optional['Reference'] = Field(\n        description=\"The party represented\",\n        default=None,\n    )\n    targetFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signed resources\",\n        default=None,\n    )\n    targetFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for targetFormat extensions\",\n        default=None,\n        alias=\"_targetFormat\",\n    )\n    sigFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signature\",\n        default=None,\n    )\n    sigFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sigFormat extensions\",\n        default=None,\n        alias=\"_sigFormat\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"The actual signature content (XML DigSig. JWS, picture, etc.)\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'sigFormat', 'targetFormat', 'onBehalfOf', 'who', 'when', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.SimpleQuantity","title":"<code>SimpleQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A fixed quantity (no comparator)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class SimpleQuantity(Quantity):\n    \"\"\"\n    A fixed quantity (no comparator)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_sqty_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"comparator.empty()\",\n            human=\"The comparator is not used on a SimpleQuantity\",\n            key=\"sqty-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.SubstanceAmount","title":"<code>SubstanceAmount</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class SubstanceAmount(BackboneElement):\n    \"\"\"\n    Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID\n    \"\"\"\n    amountQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field\",\n        default=None,\n    )\n    amountRange: typing.Optional['Range'] = Field(\n        description=\"Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field\",\n        default=None,\n    )\n    amountString: typing.Optional[String] = Field(\n        description=\"Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field\",\n        default=None,\n    )\n    amountType: typing.Optional['CodeableConcept'] = Field(\n        description=\"Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements\",\n        default=None,\n    )\n    amountText: typing.Optional[String] = Field(\n        description=\"A textual comment on a numeric value\",\n        default=None,\n    )\n    amountText_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for amountText extensions\",\n        default=None,\n        alias=\"_amountText\",\n    )\n    referenceRange: typing.Optional['Element'] = Field(\n        description=\"Reference range of possible or expected values\",\n        default=None,\n    )\n    @field_validator(*('referenceRange', 'amountText', 'amountType', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def amount_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Quantity', 'Range', String],\n            field_name_base=\"amount\",\n        )\n\n    @property \n    def amount(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"amount\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.Timing","title":"<code>Timing</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>A timing schedule that specifies an event that may occur multiple times</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class Timing(BackboneElement):\n    \"\"\"\n    A timing schedule that specifies an event that may occur multiple times\n    \"\"\"\n    event: typing.Optional[typing.List[DateTime]] = Field(\n        description=\"When the event occurs\",\n        default=None,\n    )\n    event_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for event extensions\",\n        default=None,\n        alias=\"_event\",\n    )\n    repeat: typing.Optional['Element'] = Field(\n        description=\"When the event is to occur\",\n        default=None,\n    )\n    code: typing.Optional['CodeableConcept'] = Field(\n        description=\"BID | TID | QID | AM | PM | QD | QOD | +\",\n        default=None,\n    )\n    @field_validator(*('code', 'repeat', 'event', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.empty() or durationUnit.exists()\",\n            human=\"if there's a duration, there needs to be duration units\",\n            key=\"tim-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.empty() or periodUnit.exists()\",\n            human=\"if there's a period, there needs to be period units\",\n            key=\"tim-2\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.exists() implies duration &gt;= 0\",\n            human=\"duration SHALL be a non-negative value\",\n            key=\"tim-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_5_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.exists() implies period &gt;= 0\",\n            human=\"period SHALL be a non-negative value\",\n            key=\"tim-5\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_6_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"periodMax.empty() or period.exists()\",\n            human=\"If there's a periodMax, there must be a period\",\n            key=\"tim-6\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_7_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"durationMax.empty() or duration.exists()\",\n            human=\"If there's a durationMax, there must be a duration\",\n            key=\"tim-7\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_8_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"countMax.empty() or count.exists()\",\n            human=\"If there's a countMax, there must be a count\",\n            key=\"tim-8\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_9_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"offset.empty() or (when.exists() and ((when in ('C' | 'CM' | 'CD' | 'CV')).not()))\",\n            human=\"If there's an offset, there must be a when (and not C, CM, CD, CV)\",\n            key=\"tim-9\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_10_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"timeOfDay.empty() or when.empty()\",\n            human=\"If there's a timeOfDay, there cannot be a when, or vice versa\",\n            key=\"tim-10\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.TriggerDefinition","title":"<code>TriggerDefinition</code>","text":"<p>               Bases: <code>Element</code></p> <p>Defines an expected trigger for a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class TriggerDefinition(Element):\n    \"\"\"\n    Defines an expected trigger for a module\n    \"\"\"\n    type: Code = Field(\n        description=\"named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: typing.Optional[String] = Field(\n        description=\"Name or URI that identifies the event\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    timingTiming: typing.Optional['Timing'] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingReference: typing.Optional['Reference'] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDate: typing.Optional[Date] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDateTime: typing.Optional[DateTime] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    data: typing.Optional[typing.List['DataRequirement']] = Field(\n        description=\"Triggering data of the event (multiple = \\u0027and\\u0027)\",\n        default=None,\n    )\n    condition: typing.Optional['Expression'] = Field(\n        description=\"Whether the event triggers (boolean expression)\",\n        default=None,\n    )\n    @field_validator(*('condition', 'data', 'name', 'type', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def timing_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Timing', 'Reference', Date, DateTime],\n            field_name_base=\"timing\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or timing.empty()\",\n            human=\"Either timing, or a data requirement, but not both\",\n            key=\"trd-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"condition.exists() implies data.exists()\",\n            human=\"A condition only if there is a data requirement\",\n            key=\"trd-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(type = 'named-event' implies name.exists()) and (type = 'periodic' implies timing.exists()) and (type.startsWith('data-') implies data.exists())\",\n            human=\"A named event requires a name, a periodic event requires timing, and a data event requires data\",\n            key=\"trd-3\",\n            severity=\"error\",\n        )\n\n    @property \n    def timing(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"timing\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.UsageContext","title":"<code>UsageContext</code>","text":"<p>               Bases: <code>Element</code></p> <p>Describes the context of use for a conformance or knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class UsageContext(Element):\n    \"\"\"\n    Describes the context of use for a conformance or knowledge resource\n    \"\"\"\n    code: 'Coding' = Field(\n        description=\"Type of context being specified\",\n        default=None,\n    )\n    valueCodeableConcept: 'CodeableConcept' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueQuantity: 'Quantity' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueRange: 'Range' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueReference: 'Reference' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    @field_validator(*('code', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['CodeableConcept', 'Quantity', 'Range', 'Reference'],\n            field_name_base=\"value\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4/complex_types/#fhircraft.fhir.resources.datatypes.R4.complex_types.xhtml","title":"<code>xhtml</code>","text":"<p>               Bases: <code>Element</code></p> <p>Primitive Type xhtml</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4/complex_types.py</code> <pre><code>class xhtml(Element):\n    \"\"\"\n    Primitive Type xhtml\n    \"\"\"\n    value: String = Field(\n        description=\"Actual xhtml\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/","title":"Complex types","text":""},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>Element</code></p> <p>An address expressed using postal conventions (as opposed to GPS or other location definition formats)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Address(Element):\n    \"\"\"\n    An address expressed using postal conventions (as opposed to GPS or other location definition formats)\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | billing - purpose of this address\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional[Code] = Field(\n        description=\"postal | physical | both\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the address\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    line: typing.Optional[typing.List[String]] = Field(\n        description=\"Street name, number, direction \\u0026 P.O. Box etc.\",\n        default=None,\n    )\n    line_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for line extensions\",\n        default=None,\n        alias=\"_line\",\n    )\n    city: typing.Optional[String] = Field(\n        description=\"Name of city, town etc.\",\n        default=None,\n    )\n    city_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for city extensions\",\n        default=None,\n        alias=\"_city\",\n    )\n    district: typing.Optional[String] = Field(\n        description=\"District name (aka county)\",\n        default=None,\n    )\n    district_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for district extensions\",\n        default=None,\n        alias=\"_district\",\n    )\n    state: typing.Optional[String] = Field(\n        description=\"Sub-unit of country (abbreviations ok)\",\n        default=None,\n    )\n    state_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for state extensions\",\n        default=None,\n        alias=\"_state\",\n    )\n    postalCode: typing.Optional[String] = Field(\n        description=\"Postal code for area\",\n        default=None,\n    )\n    postalCode_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for postalCode extensions\",\n        default=None,\n        alias=\"_postalCode\",\n    )\n    country: typing.Optional[String] = Field(\n        description=\"Country (e.g. can be ISO 3166 2 or 3 letter code)\",\n        default=None,\n    )\n    country_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for country extensions\",\n        default=None,\n        alias=\"_country\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when address was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'country', 'postalCode', 'state', 'district', 'city', 'line', 'text', 'type', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Age","title":"<code>Age</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A duration of time during which an organism (or a process) has existed</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Age(Quantity):\n    \"\"\"\n    A duration of time during which an organism (or a process) has existed\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_age_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (value.empty() or value.hasValue().not() or value &gt; 0)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.  If value is present, it SHALL be positive.\",\n            key=\"age-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Annotation","title":"<code>Annotation</code>","text":"<p>               Bases: <code>Element</code></p> <p>Text node with attribution</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Annotation(Element):\n    \"\"\"\n    Text node with attribution\n    \"\"\"\n    authorReference: typing.Optional['Reference'] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    authorString: typing.Optional[String] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    time: typing.Optional[DateTime] = Field(\n        description=\"When the annotation was made\",\n        default=None,\n    )\n    time_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for time extensions\",\n        default=None,\n        alias=\"_time\",\n    )\n    text: Markdown = Field(\n        description=\"The annotation  - text content (as markdown)\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'time', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def author_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Reference', String],\n            field_name_base=\"author\",\n        )\n\n    @property \n    def author(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"author\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>Element</code></p> <p>Content in a format defined elsewhere</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Attachment(Element):\n    \"\"\"\n    Content in a format defined elsewhere\n    \"\"\"\n    contentType: typing.Optional[Code] = Field(\n        description=\"Mime type of the content, with charset etc.\",\n        default=None,\n    )\n    contentType_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentType extensions\",\n        default=None,\n        alias=\"_contentType\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Human language of the content (BCP-47)\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"Data inline, base64ed\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    url: typing.Optional[Url] = Field(\n        description=\"Uri where the data can be found\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    size: typing.Optional[UnsignedInt] = Field(\n        description=\"Number of bytes of content (if url provided)\",\n        default=None,\n    )\n    size_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for size extensions\",\n        default=None,\n        alias=\"_size\",\n    )\n    hash: typing.Optional[Base64Binary] = Field(\n        description=\"Hash of the data (sha-1, base64ed)\",\n        default=None,\n    )\n    hash_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for hash extensions\",\n        default=None,\n        alias=\"_hash\",\n    )\n    title: typing.Optional[String] = Field(\n        description=\"Label to display in place of the data\",\n        default=None,\n    )\n    title_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for title extensions\",\n        default=None,\n        alias=\"_title\",\n    )\n    creation: typing.Optional[DateTime] = Field(\n        description=\"Date attachment was first created\",\n        default=None,\n    )\n    creation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for creation extensions\",\n        default=None,\n        alias=\"_creation\",\n    )\n    @field_validator(*('creation', 'title', 'hash', 'size', 'url', 'data', 'language', 'contentType', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_att_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or contentType.exists()\",\n            human=\"If the Attachment has data, it SHALL have a contentType\",\n            key=\"att-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.BackboneElement","title":"<code>BackboneElement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Base for elements defined inside a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class BackboneElement(Element):\n    \"\"\"\n    Base for elements defined inside a resource\n    \"\"\"\n    modifierExtension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Extensions that cannot be ignored even if unrecognized\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.CodeableConcept","title":"<code>CodeableConcept</code>","text":"<p>               Bases: <code>Element</code></p> <p>Concept - reference to a terminology or just  text</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class CodeableConcept(Element):\n    \"\"\"\n    Concept - reference to a terminology or just  text\n    \"\"\"\n    coding: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Code defined by a terminology system\",\n        default=None,\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Plain text representation of the concept\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'coding', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.CodeableReference","title":"<code>CodeableReference</code>","text":"<p>               Bases: <code>Element</code></p> <p>Reference to a resource or a concept</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class CodeableReference(Element):\n    \"\"\"\n    Reference to a resource or a concept\n    \"\"\"\n    concept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Reference to a concept (by class)\",\n        default=None,\n    )\n    reference: typing.Optional['Reference'] = Field(\n        description=\"Reference to a resource (by instance)\",\n        default=None,\n    )\n    @field_validator(*('reference', 'concept', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Coding","title":"<code>Coding</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference to a code defined by a terminology system</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Coding(Element):\n    \"\"\"\n    A reference to a code defined by a terminology system\n    \"\"\"\n    system: typing.Optional[Uri] = Field(\n        description=\"Identity of the terminology system\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    version: typing.Optional[String] = Field(\n        description=\"Version of the system - if relevant\",\n        default=None,\n    )\n    version_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for version extensions\",\n        default=None,\n        alias=\"_version\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Symbol in syntax defined by the system\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Representation defined by the system\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    userSelected: typing.Optional[Boolean] = Field(\n        description=\"If this coding was chosen directly by the user\",\n        default=None,\n    )\n    userSelected_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for userSelected extensions\",\n        default=None,\n        alias=\"_userSelected\",\n    )\n    @field_validator(*('userSelected', 'display', 'code', 'version', 'system', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ContactDetail","title":"<code>ContactDetail</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contact information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ContactDetail(Element):\n    \"\"\"\n    Contact information\n    \"\"\"\n    name: typing.Optional[String] = Field(\n        description=\"Name of an individual to contact\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    telecom: typing.Optional[typing.List['ContactPoint']] = Field(\n        description=\"Contact details for individual or organization\",\n        default=None,\n    )\n    @field_validator(*('telecom', 'name', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ContactPoint","title":"<code>ContactPoint</code>","text":"<p>               Bases: <code>Element</code></p> <p>Details of a Technology mediated contact point (phone, fax, email, etc.)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ContactPoint(Element):\n    \"\"\"\n    Details of a Technology mediated contact point (phone, fax, email, etc.)\n    \"\"\"\n    system: typing.Optional[Code] = Field(\n        description=\"phone | fax | email | pager | url | sms | other\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The actual contact point details\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | mobile - purpose of this contact point\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    rank: typing.Optional[PositiveInt] = Field(\n        description=\"Specify preferred order of use (1 = highest)\",\n        default=None,\n    )\n    rank_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for rank extensions\",\n        default=None,\n        alias=\"_rank\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when the contact point was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'rank', 'use', 'value', 'system', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cpt_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"value.empty() or system.exists()\",\n            human=\"A system is required if a value is provided.\",\n            key=\"cpt-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Contributor","title":"<code>Contributor</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contributor information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Contributor(Element):\n    \"\"\"\n    Contributor information\n    \"\"\"\n    type: Code = Field(\n        description=\"author | editor | reviewer | endorser\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: String = Field(\n        description=\"Who contributed the content\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    contact: typing.Optional[typing.List['ContactDetail']] = Field(\n        description=\"Contact details of the contributor\",\n        default=None,\n    )\n    @field_validator(*('contact', 'name', 'type', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Count","title":"<code>Count</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Count(Quantity):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cnt_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (code.empty() or code = '1') and (value.empty() or value.hasValue().not() or value.toString().contains('.').not())\",\n            human=\"There SHALL be a code with a value of \\\"1\\\" if there is a value. If system is present, it SHALL be UCUM.  If present, the value SHALL be a whole number.\",\n            key=\"cnt-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.DataRequirement","title":"<code>DataRequirement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Describes a required data item</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class DataRequirement(Element):\n    \"\"\"\n    Describes a required data item\n    \"\"\"\n    type: Code = Field(\n        description=\"The type of the required data\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"The profile of the required data\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    subjectCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    subjectReference: typing.Optional['Reference'] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    mustSupport: typing.Optional[typing.List[String]] = Field(\n        description=\"Indicates specific structure elements that are referenced by the knowledge module\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    codeFilter: typing.Optional[typing.List['Element']] = Field(\n        description=\"What codes are expected\",\n        default=None,\n    )\n    dateFilter: typing.Optional[typing.List['Element']] = Field(\n        description=\"What dates/date ranges are expected\",\n        default=None,\n    )\n    limit: typing.Optional[PositiveInt] = Field(\n        description=\"Number of results\",\n        default=None,\n    )\n    limit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for limit extensions\",\n        default=None,\n        alias=\"_limit\",\n    )\n    sort: typing.Optional[typing.List['Element']] = Field(\n        description=\"Order of the results\",\n        default=None,\n    )\n    @field_validator(*('sort', 'limit', 'dateFilter', 'codeFilter', 'mustSupport', 'profile', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('codeFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('dateFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def subject_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['CodeableConcept', 'Reference'],\n            field_name_base=\"subject\",\n        )\n\n    @property \n    def subject(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"subject\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A length - a value with a unit that is a physical distance</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Distance(Quantity):\n    \"\"\"\n    A length - a value with a unit that is a physical distance\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dis_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of length.  If system is present, it SHALL be UCUM.\",\n            key=\"dis-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.DomainResource","title":"<code>DomainResource</code>","text":"<p>               Bases: <code>Resource</code></p> <p>A resource with narrative, extensions, and contained resources</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class DomainResource(Resource):\n    \"\"\"\n    A resource with narrative, extensions, and contained resources\n    \"\"\"\n    text: typing.Optional['Narrative'] = Field(\n        description=\"Text summary of the resource, for human interpretation\",\n        default=None,\n    )\n    contained: typing.Optional[typing.List['Resource']] = Field(\n        description=\"Contained, inline Resources\",\n        default=None,\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    modifierExtension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Extensions that cannot be ignored\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('contained',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_dom_r4b_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"($this is Citation or $this is Evidence or $this is EvidenceReport or $this is EvidenceVariable or $this is MedicinalProductDefinition or $this is PackagedProductDefinition or $this is AdministrableProductDefinition or $this is Ingredient or $this is ClinicalUseDefinition or $this is RegulatedAuthorization or $this is SubstanceDefinition or $this is SubscriptionStatus or $this is SubscriptionTopic) implies (%resource is Citation or %resource is Evidence or %resource is EvidenceReport or %resource is EvidenceVariable or %resource is MedicinalProductDefinition or %resource is PackagedProductDefinition or %resource is AdministrableProductDefinition or %resource is Ingredient or %resource is ClinicalUseDefinition or %resource is RegulatedAuthorization or %resource is SubstanceDefinition or %resource is SubscriptionStatus or %resource is SubscriptionTopic)\",\n            human=\"Containing new R4B resources within R4 resources may cause interoperability issues if instances are shared with R4 systems\",\n            key=\"dom-r4b\",\n            severity=\"warning\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.contained.empty()\",\n            human=\"If the resource is contained in another resource, it SHALL NOT contain nested Resources\",\n            key=\"dom-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.where(((id.exists() and ('#'+id in (%resource.descendants().reference | %resource.descendants().as(canonical) | %resource.descendants().as(uri) | %resource.descendants().as(url)))) or descendants().where(reference = '#').exists() or descendants().where(as(canonical) = '#').exists() or descendants().where(as(uri) = '#').exists()).not()).trace('unmatched', id).empty()\",\n            human=\"If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource\",\n            key=\"dom-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_4_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated\",\n            key=\"dom-4\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.security.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a security label\",\n            key=\"dom-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"text.`div`.exists()\",\n            human=\"A resource should have narrative for robust management\",\n            key=\"dom-6\",\n            severity=\"warning\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Dosage","title":"<code>Dosage</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>How the medication is/was taken or should be taken</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Dosage(BackboneElement):\n    \"\"\"\n    How the medication is/was taken or should be taken\n    \"\"\"\n    sequence: typing.Optional[Integer] = Field(\n        description=\"The order of the dosage instructions\",\n        default=None,\n    )\n    sequence_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sequence extensions\",\n        default=None,\n        alias=\"_sequence\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Free text dosage instructions e.g. SIG\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    additionalInstruction: typing.Optional[typing.List['CodeableConcept']] = Field(\n        description=\"Supplemental instruction or warnings to the patient - e.g. \\\"with meals\\\", \\\"may cause drowsiness\\\"\",\n        default=None,\n    )\n    patientInstruction: typing.Optional[String] = Field(\n        description=\"Patient or consumer oriented instructions\",\n        default=None,\n    )\n    patientInstruction_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for patientInstruction extensions\",\n        default=None,\n        alias=\"_patientInstruction\",\n    )\n    timing: typing.Optional['Timing'] = Field(\n        description=\"When medication should be administered\",\n        default=None,\n    )\n    asNeededBoolean: typing.Optional[Boolean] = Field(\n        description=\"Take \\\"as needed\\\" (for x)\",\n        default=None,\n    )\n    asNeededCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Take \\\"as needed\\\" (for x)\",\n        default=None,\n    )\n    site: typing.Optional['CodeableConcept'] = Field(\n        description=\"Body site to administer to\",\n        default=None,\n    )\n    route: typing.Optional['CodeableConcept'] = Field(\n        description=\"How drug should enter body\",\n        default=None,\n    )\n    method: typing.Optional['CodeableConcept'] = Field(\n        description=\"Technique for administering medication\",\n        default=None,\n    )\n    doseAndRate: typing.Optional[typing.List['Element']] = Field(\n        description=\"Amount of medication administered\",\n        default=None,\n    )\n    maxDosePerPeriod: typing.Optional['Ratio'] = Field(\n        description=\"Upper limit on medication per unit of time\",\n        default=None,\n    )\n    maxDosePerAdministration: typing.Optional['Quantity'] = Field(\n        description=\"Upper limit on medication per administration\",\n        default=None,\n    )\n    maxDosePerLifetime: typing.Optional['Quantity'] = Field(\n        description=\"Upper limit on medication per lifetime of the patient\",\n        default=None,\n    )\n    @field_validator(*('maxDosePerLifetime', 'maxDosePerAdministration', 'maxDosePerPeriod', 'doseAndRate', 'method', 'route', 'site', 'timing', 'patientInstruction', 'additionalInstruction', 'text', 'sequence', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def asNeeded_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Boolean, 'CodeableConcept'],\n            field_name_base=\"asNeeded\",\n        )\n\n    @property \n    def asNeeded(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"asNeeded\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A length of time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Duration(Quantity):\n    \"\"\"\n    A length of time\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_drt_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"value.exists() implies ((system = %ucum) and code.exists())\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.\",\n            key=\"drt-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base for all elements</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Element(FHIRBaseModel):\n    \"\"\"\n    Base for all elements\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List['Extension']] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ElementDefinition","title":"<code>ElementDefinition</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>Definition of an element in a resource or extension</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ElementDefinition(BackboneElement):\n    \"\"\"\n    Definition of an element in a resource or extension\n    \"\"\"\n    path: String = Field(\n        description=\"Path of the element in the hierarchy of elements\",\n        default=None,\n    )\n    path_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for path extensions\",\n        default=None,\n        alias=\"_path\",\n    )\n    representation: typing.Optional[typing.List[Code]] = Field(\n        description=\"xmlAttr | xmlText | typeAttr | cdaText | xhtml\",\n        default=None,\n    )\n    representation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for representation extensions\",\n        default=None,\n        alias=\"_representation\",\n    )\n    sliceName: typing.Optional[String] = Field(\n        description=\"Name for this particular element (in a set of slices)\",\n        default=None,\n    )\n    sliceName_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceName extensions\",\n        default=None,\n        alias=\"_sliceName\",\n    )\n    sliceIsConstraining: typing.Optional[Boolean] = Field(\n        description=\"If this slice definition constrains an inherited slice definition (or not)\",\n        default=None,\n    )\n    sliceIsConstraining_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceIsConstraining extensions\",\n        default=None,\n        alias=\"_sliceIsConstraining\",\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Name for element to display with or prompt for element\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    code: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Corresponding codes in terminologies\",\n        default=None,\n    )\n    slicing: typing.Optional['Element'] = Field(\n        description=\"This element is sliced - slices follow\",\n        default=None,\n    )\n    short: typing.Optional[String] = Field(\n        description=\"Concise definition for space-constrained presentation\",\n        default=None,\n    )\n    short_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for short extensions\",\n        default=None,\n        alias=\"_short\",\n    )\n    definition: typing.Optional[Markdown] = Field(\n        description=\"Full formal definition as narrative text\",\n        default=None,\n    )\n    definition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for definition extensions\",\n        default=None,\n        alias=\"_definition\",\n    )\n    comment: typing.Optional[Markdown] = Field(\n        description=\"Comments about the use of this element\",\n        default=None,\n    )\n    comment_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comment extensions\",\n        default=None,\n        alias=\"_comment\",\n    )\n    requirements: typing.Optional[Markdown] = Field(\n        description=\"Why this resource has been created\",\n        default=None,\n    )\n    requirements_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for requirements extensions\",\n        default=None,\n        alias=\"_requirements\",\n    )\n    alias: typing.Optional[typing.List[String]] = Field(\n        description=\"Other names\",\n        default=None,\n    )\n    alias_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for alias extensions\",\n        default=None,\n        alias=\"_alias\",\n    )\n    min: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum Cardinality (a number or *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    base: typing.Optional['Element'] = Field(\n        description=\"Base definition information for tools\",\n        default=None,\n    )\n    contentReference: typing.Optional[Uri] = Field(\n        description=\"Reference to definition of content for the element\",\n        default=None,\n    )\n    contentReference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentReference extensions\",\n        default=None,\n        alias=\"_contentReference\",\n    )\n    type: typing.Optional[typing.List['Element']] = Field(\n        description=\"Data type and Profile for this element\",\n        default=None,\n    )\n    defaultValueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCode: typing.Optional[Code] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDate: typing.Optional[Date] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueId: typing.Optional[Id] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInstant: typing.Optional[Instant] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInteger: typing.Optional[Integer] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueOid: typing.Optional[Oid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueString: typing.Optional[String] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTime: typing.Optional[Time] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUri: typing.Optional[Uri] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUrl: typing.Optional[Url] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUuid: typing.Optional[Uuid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAddress: typing.Optional['Address'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAge: typing.Optional['Age'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCodeableReference: typing.Optional['CodeableReference'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCoding: typing.Optional['Coding'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCount: typing.Optional['Count'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDistance: typing.Optional['Distance'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDuration: typing.Optional['Duration'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMoney: typing.Optional['Money'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePeriod: typing.Optional['Period'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRange: typing.Optional['Range'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRatio: typing.Optional['Ratio'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRatioRange: typing.Optional['RatioRange'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueReference: typing.Optional['Reference'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSignature: typing.Optional['Signature'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTiming: typing.Optional['Timing'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContributor: typing.Optional['Contributor'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueExpression: typing.Optional['Expression'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDosage: typing.Optional['Dosage'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    meaningWhenMissing: typing.Optional[Markdown] = Field(\n        description=\"Implicit meaning when this element is missing\",\n        default=None,\n    )\n    meaningWhenMissing_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for meaningWhenMissing extensions\",\n        default=None,\n        alias=\"_meaningWhenMissing\",\n    )\n    orderMeaning: typing.Optional[String] = Field(\n        description=\"What the order of the elements means\",\n        default=None,\n    )\n    orderMeaning_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for orderMeaning extensions\",\n        default=None,\n        alias=\"_orderMeaning\",\n    )\n    fixedBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCode: typing.Optional[Code] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDate: typing.Optional[Date] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedId: typing.Optional[Id] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInstant: typing.Optional[Instant] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInteger: typing.Optional[Integer] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedOid: typing.Optional[Oid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedString: typing.Optional[String] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTime: typing.Optional[Time] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUri: typing.Optional[Uri] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUrl: typing.Optional[Url] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAddress: typing.Optional['Address'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAge: typing.Optional['Age'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCodeableReference: typing.Optional['CodeableReference'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCoding: typing.Optional['Coding'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCount: typing.Optional['Count'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDistance: typing.Optional['Distance'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDuration: typing.Optional['Duration'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMoney: typing.Optional['Money'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPeriod: typing.Optional['Period'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRange: typing.Optional['Range'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRatioRange: typing.Optional['RatioRange'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedReference: typing.Optional['Reference'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSignature: typing.Optional['Signature'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTiming: typing.Optional['Timing'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedExpression: typing.Optional['Expression'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    patternBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCode: typing.Optional[Code] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDate: typing.Optional[Date] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternId: typing.Optional[Id] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInstant: typing.Optional[Instant] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInteger: typing.Optional[Integer] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternOid: typing.Optional[Oid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternString: typing.Optional[String] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTime: typing.Optional[Time] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUri: typing.Optional[Uri] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUrl: typing.Optional[Url] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAddress: typing.Optional['Address'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAge: typing.Optional['Age'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCodeableReference: typing.Optional['CodeableReference'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCoding: typing.Optional['Coding'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCount: typing.Optional['Count'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDistance: typing.Optional['Distance'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDuration: typing.Optional['Duration'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMoney: typing.Optional['Money'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPeriod: typing.Optional['Period'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRange: typing.Optional['Range'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRatioRange: typing.Optional['RatioRange'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternReference: typing.Optional['Reference'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSignature: typing.Optional['Signature'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTiming: typing.Optional['Timing'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternExpression: typing.Optional['Expression'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    example: typing.Optional[typing.List['Element']] = Field(\n        description=\"Example value (as defined for type)\",\n        default=None,\n    )\n    minValueDate: typing.Optional[Date] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInstant: typing.Optional[Instant] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueTime: typing.Optional[Time] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInteger: typing.Optional[Integer] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDate: typing.Optional[Date] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInstant: typing.Optional[Instant] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueTime: typing.Optional[Time] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInteger: typing.Optional[Integer] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxLength: typing.Optional[Integer] = Field(\n        description=\"Max length for strings\",\n        default=None,\n    )\n    maxLength_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for maxLength extensions\",\n        default=None,\n        alias=\"_maxLength\",\n    )\n    condition: typing.Optional[typing.List[Id]] = Field(\n        description=\"Reference to invariant about presence\",\n        default=None,\n    )\n    condition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for condition extensions\",\n        default=None,\n        alias=\"_condition\",\n    )\n    constraint: typing.Optional[typing.List['Element']] = Field(\n        description=\"Condition that must evaluate to true\",\n        default=None,\n    )\n    mustSupport: typing.Optional[Boolean] = Field(\n        description=\"If the element must be supported\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    isModifier: typing.Optional[Boolean] = Field(\n        description=\"If this modifies the meaning of other elements\",\n        default=None,\n    )\n    isModifier_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifier extensions\",\n        default=None,\n        alias=\"_isModifier\",\n    )\n    isModifierReason: typing.Optional[String] = Field(\n        description=\"Reason that this element is marked as a modifier\",\n        default=None,\n    )\n    isModifierReason_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifierReason extensions\",\n        default=None,\n        alias=\"_isModifierReason\",\n    )\n    isSummary: typing.Optional[Boolean] = Field(\n        description=\"Include when _summary = true?\",\n        default=None,\n    )\n    isSummary_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isSummary extensions\",\n        default=None,\n        alias=\"_isSummary\",\n    )\n    binding: typing.Optional['Element'] = Field(\n        description=\"ValueSet details if this is coded\",\n        default=None,\n    )\n    mapping: typing.Optional[typing.List['Element']] = Field(\n        description=\"Map element to another set of definitions\",\n        default=None,\n    )\n    @field_validator(*('mapping', 'binding', 'isSummary', 'isModifierReason', 'isModifier', 'mustSupport', 'constraint', 'condition', 'maxLength', 'example', 'orderMeaning', 'meaningWhenMissing', 'type', 'contentReference', 'base', 'max', 'min', 'alias', 'requirements', 'comment', 'definition', 'short', 'slicing', 'code', 'label', 'sliceIsConstraining', 'sliceName', 'representation', 'path', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('slicing',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"discriminator.exists() or description.exists()\",\n            human=\"If there are no discriminators, there must be a definition\",\n            key=\"eld-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('max',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_3_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"empty() or ($this = '*') or (toInteger() &gt;= 0)\",\n            human=\"Max SHALL be a number or \\\"*\\\"\",\n            key=\"eld-3\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"aggregation.empty() or (code = 'Reference') or (code = 'canonical')\",\n            human=\"Aggregation may only be specified if one of the allowed types for the element is a reference\",\n            key=\"eld-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_17_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"(code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()\",\n            human=\"targetProfile is only allowed if the type is Reference or canonical\",\n            key=\"eld-17\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('constraint',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_21_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"expression.exists()\",\n            human=\"Constraints should have an expression or else validators will not be able to enforce them\",\n            key=\"eld-21\",\n            severity=\"warning\",\n        )\n\n    @field_validator(*('binding',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_12_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))\",\n            human=\"ValueSet SHALL start with http:// or https:// or urn:\",\n            key=\"eld-12\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def defaultValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'],\n            field_name_base=\"defaultValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def fixed_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'],\n            field_name_base=\"fixed\",\n        )\n\n    @model_validator(mode=\"after\")\n    def pattern_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'],\n            field_name_base=\"pattern\",\n        )\n\n    @model_validator(mode=\"after\")\n    def minValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, PositiveInt, UnsignedInt, 'Quantity'],\n            field_name_base=\"minValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def maxValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, PositiveInt, UnsignedInt, 'Quantity'],\n            field_name_base=\"maxValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"min.empty() or max.empty() or (max = '*') or iif(max != '*', min &lt;= max.toInteger())\",\n            human=\"Min &lt;= Max\",\n            key=\"eld-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())\",\n            human=\"if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding\",\n            key=\"eld-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"fixed.empty() or (type.count()  &lt;= 1)\",\n            human=\"Fixed value may only be specified if there is one type\",\n            key=\"eld-6\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_7_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or (type.count() &lt;= 1)\",\n            human=\"Pattern may only be specified if there is one type\",\n            key=\"eld-7\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_8_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or fixed.empty()\",\n            human=\"Pattern and fixed are mutually exclusive\",\n            key=\"eld-8\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_11_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"binding.empty() or type.code.empty() or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()\",\n            human=\"Binding can only be present for coded elements, string, and uri\",\n            key=\"eld-11\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_13_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"type.select(code).isDistinct()\",\n            human=\"Types must be unique by code\",\n            key=\"eld-13\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_14_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"constraint.select(key).isDistinct()\",\n            human=\"Constraints must be unique by key\",\n            key=\"eld-14\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_15_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"defaultValue.empty() or meaningWhenMissing.empty()\",\n            human=\"default value and meaningWhenMissing are mutually exclusive\",\n            key=\"eld-15\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_16_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\\\/\\\\-_\\\\[\\\\]\\\\@]+$')\",\n            human=\"sliceName must be composed of proper tokens separated by\\\"/\\\"\",\n            key=\"eld-16\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_18_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(isModifier.exists() and isModifier) implies isModifierReason.exists()\",\n            human=\"Must have a modifier reason if isModifier = true\",\n            key=\"eld-18\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_19_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('^[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\.[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\[x\\\\])?(\\\\:[^\\\\s\\\\.]+)?)*$')\",\n            human=\"Element names cannot include some special characters\",\n            key=\"eld-19\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_20_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('^[A-Za-z][A-Za-z0-9]*(\\\\.[a-z][A-Za-z0-9]*(\\\\[x])?)*$')\",\n            human=\"Element names should be simple alphanumerics with a max of 64 characters, or code generation tools may be broken\",\n            key=\"eld-20\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_22_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceIsConstraining.exists() implies sliceName.exists()\",\n            human=\"sliceIsConstraining can only appear if slicename is present\",\n            key=\"eld-22\",\n            severity=\"error\",\n        )\n\n    @property \n    def defaultValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"defaultValue\",\n        )\n    @property \n    def fixed(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"fixed\",\n        )\n    @property \n    def pattern(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"pattern\",\n        )\n    @property \n    def minValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"minValue\",\n        )\n    @property \n    def maxValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"maxValue\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Expression","title":"<code>Expression</code>","text":"<p>               Bases: <code>Element</code></p> <p>An expression that can be used to generate a value</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Expression(Element):\n    \"\"\"\n    An expression that can be used to generate a value\n    \"\"\"\n    description: typing.Optional[String] = Field(\n        description=\"Natural language description of the condition\",\n        default=None,\n    )\n    description_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for description extensions\",\n        default=None,\n        alias=\"_description\",\n    )\n    name: typing.Optional[Id] = Field(\n        description=\"Short name assigned to expression for reuse\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    language: Code = Field(\n        description=\"text/cql | text/fhirpath | application/x-fhir-query | text/cql-identifier | text/cql-expression | etc.\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    expression: typing.Optional[String] = Field(\n        description=\"Expression in specified language\",\n        default=None,\n    )\n    expression_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for expression extensions\",\n        default=None,\n        alias=\"_expression\",\n    )\n    reference: typing.Optional[Uri] = Field(\n        description=\"Where the expression is found\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    @field_validator(*('reference', 'expression', 'language', 'name', 'description', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_exp_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"expression.exists() or reference.exists()\",\n            human=\"An expression or a reference must be provided\",\n            key=\"exp-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>Element</code></p> <p>Optional Extensions Element</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Extension(Element):\n    \"\"\"\n    Optional Extensions Element\n    \"\"\"\n    url: String = Field(\n        description=\"identifies the meaning of the extension\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    valueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCode: typing.Optional[Code] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDate: typing.Optional[Date] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueId: typing.Optional[Id] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInstant: typing.Optional[Instant] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInteger: typing.Optional[Integer] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueOid: typing.Optional[Oid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueString: typing.Optional[String] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTime: typing.Optional[Time] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUri: typing.Optional[Uri] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUrl: typing.Optional[Url] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUuid: typing.Optional[Uuid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAddress: typing.Optional['Address'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAge: typing.Optional['Age'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAnnotation: typing.Optional['Annotation'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAttachment: typing.Optional['Attachment'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCodeableReference: typing.Optional['CodeableReference'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCoding: typing.Optional['Coding'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactPoint: typing.Optional['ContactPoint'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCount: typing.Optional['Count'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDistance: typing.Optional['Distance'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDuration: typing.Optional['Duration'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueHumanName: typing.Optional['HumanName'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueIdentifier: typing.Optional['Identifier'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMoney: typing.Optional['Money'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePeriod: typing.Optional['Period'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueQuantity: typing.Optional['Quantity'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRange: typing.Optional['Range'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRatio: typing.Optional['Ratio'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRatioRange: typing.Optional['RatioRange'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueReference: typing.Optional['Reference'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSampledData: typing.Optional['SampledData'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSignature: typing.Optional['Signature'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTiming: typing.Optional['Timing'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactDetail: typing.Optional['ContactDetail'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContributor: typing.Optional['Contributor'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDataRequirement: typing.Optional['DataRequirement'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueExpression: typing.Optional['Expression'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueParameterDefinition: typing.Optional['ParameterDefinition'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRelatedArtifact: typing.Optional['RelatedArtifact'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTriggerDefinition: typing.Optional['TriggerDefinition'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUsageContext: typing.Optional['UsageContext'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDosage: typing.Optional['Dosage'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'CodeableReference', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'RatioRange', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'],\n            field_name_base=\"value\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ext_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.HumanName","title":"<code>HumanName</code>","text":"<p>               Bases: <code>Element</code></p> <p>Name of a human - parts and usage</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class HumanName(Element):\n    \"\"\"\n    Name of a human - parts and usage\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | nickname | anonymous | old | maiden\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the full name\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    family: typing.Optional[String] = Field(\n        description=\"Family name (often called \\u0027Surname\\u0027)\",\n        default=None,\n    )\n    family_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for family extensions\",\n        default=None,\n        alias=\"_family\",\n    )\n    given: typing.Optional[typing.List[String]] = Field(\n        description=\"Given names (not always \\u0027first\\u0027). Includes middle names\",\n        default=None,\n    )\n    given_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for given extensions\",\n        default=None,\n        alias=\"_given\",\n    )\n    prefix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come before the name\",\n        default=None,\n    )\n    prefix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for prefix extensions\",\n        default=None,\n        alias=\"_prefix\",\n    )\n    suffix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come after the name\",\n        default=None,\n    )\n    suffix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for suffix extensions\",\n        default=None,\n        alias=\"_suffix\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when name was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'suffix', 'prefix', 'given', 'family', 'text', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Identifier","title":"<code>Identifier</code>","text":"<p>               Bases: <code>Element</code></p> <p>An identifier intended for computation</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Identifier(Element):\n    \"\"\"\n    An identifier intended for computation\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | secondary | old (If known)\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional['CodeableConcept'] = Field(\n        description=\"Description of identifier\",\n        default=None,\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"The namespace for the identifier value\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The value that is unique\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    period: typing.Optional['Period'] = Field(\n        description=\"Time period when id is/was valid for use\",\n        default=None,\n    )\n    assigner: typing.Optional['Reference'] = Field(\n        description=\"Organization that issued id (may be just text)\",\n        default=None,\n    )\n    @field_validator(*('assigner', 'period', 'value', 'system', 'type', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.MarketingStatus","title":"<code>MarketingStatus</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class MarketingStatus(BackboneElement):\n    \"\"\"\n    The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available\n    \"\"\"\n    country: typing.Optional['CodeableConcept'] = Field(\n        description=\"The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 \\u2011 1 alpha-2 code elements\",\n        default=None,\n    )\n    jurisdiction: typing.Optional['CodeableConcept'] = Field(\n        description=\"Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    status: 'CodeableConcept' = Field(\n        description=\"This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples\",\n        default=None,\n    )\n    dateRange: typing.Optional['Period'] = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate: typing.Optional[DateTime] = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for restoreDate extensions\",\n        default=None,\n        alias=\"_restoreDate\",\n    )\n    @field_validator(*('restoreDate', 'dateRange', 'status', 'jurisdiction', 'country', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>Element</code></p> <p>Metadata about a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Meta(Element):\n    \"\"\"\n    Metadata about a resource\n    \"\"\"\n    versionId: typing.Optional[Id] = Field(\n        description=\"Version specific identifier\",\n        default=None,\n    )\n    versionId_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for versionId extensions\",\n        default=None,\n        alias=\"_versionId\",\n    )\n    lastUpdated: typing.Optional[Instant] = Field(\n        description=\"When the resource version last changed\",\n        default=None,\n    )\n    lastUpdated_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lastUpdated extensions\",\n        default=None,\n        alias=\"_lastUpdated\",\n    )\n    source: typing.Optional[Uri] = Field(\n        description=\"Identifies where the resource comes from\",\n        default=None,\n    )\n    source_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for source extensions\",\n        default=None,\n        alias=\"_source\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"Profiles this resource claims to conform to\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    security: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Security Labels applied to this resource\",\n        default=None,\n    )\n    tag: typing.Optional[typing.List['Coding']] = Field(\n        description=\"Tags applied to this resource\",\n        default=None,\n    )\n    @field_validator(*('tag', 'security', 'profile', 'source', 'lastUpdated', 'versionId', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Money","title":"<code>Money</code>","text":"<p>               Bases: <code>Element</code></p> <p>An amount of economic utility in some recognized currency</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Money(Element):\n    \"\"\"\n    An amount of economic utility in some recognized currency\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    currency: typing.Optional[Code] = Field(\n        description=\"ISO 4217 Currency Code\",\n        default=None,\n    )\n    currency_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for currency extensions\",\n        default=None,\n        alias=\"_currency\",\n    )\n    @field_validator(*('currency', 'value', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.MoneyQuantity","title":"<code>MoneyQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>An amount of money. With regard to precision, see Decimal Precision</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class MoneyQuantity(Quantity):\n    \"\"\"\n    An amount of money. With regard to precision, see [Decimal Precision](datatypes.html#precision)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_mqty_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = 'urn:iso:std:iso:4217')\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of currency.  If system is present, it SHALL be ISO 4217 (system = \\\"urn:iso:std:iso:4217\\\" - currency).\",\n            key=\"mqty-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Narrative","title":"<code>Narrative</code>","text":"<p>               Bases: <code>Element</code></p> <p>Human-readable summary of the resource (essential clinical and business information)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Narrative(Element):\n    \"\"\"\n    Human-readable summary of the resource (essential clinical and business information)\n    \"\"\"\n    status: Code = Field(\n        description=\"generated | extensions | additional | empty\",\n        default=None,\n    )\n    status_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for status extensions\",\n        default=None,\n        alias=\"_status\",\n    )\n    div: str = Field(\n        description=\"Limited xhtml content\",\n        default=None,\n    )\n    @field_validator(*('div', 'status', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL contain only the basic html formatting elements and attributes described in chapters 7-11 (except section 4 of chapter 9) and 15 of the HTML 4.0 standard, &lt;a&gt; elements (either name or href), images and internally contained style attributes\",\n            key=\"txt-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL have some non-whitespace content\",\n            key=\"txt-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ParameterDefinition","title":"<code>ParameterDefinition</code>","text":"<p>               Bases: <code>Element</code></p> <p>Definition of a parameter to a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ParameterDefinition(Element):\n    \"\"\"\n    Definition of a parameter to a module\n    \"\"\"\n    name: typing.Optional[Code] = Field(\n        description=\"Name used to access the parameter value\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    use: Code = Field(\n        description=\"in | out\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    min: typing.Optional[Integer] = Field(\n        description=\"Minimum cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum cardinality (a number of *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    documentation: typing.Optional[String] = Field(\n        description=\"A brief description of the parameter\",\n        default=None,\n    )\n    documentation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for documentation extensions\",\n        default=None,\n        alias=\"_documentation\",\n    )\n    type: Code = Field(\n        description=\"What type of value\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[Canonical] = Field(\n        description=\"What profile the value is expected to be\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    @field_validator(*('profile', 'type', 'documentation', 'max', 'min', 'use', 'name', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>Element</code></p> <p>Time range defined by start and end date/time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Period(Element):\n    \"\"\"\n    Time range defined by start and end date/time\n    \"\"\"\n    start: typing.Optional[DateTime] = Field(\n        description=\"Starting time with inclusive boundary\",\n        default=None,\n    )\n    start_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for start extensions\",\n        default=None,\n        alias=\"_start\",\n    )\n    end: typing.Optional[DateTime] = Field(\n        description=\"End time with inclusive boundary, if not ongoing\",\n        default=None,\n    )\n    end_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for end extensions\",\n        default=None,\n        alias=\"_end\",\n    )\n    @field_validator(*('end', 'start', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_per_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"start.hasValue().not() or end.hasValue().not() or (start &lt;= end)\",\n            human=\"If present, start SHALL have a lower value than end\",\n            key=\"per-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Population","title":"<code>Population</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Population(BackboneElement):\n    \"\"\"\n    A definition of a set of people that apply to some clinically related context, for example people contraindicated for a certain medication\n    \"\"\"\n    ageRange: typing.Optional['Range'] = Field(\n        description=\"The age of the specific population\",\n        default=None,\n    )\n    ageCodeableConcept: typing.Optional['CodeableConcept'] = Field(\n        description=\"The age of the specific population\",\n        default=None,\n    )\n    gender: typing.Optional['CodeableConcept'] = Field(\n        description=\"The gender of the specific population\",\n        default=None,\n    )\n    race: typing.Optional['CodeableConcept'] = Field(\n        description=\"Race of the specific population\",\n        default=None,\n    )\n    physiologicalCondition: typing.Optional['CodeableConcept'] = Field(\n        description=\"The existing physiological conditions of the specific population to which this applies\",\n        default=None,\n    )\n    @field_validator(*('physiologicalCondition', 'race', 'gender', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def age_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Range', 'CodeableConcept'],\n            field_name_base=\"age\",\n        )\n\n    @property \n    def age(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"age\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ProdCharacteristic","title":"<code>ProdCharacteristic</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ProdCharacteristic(BackboneElement):\n    \"\"\"\n    The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available\n    \"\"\"\n    height: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    width: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    depth: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    weight: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    nominalVolume: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    externalDiameter: typing.Optional['Quantity'] = Field(\n        description=\"Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    shape: typing.Optional[String] = Field(\n        description=\"Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    shape_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for shape extensions\",\n        default=None,\n        alias=\"_shape\",\n    )\n    color: typing.Optional[typing.List[String]] = Field(\n        description=\"Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    color_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for color extensions\",\n        default=None,\n        alias=\"_color\",\n    )\n    imprint: typing.Optional[typing.List[String]] = Field(\n        description=\"Where applicable, the imprint can be specified as text\",\n        default=None,\n    )\n    imprint_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for imprint extensions\",\n        default=None,\n        alias=\"_imprint\",\n    )\n    image: typing.Optional[typing.List['Attachment']] = Field(\n        description=\"Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations\",\n        default=None,\n    )\n    scoring: typing.Optional['CodeableConcept'] = Field(\n        description=\"Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used\",\n        default=None,\n    )\n    @field_validator(*('scoring', 'image', 'imprint', 'color', 'shape', 'externalDiameter', 'nominalVolume', 'weight', 'depth', 'width', 'height', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.ProductShelfLife","title":"<code>ProductShelfLife</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>The shelf-life and storage information for a medicinal product item or container can be described using this class</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class ProductShelfLife(BackboneElement):\n    \"\"\"\n    The shelf-life and storage information for a medicinal product item or container can be described using this class\n    \"\"\"\n    identifier: typing.Optional['Identifier'] = Field(\n        description=\"Unique identifier for the packaged Medicinal Product\",\n        default=None,\n    )\n    type: 'CodeableConcept' = Field(\n        description=\"This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    period: 'Quantity' = Field(\n        description=\"The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    specialPrecautionsForStorage: typing.Optional[typing.List['CodeableConcept']] = Field(\n        description=\"Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    @field_validator(*('specialPrecautionsForStorage', 'period', 'type', 'identifier', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Quantity","title":"<code>Quantity</code>","text":"<p>               Bases: <code>Element</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Quantity(Element):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>Element</code></p> <p>Set of values bounded by low and high</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Range(Element):\n    \"\"\"\n    Set of values bounded by low and high\n    \"\"\"\n    low: typing.Optional['Quantity'] = Field(\n        description=\"Low limit\",\n        default=None,\n    )\n    high: typing.Optional['Quantity'] = Field(\n        description=\"High limit\",\n        default=None,\n    )\n    @field_validator(*('high', 'low', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rng_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"low.empty() or high.empty() or (low &lt;= high)\",\n            human=\"If present, low SHALL have a lower value than high\",\n            key=\"rng-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Ratio","title":"<code>Ratio</code>","text":"<p>               Bases: <code>Element</code></p> <p>A ratio of two Quantity values - a numerator and a denominator</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Ratio(Element):\n    \"\"\"\n    A ratio of two Quantity values - a numerator and a denominator\n    \"\"\"\n    numerator: typing.Optional['Quantity'] = Field(\n        description=\"Numerator value\",\n        default=None,\n    )\n    denominator: typing.Optional['Quantity'] = Field(\n        description=\"Denominator value\",\n        default=None,\n    )\n    @field_validator(*('denominator', 'numerator', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rat_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(numerator.exists() and denominator.exists()) or (numerator.empty() and denominator.empty() and extension.exists())\",\n            human=\"Numerator and denominator SHALL both be present, or both are absent. If both are absent, there SHALL be some extension present\",\n            key=\"rat-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.RatioRange","title":"<code>RatioRange</code>","text":"<p>               Bases: <code>Element</code></p> <p>Range of ratio values</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class RatioRange(Element):\n    \"\"\"\n    Range of ratio values\n    \"\"\"\n    lowNumerator: typing.Optional['Quantity'] = Field(\n        description=\"Low Numerator limit\",\n        default=None,\n    )\n    highNumerator: typing.Optional['Quantity'] = Field(\n        description=\"High Numerator limit\",\n        default=None,\n    )\n    denominator: typing.Optional['Quantity'] = Field(\n        description=\"Denominator value\",\n        default=None,\n    )\n    @field_validator(*('denominator', 'highNumerator', 'lowNumerator', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_inv_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"((lowNumerator.exists() or highNumerator.exists()) and denominator.exists()) or (lowNumerator.empty() and highNumerator.empty() and denominator.empty() and extension.exists())\",\n            human=\"One of lowNumerator or highNumerator and denominator SHALL be present, or all are absent. If all are absent, there SHALL be some extension present\",\n            key=\"inv-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_inv_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"lowNumerator.empty() or highNumerator.empty() or (lowNumerator &lt;= highNumerator)\",\n            human=\"If present, lowNumerator SHALL have a lower value than highNumerator\",\n            key=\"inv-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Reference","title":"<code>Reference</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference from one resource to another</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Reference(Element):\n    \"\"\"\n    A reference from one resource to another\n    \"\"\"\n    reference: typing.Optional[String] = Field(\n        description=\"Literal reference, Relative, internal or absolute URL\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    type: typing.Optional[Uri] = Field(\n        description=\"Type the reference refers to (e.g. \\\"Patient\\\")\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    identifier: typing.Optional['Identifier'] = Field(\n        description=\"Logical reference, when literal reference is not known\",\n        default=None,\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Text alternative for the resource\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    @field_validator(*('display', 'identifier', 'type', 'reference', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ref_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"reference.startsWith('#').not() or (reference.substring(1).trace('url') in %rootResource.contained.id.trace('ids')) or (reference='#' and %rootResource!=%resource)\",\n            human=\"SHALL have a contained resource if a local reference is provided\",\n            key=\"ref-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.RelatedArtifact","title":"<code>RelatedArtifact</code>","text":"<p>               Bases: <code>Element</code></p> <p>Related artifacts for a knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class RelatedArtifact(Element):\n    \"\"\"\n    Related artifacts for a knowledge resource\n    \"\"\"\n    type: Code = Field(\n        description=\"documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Short label\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Brief description of the related artifact\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    citation: typing.Optional[Markdown] = Field(\n        description=\"Bibliographic citation for the artifact\",\n        default=None,\n    )\n    citation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for citation extensions\",\n        default=None,\n        alias=\"_citation\",\n    )\n    url: typing.Optional[Url] = Field(\n        description=\"Where the artifact can be accessed\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    document: typing.Optional['Attachment'] = Field(\n        description=\"What document is being referenced\",\n        default=None,\n    )\n    resource: typing.Optional[Canonical] = Field(\n        description=\"What resource is being referenced\",\n        default=None,\n    )\n    resource_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for resource extensions\",\n        default=None,\n        alias=\"_resource\",\n    )\n    @field_validator(*('resource', 'document', 'url', 'citation', 'display', 'label', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Resource","title":"<code>Resource</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base Resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Resource(FHIRBaseModel):\n    \"\"\"\n    Base Resource\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Logical id of this artifact\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    meta: typing.Optional['Meta'] = Field(\n        description=\"Metadata about the resource\",\n        default=None,\n    )\n    implicitRules: typing.Optional[Uri] = Field(\n        description=\"A set of rules under which this content was created\",\n        default=None,\n    )\n    implicitRules_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for implicitRules extensions\",\n        default=None,\n        alias=\"_implicitRules\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Language of the resource content\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    @field_validator(*('language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.SampledData","title":"<code>SampledData</code>","text":"<p>               Bases: <code>Element</code></p> <p>A series of measurements taken by a device</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class SampledData(Element):\n    \"\"\"\n    A series of measurements taken by a device\n    \"\"\"\n    origin: 'Quantity' = Field(\n        description=\"Zero value and units\",\n        default=None,\n    )\n    period: Decimal = Field(\n        description=\"Number of milliseconds between samples\",\n        default=None,\n    )\n    period_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for period extensions\",\n        default=None,\n        alias=\"_period\",\n    )\n    factor: typing.Optional[Decimal] = Field(\n        description=\"Multiply data by this before adding to origin\",\n        default=None,\n    )\n    factor_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for factor extensions\",\n        default=None,\n        alias=\"_factor\",\n    )\n    lowerLimit: typing.Optional[Decimal] = Field(\n        description=\"Lower limit of detection\",\n        default=None,\n    )\n    lowerLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lowerLimit extensions\",\n        default=None,\n        alias=\"_lowerLimit\",\n    )\n    upperLimit: typing.Optional[Decimal] = Field(\n        description=\"Upper limit of detection\",\n        default=None,\n    )\n    upperLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for upperLimit extensions\",\n        default=None,\n        alias=\"_upperLimit\",\n    )\n    dimensions: PositiveInt = Field(\n        description=\"Number of sample points at each time point\",\n        default=None,\n    )\n    dimensions_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for dimensions extensions\",\n        default=None,\n        alias=\"_dimensions\",\n    )\n    data: typing.Optional[String] = Field(\n        description=\"Decimal values with spaces, or \\\"E\\\" | \\\"U\\\" | \\\"L\\\"\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'dimensions', 'upperLimit', 'lowerLimit', 'factor', 'period', 'origin', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Signature","title":"<code>Signature</code>","text":"<p>               Bases: <code>Element</code></p> <p>A Signature - XML DigSig, JWS, Graphical image of signature, etc.</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Signature(Element):\n    \"\"\"\n    A Signature - XML DigSig, JWS, Graphical image of signature, etc.\n    \"\"\"\n    type: typing.List['Coding'] = Field(\n        description=\"Indication of the reason the entity signed the object(s)\",\n        default=None,\n    )\n    when: Instant = Field(\n        description=\"When the signature was created\",\n        default=None,\n    )\n    when_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for when extensions\",\n        default=None,\n        alias=\"_when\",\n    )\n    who: 'Reference' = Field(\n        description=\"Who signed\",\n        default=None,\n    )\n    onBehalfOf: typing.Optional['Reference'] = Field(\n        description=\"The party represented\",\n        default=None,\n    )\n    targetFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signed resources\",\n        default=None,\n    )\n    targetFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for targetFormat extensions\",\n        default=None,\n        alias=\"_targetFormat\",\n    )\n    sigFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signature\",\n        default=None,\n    )\n    sigFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sigFormat extensions\",\n        default=None,\n        alias=\"_sigFormat\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"The actual signature content (XML DigSig. JWS, picture, etc.)\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'sigFormat', 'targetFormat', 'onBehalfOf', 'who', 'when', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.SimpleQuantity","title":"<code>SimpleQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A fixed quantity (no comparator)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class SimpleQuantity(Quantity):\n    \"\"\"\n    A fixed quantity (no comparator)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_sqty_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"comparator.empty()\",\n            human=\"The comparator is not used on a SimpleQuantity\",\n            key=\"sqty-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.Timing","title":"<code>Timing</code>","text":"<p>               Bases: <code>BackboneElement</code></p> <p>A timing schedule that specifies an event that may occur multiple times</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class Timing(BackboneElement):\n    \"\"\"\n    A timing schedule that specifies an event that may occur multiple times\n    \"\"\"\n    event: typing.Optional[typing.List[DateTime]] = Field(\n        description=\"When the event occurs\",\n        default=None,\n    )\n    event_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for event extensions\",\n        default=None,\n        alias=\"_event\",\n    )\n    repeat: typing.Optional['Element'] = Field(\n        description=\"When the event is to occur\",\n        default=None,\n    )\n    code: typing.Optional['CodeableConcept'] = Field(\n        description=\"BID | TID | QID | AM | PM | QD | QOD | +\",\n        default=None,\n    )\n    @field_validator(*('code', 'repeat', 'event', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.empty() or durationUnit.exists()\",\n            human=\"if there's a duration, there needs to be duration units\",\n            key=\"tim-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.empty() or periodUnit.exists()\",\n            human=\"if there's a period, there needs to be period units\",\n            key=\"tim-2\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.exists() implies duration &gt;= 0\",\n            human=\"duration SHALL be a non-negative value\",\n            key=\"tim-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_5_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.exists() implies period &gt;= 0\",\n            human=\"period SHALL be a non-negative value\",\n            key=\"tim-5\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_6_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"periodMax.empty() or period.exists()\",\n            human=\"If there's a periodMax, there must be a period\",\n            key=\"tim-6\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_7_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"durationMax.empty() or duration.exists()\",\n            human=\"If there's a durationMax, there must be a duration\",\n            key=\"tim-7\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_8_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"countMax.empty() or count.exists()\",\n            human=\"If there's a countMax, there must be a count\",\n            key=\"tim-8\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_9_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"offset.empty() or (when.exists() and ((when in ('C' | 'CM' | 'CD' | 'CV')).not()))\",\n            human=\"If there's an offset, there must be a when (and not C, CM, CD, CV)\",\n            key=\"tim-9\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_10_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"timeOfDay.empty() or when.empty()\",\n            human=\"If there's a timeOfDay, there cannot be a when, or vice versa\",\n            key=\"tim-10\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.TriggerDefinition","title":"<code>TriggerDefinition</code>","text":"<p>               Bases: <code>Element</code></p> <p>Defines an expected trigger for a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class TriggerDefinition(Element):\n    \"\"\"\n    Defines an expected trigger for a module\n    \"\"\"\n    type: Code = Field(\n        description=\"named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: typing.Optional[String] = Field(\n        description=\"Name or URI that identifies the event\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    timingTiming: typing.Optional['Timing'] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingReference: typing.Optional['Reference'] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDate: typing.Optional[Date] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDateTime: typing.Optional[DateTime] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    data: typing.Optional[typing.List['DataRequirement']] = Field(\n        description=\"Triggering data of the event (multiple = \\u0027and\\u0027)\",\n        default=None,\n    )\n    condition: typing.Optional['Expression'] = Field(\n        description=\"Whether the event triggers (boolean expression)\",\n        default=None,\n    )\n    @field_validator(*('condition', 'data', 'name', 'type', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def timing_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['Timing', 'Reference', Date, DateTime],\n            field_name_base=\"timing\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or timing.empty()\",\n            human=\"Either timing, or a data requirement, but not both\",\n            key=\"trd-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"condition.exists() implies data.exists()\",\n            human=\"A condition only if there is a data requirement\",\n            key=\"trd-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(type = 'named-event' implies name.exists()) and (type = 'periodic' implies timing.exists()) and (type.startsWith('data-') implies data.exists())\",\n            human=\"A named event requires a name, a periodic event requires timing, and a data event requires data\",\n            key=\"trd-3\",\n            severity=\"error\",\n        )\n\n    @property \n    def timing(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"timing\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.UsageContext","title":"<code>UsageContext</code>","text":"<p>               Bases: <code>Element</code></p> <p>Describes the context of use for a conformance or knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class UsageContext(Element):\n    \"\"\"\n    Describes the context of use for a conformance or knowledge resource\n    \"\"\"\n    code: 'Coding' = Field(\n        description=\"Type of context being specified\",\n        default=None,\n    )\n    valueCodeableConcept: 'CodeableConcept' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueQuantity: 'Quantity' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueRange: 'Range' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueReference: 'Reference' = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    @field_validator(*('code', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count()) or $this is Parameters\",\n            human=\"All FHIR elements must have a @value or children unless an empty Parameters resource\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=['CodeableConcept', 'Quantity', 'Range', 'Reference'],\n            field_name_base=\"value\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R4B/complex_types/#fhircraft.fhir.resources.datatypes.R4B.complex_types.xhtml","title":"<code>xhtml</code>","text":"<p>               Bases: <code>Element</code></p> <p>Primitive Type xhtml</p> Source code in <code>fhircraft/fhir/resources/datatypes/R4B/complex_types.py</code> <pre><code>class xhtml(Element):\n    \"\"\"\n    Primitive Type xhtml\n    \"\"\"\n    value: String = Field(\n        description=\"Actual xhtml\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/","title":"Complex types","text":""},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>Element</code></p> <p>An address expressed using postal conventions (as opposed to GPS or other location definition formats)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Address(Element):\n    \"\"\"\n    An address expressed using postal conventions (as opposed to GPS or other location definition formats)\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | billing - purpose of this address\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional[Code] = Field(\n        description=\"postal | physical | both\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the address\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    line: typing.Optional[typing.List[String]] = Field(\n        description=\"Street name, number, direction \\u0026 P.O. Box etc.\",\n        default=None,\n    )\n    line_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for line extensions\",\n        default=None,\n        alias=\"_line\",\n    )\n    city: typing.Optional[String] = Field(\n        description=\"Name of city, town etc.\",\n        default=None,\n    )\n    city_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for city extensions\",\n        default=None,\n        alias=\"_city\",\n    )\n    district: typing.Optional[String] = Field(\n        description=\"District name (aka county)\",\n        default=None,\n    )\n    district_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for district extensions\",\n        default=None,\n        alias=\"_district\",\n    )\n    state: typing.Optional[String] = Field(\n        description=\"Sub-unit of country (abbreviations ok)\",\n        default=None,\n    )\n    state_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for state extensions\",\n        default=None,\n        alias=\"_state\",\n    )\n    postalCode: typing.Optional[String] = Field(\n        description=\"Postal code for area\",\n        default=None,\n    )\n    postalCode_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for postalCode extensions\",\n        default=None,\n        alias=\"_postalCode\",\n    )\n    country: typing.Optional[String] = Field(\n        description=\"Country (e.g. may be ISO 3166 2 or 3 letter code)\",\n        default=None,\n    )\n    country_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for country extensions\",\n        default=None,\n        alias=\"_country\",\n    )\n    period: typing.Optional[\"Period\"] = Field(\n        description=\"Time period when address was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'country', 'postalCode', 'state', 'district', 'city', 'line', 'text', 'type', 'use', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Age","title":"<code>Age</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A duration of time during which an organism (or a process) has existed</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Age(Quantity):\n    \"\"\"\n    A duration of time during which an organism (or a process) has existed\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_age_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (value.empty() or value.hasValue().not() or value &gt; 0)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.  If value is present, it SHALL be positive.\",\n            key=\"age-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Annotation","title":"<code>Annotation</code>","text":"<p>               Bases: <code>Element</code></p> <p>Text node with attribution</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Annotation(Element):\n    \"\"\"\n    Text node with attribution\n    \"\"\"\n    authorReference: typing.Optional[\"Reference\"] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    authorString: typing.Optional[String] = Field(\n        description=\"Individual responsible for the annotation\",\n        default=None,\n    )\n    time: typing.Optional[DateTime] = Field(\n        description=\"When the annotation was made\",\n        default=None,\n    )\n    time_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for time extensions\",\n        default=None,\n        alias=\"_time\",\n    )\n    text: Markdown = Field(\n        description=\"The annotation  - text content (as markdown)\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'time', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def author_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Reference, String],\n            field_name_base=\"author\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @property \n    def author(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"author\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>Element</code></p> <p>Content in a format defined elsewhere</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Attachment(Element):\n    \"\"\"\n    Content in a format defined elsewhere\n    \"\"\"\n    contentType: typing.Optional[Code] = Field(\n        description=\"Mime type of the content, with charset etc.\",\n        default=None,\n    )\n    contentType_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentType extensions\",\n        default=None,\n        alias=\"_contentType\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Human language of the content (BCP-47)\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"Data inline, base64ed\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    url: typing.Optional[Url] = Field(\n        description=\"Uri where the data can be found\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    size: typing.Optional[Integer64] = Field(\n        description=\"Number of bytes of content (if url provided)\",\n        default=None,\n    )\n    size_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for size extensions\",\n        default=None,\n        alias=\"_size\",\n    )\n    hash: typing.Optional[Base64Binary] = Field(\n        description=\"Hash of the data (sha-1, base64ed)\",\n        default=None,\n    )\n    hash_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for hash extensions\",\n        default=None,\n        alias=\"_hash\",\n    )\n    title: typing.Optional[String] = Field(\n        description=\"Label to display in place of the data\",\n        default=None,\n    )\n    title_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for title extensions\",\n        default=None,\n        alias=\"_title\",\n    )\n    creation: typing.Optional[DateTime] = Field(\n        description=\"Date attachment was first created\",\n        default=None,\n    )\n    creation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for creation extensions\",\n        default=None,\n        alias=\"_creation\",\n    )\n    height: typing.Optional[PositiveInt] = Field(\n        description=\"Height of the image in pixels (photo/video)\",\n        default=None,\n    )\n    height_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for height extensions\",\n        default=None,\n        alias=\"_height\",\n    )\n    width: typing.Optional[PositiveInt] = Field(\n        description=\"Width of the image in pixels (photo/video)\",\n        default=None,\n    )\n    width_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for width extensions\",\n        default=None,\n        alias=\"_width\",\n    )\n    frames: typing.Optional[PositiveInt] = Field(\n        description=\"Number of frames if \\u003e 1 (photo)\",\n        default=None,\n    )\n    frames_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for frames extensions\",\n        default=None,\n        alias=\"_frames\",\n    )\n    duration: typing.Optional[Decimal] = Field(\n        description=\"Length in seconds (audio / video)\",\n        default=None,\n    )\n    duration_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for duration extensions\",\n        default=None,\n        alias=\"_duration\",\n    )\n    pages: typing.Optional[PositiveInt] = Field(\n        description=\"Number of printed pages\",\n        default=None,\n    )\n    pages_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for pages extensions\",\n        default=None,\n        alias=\"_pages\",\n    )\n    @field_validator(*('pages', 'duration', 'frames', 'width', 'height', 'creation', 'title', 'hash', 'size', 'url', 'data', 'language', 'contentType', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_att_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or contentType.exists()\",\n            human=\"If the Attachment has data, it SHALL have a contentType\",\n            key=\"att-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Availability","title":"<code>Availability</code>","text":"<p>               Bases: <code>Element</code></p> <p>Availability data for an {item}</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Availability(Element):\n    \"\"\"\n    Availability data for an {item}\n    \"\"\"\n    availableTime: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Times the {item} is available\",\n        default=None,\n    )\n    notAvailableTime: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Not available during this time due to provided reason\",\n        default=None,\n    )\n    @field_validator(*('notAvailableTime', 'availableTime', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('availableTime',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_av_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"allDay.exists().not() or (allDay implies availableStartTime.exists().not() and availableEndTime.exists().not())\",\n            human=\"Cannot include start/end times when selecting all day availability.\",\n            key=\"av-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.BackboneElement","title":"<code>BackboneElement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Base for elements defined inside a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class BackboneElement(Element):\n    \"\"\"\n    Base for elements defined inside a resource\n    \"\"\"\n    modifierExtension: typing.Optional[typing.List[\"Extension\"]] = Field(\n        description=\"Extensions that cannot be ignored even if unrecognized\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.BackboneType","title":"<code>BackboneType</code>","text":"<p>               Bases: <code>Element</code></p> <p>Base for datatypes that can carry modifier extensions</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class BackboneType(Element):\n    \"\"\"\n    Base for datatypes that can carry modifier extensions\n    \"\"\"\n    modifierExtension: typing.Optional[typing.List[\"Extension\"]] = Field(\n        description=\"Extensions that cannot be ignored even if unrecognized\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Base","title":"<code>Base</code>","text":"<p>               Bases: <code>FHIRBaseModel</code></p> <p>Base for all types and resources</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Base(FHIRBaseModel):\n    \"\"\"\n    Base for all types and resources\n    \"\"\"\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.CodeableConcept","title":"<code>CodeableConcept</code>","text":"<p>               Bases: <code>Element</code></p> <p>Concept - reference to a terminology or just  text</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class CodeableConcept(Element):\n    \"\"\"\n    Concept - reference to a terminology or just  text\n    \"\"\"\n    coding: typing.Optional[typing.List[\"Coding\"]] = Field(\n        description=\"Code defined by a terminology system\",\n        default=None,\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Plain text representation of the concept\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    @field_validator(*('text', 'coding', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.CodeableReference","title":"<code>CodeableReference</code>","text":"<p>               Bases: <code>Element</code></p> <p>Reference to a resource or a concept</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class CodeableReference(Element):\n    \"\"\"\n    Reference to a resource or a concept\n    \"\"\"\n    concept: typing.Optional[CodeableConcept] = Field(\n        description=\"Reference to a concept (by class)\",\n        default=None,\n    )\n    reference: typing.Optional[\"Reference\"] = Field(\n        description=\"Reference to a resource (by instance)\",\n        default=None,\n    )\n    @field_validator(*('reference', 'concept', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Coding","title":"<code>Coding</code>","text":"<p>               Bases: <code>Element</code></p> <p>A reference to a code defined by a terminology system</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Coding(Element):\n    \"\"\"\n    A reference to a code defined by a terminology system\n    \"\"\"\n    system: typing.Optional[Uri] = Field(\n        description=\"Identity of the terminology system\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    version: typing.Optional[String] = Field(\n        description=\"Version of the system - if relevant\",\n        default=None,\n    )\n    version_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for version extensions\",\n        default=None,\n        alias=\"_version\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Symbol in syntax defined by the system\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Representation defined by the system\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    userSelected: typing.Optional[Boolean] = Field(\n        description=\"If this coding was chosen directly by the user\",\n        default=None,\n    )\n    userSelected_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for userSelected extensions\",\n        default=None,\n        alias=\"_userSelected\",\n    )\n    @field_validator(*('userSelected', 'display', 'code', 'version', 'system', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cod_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.exists().not() implies display.exists().not()\",\n            human=\"A Coding SHOULD NOT have a display unless a code is also present.  Computation on Coding.display alone is generally unsafe.  Consider using CodeableConcept.text\",\n            key=\"cod-1\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ContactDetail","title":"<code>ContactDetail</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contact information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ContactDetail(Element):\n    \"\"\"\n    Contact information\n    \"\"\"\n    name: typing.Optional[String] = Field(\n        description=\"Name of an individual to contact\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    telecom: typing.Optional[typing.List[\"ContactPoint\"]] = Field(\n        description=\"Contact details for individual or organization\",\n        default=None,\n    )\n    @field_validator(*('telecom', 'name', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ContactPoint","title":"<code>ContactPoint</code>","text":"<p>               Bases: <code>Element</code></p> <p>Details of a Technology mediated contact point (phone, fax, email, etc.)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ContactPoint(Element):\n    \"\"\"\n    Details of a Technology mediated contact point (phone, fax, email, etc.)\n    \"\"\"\n    system: typing.Optional[Code] = Field(\n        description=\"phone | fax | email | pager | url | sms | other\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The actual contact point details\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    use: typing.Optional[Code] = Field(\n        description=\"home | work | temp | old | mobile - purpose of this contact point\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    rank: typing.Optional[PositiveInt] = Field(\n        description=\"Specify preferred order of use (1 = highest)\",\n        default=None,\n    )\n    rank_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for rank extensions\",\n        default=None,\n        alias=\"_rank\",\n    )\n    period: typing.Optional[\"Period\"] = Field(\n        description=\"Time period when the contact point was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'rank', 'use', 'value', 'system', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_cpt_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"value.empty() or system.exists()\",\n            human=\"A system is required if a value is provided.\",\n            key=\"cpt-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Contributor","title":"<code>Contributor</code>","text":"<p>               Bases: <code>Element</code></p> <p>Contributor information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Contributor(Element):\n    \"\"\"\n    Contributor information\n    \"\"\"\n    type: Code = Field(\n        description=\"author | editor | reviewer | endorser\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: String = Field(\n        description=\"Who contributed the content\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    contact: typing.Optional[typing.List[ContactDetail]] = Field(\n        description=\"Contact details of the contributor\",\n        default=None,\n    )\n    @field_validator(*('contact', 'name', 'type', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Count","title":"<code>Count</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Count(Quantity):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    @model_validator(mode=\"after\")\n    def FHIR_cnt_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum) and (code.empty() or code = '1') and (value.empty() or value.hasValue().not() or value.toString().contains('.').not())\",\n            human=\"There SHALL be a code with a value of \\\"1\\\" if there is a value. If system is present, it SHALL be UCUM.  If present, the value SHALL be a whole number.\",\n            key=\"cnt-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.DataRequirement","title":"<code>DataRequirement</code>","text":"<p>               Bases: <code>Element</code></p> <p>Describes a required data item</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class DataRequirement(Element):\n    \"\"\"\n    Describes a required data item\n    \"\"\"\n    type: Code = Field(\n        description=\"The type of the required data\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"The profile of the required data\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    subjectCodeableConcept: typing.Optional[CodeableConcept] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    subjectReference: typing.Optional[\"Reference\"] = Field(\n        description=\"E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device\",\n        default=None,\n    )\n    mustSupport: typing.Optional[typing.List[String]] = Field(\n        description=\"Indicates specific structure elements that are referenced by the knowledge module\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    codeFilter: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"What codes are expected\",\n        default=None,\n    )\n    dateFilter: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"What dates/date ranges are expected\",\n        default=None,\n    )\n    valueFilter: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"What values are expected\",\n        default=None,\n    )\n    limit: typing.Optional[PositiveInt] = Field(\n        description=\"Number of results\",\n        default=None,\n    )\n    limit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for limit extensions\",\n        default=None,\n        alias=\"_limit\",\n    )\n    sort: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Order of the results\",\n        default=None,\n    )\n    @field_validator(*('sort', 'limit', 'valueFilter', 'dateFilter', 'codeFilter', 'mustSupport', 'profile', 'type', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('codeFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('dateFilter',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_drq_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"path.exists() xor searchParam.exists()\",\n            human=\"Either a path or a searchParam must be provided, but not both\",\n            key=\"drq-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def subject_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[CodeableConcept, Reference],\n            field_name_base=\"subject\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @property \n    def subject(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"subject\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.DataType","title":"<code>DataType</code>","text":"<p>               Bases: <code>Element</code></p> <p>Reuseable Types</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class DataType(Element):\n    \"\"\"\n    Reuseable Types\n    \"\"\"\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A length - a value with a unit that is a physical distance</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Distance(Quantity):\n    \"\"\"\n    A length - a value with a unit that is a physical distance\n    \"\"\"\n    @model_validator(mode=\"after\")\n    def FHIR_dis_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = %ucum)\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of length.  If system is present, it SHALL be UCUM.\",\n            key=\"dis-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.DomainResource","title":"<code>DomainResource</code>","text":"<p>               Bases: <code>Resource</code></p> <p>A resource with narrative, extensions, and contained resources</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class DomainResource(Resource):\n    \"\"\"\n    A resource with narrative, extensions, and contained resources\n    \"\"\"\n    text: typing.Optional[Narrative] = Field(\n        description=\"Text summary of the resource, for human interpretation\",\n        default=None,\n    )\n    contained: typing.Optional[typing.List[Resource]] = Field(\n        description=\"Contained, inline Resources\",\n        default=None,\n    )\n    extension: typing.Optional[typing.List[\"Extension\"]] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    modifierExtension: typing.Optional[typing.List[\"Extension\"]] = Field(\n        description=\"Extensions that cannot be ignored\",\n        default=None,\n    )\n    @field_validator(*('modifierExtension', 'extension', 'text', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta', 'language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.contained.empty()\",\n            human=\"If the resource is contained in another resource, it SHALL NOT contain nested Resources\",\n            key=\"dom-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.where((('#'+id in (%resource.descendants().reference | %resource.descendants().ofType(canonical) | %resource.descendants().ofType(uri) | %resource.descendants().ofType(url))) or descendants().where(reference = '#').exists() or descendants().where(ofType(canonical) = '#').exists() or descendants().where(ofType(canonical) = '#').exists()).not()).trace('unmatched', id).empty()\",\n            human=\"If the resource is contained in another resource, it SHALL be referred to from elsewhere in the resource or SHALL refer to the containing resource\",\n            key=\"dom-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_4_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.versionId.empty() and contained.meta.lastUpdated.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a meta.versionId or a meta.lastUpdated\",\n            key=\"dom-4\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contained.meta.security.empty()\",\n            human=\"If a resource is contained in another resource, it SHALL NOT have a security label\",\n            key=\"dom-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dom_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"text.`div`.exists()\",\n            human=\"A resource should have narrative for robust management\",\n            key=\"dom-6\",\n            severity=\"warning\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Dosage","title":"<code>Dosage</code>","text":"<p>               Bases: <code>BackboneType</code></p> <p>How the medication is/was taken or should be taken</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Dosage(BackboneType):\n    \"\"\"\n    How the medication is/was taken or should be taken\n    \"\"\"\n    sequence: typing.Optional[Integer] = Field(\n        description=\"The order of the dosage instructions\",\n        default=None,\n    )\n    sequence_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sequence extensions\",\n        default=None,\n        alias=\"_sequence\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Free text dosage instructions e.g. SIG\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    additionalInstruction: typing.Optional[typing.List[CodeableConcept]] = Field(\n        description=\"Supplemental instruction or warnings to the patient - e.g. \\\"with meals\\\", \\\"may cause drowsiness\\\"\",\n        default=None,\n    )\n    patientInstruction: typing.Optional[String] = Field(\n        description=\"Patient or consumer oriented instructions\",\n        default=None,\n    )\n    patientInstruction_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for patientInstruction extensions\",\n        default=None,\n        alias=\"_patientInstruction\",\n    )\n    timing: typing.Optional[\"Timing\"] = Field(\n        description=\"When medication should be administered\",\n        default=None,\n    )\n    asNeeded: typing.Optional[Boolean] = Field(\n        description=\"Take \\\"as needed\\\"\",\n        default=None,\n    )\n    asNeeded_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for asNeeded extensions\",\n        default=None,\n        alias=\"_asNeeded\",\n    )\n    asNeededFor: typing.Optional[typing.List[CodeableConcept]] = Field(\n        description=\"Take \\\"as needed\\\" (for x)\",\n        default=None,\n    )\n    site: typing.Optional[CodeableConcept] = Field(\n        description=\"Body site to administer to\",\n        default=None,\n    )\n    route: typing.Optional[CodeableConcept] = Field(\n        description=\"How drug should enter body\",\n        default=None,\n    )\n    method: typing.Optional[CodeableConcept] = Field(\n        description=\"Technique for administering medication\",\n        default=None,\n    )\n    doseAndRate: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Amount of medication administered, to be administered or typical amount to be administered\",\n        default=None,\n    )\n    maxDosePerPeriod: typing.Optional[typing.List[\"Ratio\"]] = Field(\n        description=\"Upper limit on medication per unit of time\",\n        default=None,\n    )\n    maxDosePerAdministration: typing.Optional[\"Quantity\"] = Field(\n        description=\"Upper limit on medication per administration\",\n        default=None,\n    )\n    maxDosePerLifetime: typing.Optional[\"Quantity\"] = Field(\n        description=\"Upper limit on medication per lifetime of the patient\",\n        default=None,\n    )\n    @field_validator(*('maxDosePerLifetime', 'maxDosePerAdministration', 'maxDosePerPeriod', 'doseAndRate', 'method', 'route', 'site', 'asNeededFor', 'asNeeded', 'timing', 'patientInstruction', 'additionalInstruction', 'text', 'sequence', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_dos_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"asNeededFor.empty() or asNeeded.empty() or asNeeded\",\n            human=\"AsNeededFor can only be set if AsNeeded is empty or true\",\n            key=\"dos-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A length of time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Duration(Quantity):\n    \"\"\"\n    A length of time\n    \"\"\"\n    @model_validator(mode=\"after\")\n    def FHIR_drt_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.exists() implies ((system = %ucum) and value.exists())\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of time.  If system is present, it SHALL be UCUM.\",\n            key=\"drt-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>Base</code></p> <p>Base for all elements</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Element(Base):\n    \"\"\"\n    Base for all elements\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Unique id for inter-element referencing\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    extension: typing.Optional[typing.List[\"Extension\"]] = Field(\n        description=\"Additional content defined by implementations\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ElementDefinition","title":"<code>ElementDefinition</code>","text":"<p>               Bases: <code>BackboneType</code></p> <p>Definition of an element in a resource or extension</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ElementDefinition(BackboneType):\n    \"\"\"\n    Definition of an element in a resource or extension\n    \"\"\"\n    path: String = Field(\n        description=\"Path of the element in the hierarchy of elements\",\n        default=None,\n    )\n    path_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for path extensions\",\n        default=None,\n        alias=\"_path\",\n    )\n    representation: typing.Optional[typing.List[Code]] = Field(\n        description=\"xmlAttr | xmlText | typeAttr | cdaText | xhtml\",\n        default=None,\n    )\n    representation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for representation extensions\",\n        default=None,\n        alias=\"_representation\",\n    )\n    sliceName: typing.Optional[String] = Field(\n        description=\"Name for this particular element (in a set of slices)\",\n        default=None,\n    )\n    sliceName_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceName extensions\",\n        default=None,\n        alias=\"_sliceName\",\n    )\n    sliceIsConstraining: typing.Optional[Boolean] = Field(\n        description=\"If this slice definition constrains an inherited slice definition (or not)\",\n        default=None,\n    )\n    sliceIsConstraining_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sliceIsConstraining extensions\",\n        default=None,\n        alias=\"_sliceIsConstraining\",\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Name for element to display with or prompt for element\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    code: typing.Optional[typing.List[Coding]] = Field(\n        description=\"Corresponding codes in terminologies\",\n        default=None,\n    )\n    slicing: typing.Optional[\"Element\"] = Field(\n        description=\"This element is sliced - slices follow\",\n        default=None,\n    )\n    short: typing.Optional[String] = Field(\n        description=\"Concise definition for space-constrained presentation\",\n        default=None,\n    )\n    short_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for short extensions\",\n        default=None,\n        alias=\"_short\",\n    )\n    definition: typing.Optional[Markdown] = Field(\n        description=\"Full formal definition as narrative text\",\n        default=None,\n    )\n    definition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for definition extensions\",\n        default=None,\n        alias=\"_definition\",\n    )\n    comment: typing.Optional[Markdown] = Field(\n        description=\"Comments about the use of this element\",\n        default=None,\n    )\n    comment_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comment extensions\",\n        default=None,\n        alias=\"_comment\",\n    )\n    requirements: typing.Optional[Markdown] = Field(\n        description=\"Why this resource has been created\",\n        default=None,\n    )\n    requirements_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for requirements extensions\",\n        default=None,\n        alias=\"_requirements\",\n    )\n    alias: typing.Optional[typing.List[String]] = Field(\n        description=\"Other names\",\n        default=None,\n    )\n    alias_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for alias extensions\",\n        default=None,\n        alias=\"_alias\",\n    )\n    min: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum Cardinality (a number or *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    base: typing.Optional[\"Element\"] = Field(\n        description=\"Base definition information for tools\",\n        default=None,\n    )\n    contentReference: typing.Optional[Uri] = Field(\n        description=\"Reference to definition of content for the element\",\n        default=None,\n    )\n    contentReference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for contentReference extensions\",\n        default=None,\n        alias=\"_contentReference\",\n    )\n    type: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Data type and Profile for this element\",\n        default=None,\n    )\n    defaultValueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCode: typing.Optional[Code] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDate: typing.Optional[Date] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueId: typing.Optional[Id] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInstant: typing.Optional[Instant] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInteger: typing.Optional[Integer] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueInteger64: typing.Optional[Integer64] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueOid: typing.Optional[Oid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueString: typing.Optional[String] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTime: typing.Optional[Time] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUri: typing.Optional[Uri] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUrl: typing.Optional[Url] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUuid: typing.Optional[Uuid] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAddress: typing.Optional[Address] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAge: typing.Optional[\"Age\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAnnotation: typing.Optional[Annotation] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAttachment: typing.Optional[Attachment] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCodeableConcept: typing.Optional[CodeableConcept] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCodeableReference: typing.Optional[CodeableReference] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCoding: typing.Optional[Coding] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactPoint: typing.Optional[ContactPoint] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueCount: typing.Optional[\"Count\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDistance: typing.Optional[\"Distance\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDuration: typing.Optional[\"Duration\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueHumanName: typing.Optional[\"HumanName\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueIdentifier: typing.Optional[\"Identifier\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMoney: typing.Optional[\"Money\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValuePeriod: typing.Optional[\"Period\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRange: typing.Optional[\"Range\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRatio: typing.Optional[\"Ratio\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRatioRange: typing.Optional[\"RatioRange\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueReference: typing.Optional[\"Reference\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSampledData: typing.Optional[\"SampledData\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueSignature: typing.Optional[\"Signature\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTiming: typing.Optional[\"Timing\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueContactDetail: typing.Optional[ContactDetail] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDataRequirement: typing.Optional[DataRequirement] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueExpression: typing.Optional[\"Expression\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueParameterDefinition: typing.Optional[\"ParameterDefinition\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueRelatedArtifact: typing.Optional[\"RelatedArtifact\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueTriggerDefinition: typing.Optional[\"TriggerDefinition\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueUsageContext: typing.Optional[\"UsageContext\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueAvailability: typing.Optional['Availability'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueExtendedContactDetail: typing.Optional['ExtendedContactDetail'] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueDosage: typing.Optional[Dosage] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    defaultValueMeta: typing.Optional[\"Meta\"] = Field(\n        description=\"Specified value if missing from instance\",\n        default=None,\n    )\n    meaningWhenMissing: typing.Optional[Markdown] = Field(\n        description=\"Implicit meaning when this element is missing\",\n        default=None,\n    )\n    meaningWhenMissing_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for meaningWhenMissing extensions\",\n        default=None,\n        alias=\"_meaningWhenMissing\",\n    )\n    orderMeaning: typing.Optional[String] = Field(\n        description=\"What the order of the elements means\",\n        default=None,\n    )\n    orderMeaning_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for orderMeaning extensions\",\n        default=None,\n        alias=\"_orderMeaning\",\n    )\n    fixedBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCode: typing.Optional[Code] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDate: typing.Optional[Date] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedId: typing.Optional[Id] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInstant: typing.Optional[Instant] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInteger: typing.Optional[Integer] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedInteger64: typing.Optional[Integer64] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedOid: typing.Optional[Oid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedString: typing.Optional[String] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTime: typing.Optional[Time] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUri: typing.Optional[Uri] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUrl: typing.Optional[Url] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAddress: typing.Optional[Address] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAge: typing.Optional[\"Age\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAnnotation: typing.Optional[Annotation] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAttachment: typing.Optional[Attachment] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCodeableConcept: typing.Optional[CodeableConcept] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCodeableReference: typing.Optional[CodeableReference] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCoding: typing.Optional[Coding] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactPoint: typing.Optional[ContactPoint] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedCount: typing.Optional[\"Count\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDistance: typing.Optional[\"Distance\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDuration: typing.Optional[\"Duration\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedHumanName: typing.Optional[\"HumanName\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedIdentifier: typing.Optional[\"Identifier\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMoney: typing.Optional[\"Money\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedPeriod: typing.Optional[\"Period\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRange: typing.Optional[\"Range\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRatio: typing.Optional[\"Ratio\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRatioRange: typing.Optional[\"RatioRange\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedReference: typing.Optional[\"Reference\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSampledData: typing.Optional[\"SampledData\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedSignature: typing.Optional[\"Signature\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTiming: typing.Optional[\"Timing\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedContactDetail: typing.Optional[ContactDetail] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDataRequirement: typing.Optional[DataRequirement] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedExpression: typing.Optional[\"Expression\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedParameterDefinition: typing.Optional[\"ParameterDefinition\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedRelatedArtifact: typing.Optional[\"RelatedArtifact\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedTriggerDefinition: typing.Optional[\"TriggerDefinition\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedUsageContext: typing.Optional[\"UsageContext\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedAvailability: typing.Optional['Availability'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedExtendedContactDetail: typing.Optional['ExtendedContactDetail'] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedDosage: typing.Optional[Dosage] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    fixedMeta: typing.Optional[\"Meta\"] = Field(\n        description=\"Value must be exactly this\",\n        default=None,\n    )\n    patternBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCode: typing.Optional[Code] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDate: typing.Optional[Date] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternId: typing.Optional[Id] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInstant: typing.Optional[Instant] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInteger: typing.Optional[Integer] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternInteger64: typing.Optional[Integer64] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternOid: typing.Optional[Oid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternString: typing.Optional[String] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTime: typing.Optional[Time] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUri: typing.Optional[Uri] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUrl: typing.Optional[Url] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUuid: typing.Optional[Uuid] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAddress: typing.Optional[Address] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAge: typing.Optional[\"Age\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAnnotation: typing.Optional[Annotation] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAttachment: typing.Optional[Attachment] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCodeableConcept: typing.Optional[CodeableConcept] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCodeableReference: typing.Optional[CodeableReference] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCoding: typing.Optional[Coding] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactPoint: typing.Optional[ContactPoint] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternCount: typing.Optional[\"Count\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDistance: typing.Optional[\"Distance\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDuration: typing.Optional[\"Duration\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternHumanName: typing.Optional[\"HumanName\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternIdentifier: typing.Optional[\"Identifier\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMoney: typing.Optional[\"Money\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternPeriod: typing.Optional[\"Period\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRange: typing.Optional[\"Range\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRatio: typing.Optional[\"Ratio\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRatioRange: typing.Optional[\"RatioRange\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternReference: typing.Optional[\"Reference\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSampledData: typing.Optional[\"SampledData\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternSignature: typing.Optional[\"Signature\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTiming: typing.Optional[\"Timing\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternContactDetail: typing.Optional[ContactDetail] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDataRequirement: typing.Optional[DataRequirement] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternExpression: typing.Optional[\"Expression\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternParameterDefinition: typing.Optional[\"ParameterDefinition\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternRelatedArtifact: typing.Optional[\"RelatedArtifact\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternTriggerDefinition: typing.Optional[\"TriggerDefinition\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternUsageContext: typing.Optional[\"UsageContext\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternAvailability: typing.Optional['Availability'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternExtendedContactDetail: typing.Optional['ExtendedContactDetail'] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternDosage: typing.Optional[Dosage] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    patternMeta: typing.Optional[\"Meta\"] = Field(\n        description=\"Value must have at least these property values\",\n        default=None,\n    )\n    example: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Example value (as defined for type)\",\n        default=None,\n    )\n    minValueDate: typing.Optional[Date] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInstant: typing.Optional[Instant] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueTime: typing.Optional[Time] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInteger: typing.Optional[Integer] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueInteger64: typing.Optional[Integer64] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    minValueQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Minimum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDate: typing.Optional[Date] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInstant: typing.Optional[Instant] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueTime: typing.Optional[Time] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInteger: typing.Optional[Integer] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueInteger64: typing.Optional[Integer64] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxValueQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Maximum Allowed Value (for some types)\",\n        default=None,\n    )\n    maxLength: typing.Optional[Integer] = Field(\n        description=\"Max length for string type data\",\n        default=None,\n    )\n    maxLength_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for maxLength extensions\",\n        default=None,\n        alias=\"_maxLength\",\n    )\n    condition: typing.Optional[typing.List[Id]] = Field(\n        description=\"Reference to invariant about presence\",\n        default=None,\n    )\n    condition_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for condition extensions\",\n        default=None,\n        alias=\"_condition\",\n    )\n    constraint: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Condition that must evaluate to true\",\n        default=None,\n    )\n    mustHaveValue: typing.Optional[Boolean] = Field(\n        description=\"For primitives, that a value must be present - not replaced by an extension\",\n        default=None,\n    )\n    mustHaveValue_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustHaveValue extensions\",\n        default=None,\n        alias=\"_mustHaveValue\",\n    )\n    valueAlternatives: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"Extensions that are allowed to replace a primitive value\",\n        default=None,\n    )\n    valueAlternatives_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for valueAlternatives extensions\",\n        default=None,\n        alias=\"_valueAlternatives\",\n    )\n    mustSupport: typing.Optional[Boolean] = Field(\n        description=\"If the element must be supported (discouraged - see obligations)\",\n        default=None,\n    )\n    mustSupport_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for mustSupport extensions\",\n        default=None,\n        alias=\"_mustSupport\",\n    )\n    isModifier: typing.Optional[Boolean] = Field(\n        description=\"If this modifies the meaning of other elements\",\n        default=None,\n    )\n    isModifier_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifier extensions\",\n        default=None,\n        alias=\"_isModifier\",\n    )\n    isModifierReason: typing.Optional[String] = Field(\n        description=\"Reason that this element is marked as a modifier\",\n        default=None,\n    )\n    isModifierReason_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isModifierReason extensions\",\n        default=None,\n        alias=\"_isModifierReason\",\n    )\n    isSummary: typing.Optional[Boolean] = Field(\n        description=\"Include when _summary = true?\",\n        default=None,\n    )\n    isSummary_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for isSummary extensions\",\n        default=None,\n        alias=\"_isSummary\",\n    )\n    binding: typing.Optional[\"Element\"] = Field(\n        description=\"ValueSet details if this is coded\",\n        default=None,\n    )\n    mapping: typing.Optional[typing.List[\"Element\"]] = Field(\n        description=\"Map element to another set of definitions\",\n        default=None,\n    )\n    @field_validator(*('mapping', 'binding', 'isSummary', 'isModifierReason', 'isModifier', 'mustSupport', 'valueAlternatives', 'mustHaveValue', 'constraint', 'condition', 'maxLength', 'example', 'orderMeaning', 'meaningWhenMissing', 'type', 'contentReference', 'base', 'max', 'min', 'alias', 'requirements', 'comment', 'definition', 'short', 'slicing', 'code', 'label', 'sliceIsConstraining', 'sliceName', 'representation', 'path', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('max',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_3_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"empty() or ($this = '*') or (toInteger() &gt;= 0)\",\n            human=\"Max SHALL be a number or \\\"*\\\"\",\n            key=\"eld-3\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"aggregation.empty() or (code = 'Reference') or (code = 'canonical') or (code = 'CodeableReference')\",\n            human=\"Aggregation may only be specified if one of the allowed types for the element is a reference\",\n            key=\"eld-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('type',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_17_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"(code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()\",\n            human=\"targetProfile is only allowed if the type is Reference or canonical\",\n            key=\"eld-17\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('constraint',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_21_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"expression.exists()\",\n            human=\"Constraints should have an expression or else validators will not be able to enforce them\",\n            key=\"eld-21\",\n            severity=\"warning\",\n        )\n\n    @field_validator(*('constraint',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_26_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"(severity = 'error') implies suppress.empty()\",\n            human=\"Errors cannot be suppressed\",\n            key=\"eld-26\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('binding',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_12_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))\",\n            human=\"ValueSet SHALL start with http:// or https:// or urn: or #\",\n            key=\"eld-12\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('binding',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_eld_23_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"description.exists() or valueSet.exists()\",\n            human=\"binding SHALL have either description or valueSet\",\n            key=\"eld-23\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def defaultValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Integer64, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, Address, Age, Annotation, Attachment, CodeableConcept, CodeableReference, Coding, ContactPoint, Count, Distance, Duration, HumanName, Identifier, Money, Period, Quantity, Range, Ratio, RatioRange, Reference, SampledData, Signature, Timing, ContactDetail, DataRequirement, Expression, ParameterDefinition, RelatedArtifact, TriggerDefinition, UsageContext, 'Availability', 'ExtendedContactDetail', Dosage, Meta],\n            field_name_base=\"defaultValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def fixed_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Integer64, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, Address, Age, Annotation, Attachment, CodeableConcept, CodeableReference, Coding, ContactPoint, Count, Distance, Duration, HumanName, Identifier, Money, Period, Quantity, Range, Ratio, RatioRange, Reference, SampledData, Signature, Timing, ContactDetail, DataRequirement, Expression, ParameterDefinition, RelatedArtifact, TriggerDefinition, UsageContext, 'Availability', 'ExtendedContactDetail', Dosage, Meta],\n            field_name_base=\"fixed\",\n        )\n\n    @model_validator(mode=\"after\")\n    def pattern_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Integer64, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, Address, Age, Annotation, Attachment, CodeableConcept, CodeableReference, Coding, ContactPoint, Count, Distance, Duration, HumanName, Identifier, Money, Period, Quantity, Range, Ratio, RatioRange, Reference, SampledData, Signature, Timing, ContactDetail, DataRequirement, Expression, ParameterDefinition, RelatedArtifact, TriggerDefinition, UsageContext, 'Availability', 'ExtendedContactDetail', Dosage, Meta],\n            field_name_base=\"pattern\",\n        )\n\n    @model_validator(mode=\"after\")\n    def minValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, Integer64, PositiveInt, UnsignedInt, Quantity],\n            field_name_base=\"minValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def maxValue_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Date, DateTime, Instant, Time, Decimal, Integer, Integer64, PositiveInt, UnsignedInt, Quantity],\n            field_name_base=\"maxValue\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"min.empty() or max.empty() or (max = '*') or iif(max != '*', min &lt;= max.toInteger())\",\n            human=\"Min &lt;= Max\",\n            key=\"eld-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_5_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())\",\n            human=\"if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding\",\n            key=\"eld-5\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_6_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"fixed.empty() or (type.count()  &lt;= 1)\",\n            human=\"Fixed value may only be specified if there is one type\",\n            key=\"eld-6\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_7_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or (type.count() &lt;= 1)\",\n            human=\"Pattern may only be specified if there is one type\",\n            key=\"eld-7\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_8_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"pattern.empty() or fixed.empty()\",\n            human=\"Pattern and fixed are mutually exclusive\",\n            key=\"eld-8\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_11_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"binding.empty() or type.code.empty() or type.code.contains(\\\":\\\") or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()\",\n            human=\"Binding can only be present for coded elements, string, and uri if using FHIR-defined types\",\n            key=\"eld-11\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_13_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"type.select(code).isDistinct()\",\n            human=\"Types must be unique by code\",\n            key=\"eld-13\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_14_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"constraint.select(key).isDistinct()\",\n            human=\"Constraints must be unique by key\",\n            key=\"eld-14\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_15_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"defaultValue.empty() or meaningWhenMissing.empty()\",\n            human=\"default value and meaningWhenMissing are mutually exclusive\",\n            key=\"eld-15\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_16_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\\\/\\\\-_\\\\[\\\\]\\\\@]+$')\",\n            human=\"sliceName must be composed of proper tokens separated by \\\"/\\\"\",\n            key=\"eld-16\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_18_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(isModifier.exists() and isModifier) implies isModifierReason.exists()\",\n            human=\"Must have a modifier reason if isModifier = true\",\n            key=\"eld-18\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_19_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('^[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\.[^\\\\s\\\\.,:;\\\\\\'\\\"\\\\/|?!@#$%&amp;*()\\\\[\\\\]{}]{1,64}(\\\\[x\\\\])?(\\\\:[^\\\\s\\\\.]+)?)*$')\",\n            human=\"Element path SHALL be expressed as a set of '.'-separated components with each component restricted to a maximum of 64 characters and with some limits on the allowed choice of characters\",\n            key=\"eld-19\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_20_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"path.matches('^[A-Za-z][A-Za-z0-9]{0,63}(\\\\.[a-z][A-Za-z0-9]{0,63}(\\\\[x])?)*$')\",\n            human=\"The first component of the path should be UpperCamelCase.  Additional components (following a '.') should be lowerCamelCase.  If this syntax is not adhered to, code generation tools may be broken. Logical models may be less concerned about this implication.\",\n            key=\"eld-20\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_22_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"sliceIsConstraining.exists() implies sliceName.exists()\",\n            human=\"sliceIsConstraining can only appear if slicename is present\",\n            key=\"eld-22\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_24_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"fixed.exists().not()\",\n            human=\"pattern[x] should be used rather than fixed[x]\",\n            key=\"eld-24\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_25_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"orderMeaning.empty() implies slicing.where(rules='openAtEnd' or ordered).exists().not()\",\n            human=\"Order has no meaning (and cannot be asserted to have meaning), so enforcing rules on order is improper\",\n            key=\"eld-25\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_27_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"mapping.select(identity).isDistinct()\",\n            human=\"Mappings SHOULD be unique by key\",\n            key=\"eld-27\",\n            severity=\"warning\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_eld_28_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"mustHaveValue.value implies valueAlternatives.empty()\",\n            human=\"Can't have valueAlternatives if mustHaveValue is true\",\n            key=\"eld-28\",\n            severity=\"error\",\n        )\n\n    @property \n    def defaultValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"defaultValue\",\n        )\n    @property \n    def fixed(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"fixed\",\n        )\n    @property \n    def pattern(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"pattern\",\n        )\n    @property \n    def minValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"minValue\",\n        )\n    @property \n    def maxValue(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"maxValue\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Expression","title":"<code>Expression</code>","text":"<p>               Bases: <code>DataType</code></p> <p>An expression that can be used to generate a value</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Expression(DataType):\n    \"\"\"\n    An expression that can be used to generate a value\n    \"\"\"\n    description: typing.Optional[String] = Field(\n        description=\"Natural language description of the condition\",\n        default=None,\n    )\n    description_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for description extensions\",\n        default=None,\n        alias=\"_description\",\n    )\n    name: typing.Optional[Code] = Field(\n        description=\"Short name assigned to expression for reuse\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"text/cql | text/fhirpath | application/x-fhir-query | etc.\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    expression: typing.Optional[String] = Field(\n        description=\"Expression in specified language\",\n        default=None,\n    )\n    expression_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for expression extensions\",\n        default=None,\n        alias=\"_expression\",\n    )\n    reference: typing.Optional[Uri] = Field(\n        description=\"Where the expression is found\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    @field_validator(*('reference', 'expression', 'language', 'name', 'description', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_exp_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"expression.exists() or reference.exists()\",\n            human=\"An expression or a reference must be provided\",\n            key=\"exp-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_exp_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"name.hasValue() implies name.matches('[A-Za-z][A-Za-z0-9\\\\_]{0,63}')\",\n            human=\"The name must be a valid variable name in most computer languages\",\n            key=\"exp-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ExtendedContactDetail","title":"<code>ExtendedContactDetail</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Contact information</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ExtendedContactDetail(DataType):\n    \"\"\"\n    Contact information\n    \"\"\"\n    purpose: typing.Optional[CodeableConcept] = Field(\n        description=\"The type of contact\",\n        default=None,\n    )\n    name: typing.Optional[typing.List[\"HumanName\"]] = Field(\n        description=\"Name of an individual to contact\",\n        default=None,\n    )\n    telecom: typing.Optional[typing.List[ContactPoint]] = Field(\n        description=\"Contact details (e.g.phone/fax/url)\",\n        default=None,\n    )\n    address: typing.Optional[Address] = Field(\n        description=\"Address for the contact\",\n        default=None,\n    )\n    organization: typing.Optional[\"Reference\"] = Field(\n        description=\"This contact detail is handled/monitored by a specific organization\",\n        default=None,\n    )\n    period: typing.Optional[\"Period\"] = Field(\n        description=\"Period that this contact was valid for usage\",\n        default=None,\n    )\n    @field_validator(*('period', 'organization', 'address', 'telecom', 'name', 'purpose', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Optional Extensions Element</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Extension(DataType):\n    \"\"\"\n    Optional Extensions Element\n    \"\"\"\n    url: String = Field(\n        description=\"identifies the meaning of the extension\",\n        default=None,\n    )\n    url_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for url extensions\",\n        default=None,\n        alias=\"_url\",\n    )\n    valueBase64Binary: typing.Optional[Base64Binary] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueBoolean: typing.Optional[Boolean] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCanonical: typing.Optional[Canonical] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCode: typing.Optional[Code] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDate: typing.Optional[Date] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDateTime: typing.Optional[DateTime] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDecimal: typing.Optional[Decimal] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueId: typing.Optional[Id] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInstant: typing.Optional[Instant] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInteger: typing.Optional[Integer] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueInteger64: typing.Optional[Integer64] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMarkdown: typing.Optional[Markdown] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueOid: typing.Optional[Oid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePositiveInt: typing.Optional[PositiveInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueString: typing.Optional[String] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTime: typing.Optional[Time] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUnsignedInt: typing.Optional[UnsignedInt] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUri: typing.Optional[Uri] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUrl: typing.Optional[Url] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUuid: typing.Optional[Uuid] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAddress: typing.Optional[Address] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAge: typing.Optional[\"Age\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAnnotation: typing.Optional[Annotation] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAttachment: typing.Optional[Attachment] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCodeableConcept: typing.Optional[CodeableConcept] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCodeableReference: typing.Optional[CodeableReference] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCoding: typing.Optional[Coding] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactPoint: typing.Optional[ContactPoint] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueCount: typing.Optional[\"Count\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDistance: typing.Optional[\"Distance\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDuration: typing.Optional[\"Duration\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueHumanName: typing.Optional[\"HumanName\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueIdentifier: typing.Optional[\"Identifier\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMoney: typing.Optional[\"Money\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valuePeriod: typing.Optional[\"Period\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueQuantity: typing.Optional[\"Quantity\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRange: typing.Optional[\"Range\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRatio: typing.Optional[\"Ratio\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRatioRange: typing.Optional[\"RatioRange\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueReference: typing.Optional[\"Reference\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSampledData: typing.Optional[\"SampledData\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueSignature: typing.Optional[\"Signature\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTiming: typing.Optional[\"Timing\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueContactDetail: typing.Optional[ContactDetail] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDataRequirement: typing.Optional[DataRequirement] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueExpression: typing.Optional[Expression] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueParameterDefinition: typing.Optional[\"ParameterDefinition\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueRelatedArtifact: typing.Optional[\"RelatedArtifact\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueTriggerDefinition: typing.Optional[\"TriggerDefinition\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueUsageContext: typing.Optional[\"UsageContext\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueAvailability: typing.Optional['Availability'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueExtendedContactDetail: typing.Optional['ExtendedContactDetail'] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueDosage: typing.Optional[Dosage] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    valueMeta: typing.Optional[\"Meta\"] = Field(\n        description=\"Value of extension\",\n        default=None,\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Base64Binary, Boolean, Canonical, Code, Date, DateTime, Decimal, Id, Instant, Integer, Integer64, Markdown, Oid, PositiveInt, String, Time, UnsignedInt, Uri, Url, Uuid, Address, Age, Annotation, Attachment, CodeableConcept, CodeableReference, Coding, ContactPoint, Count, Distance, Duration, HumanName, Identifier, Money, Period, Quantity, Range, Ratio, RatioRange, Reference, SampledData, Signature, Timing, ContactDetail, DataRequirement, Expression, ParameterDefinition, RelatedArtifact, TriggerDefinition, UsageContext, 'Availability', 'ExtendedContactDetail', Dosage, Meta],\n            field_name_base=\"value\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ext_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.HumanName","title":"<code>HumanName</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Name of a human or other living entity - parts and usage</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class HumanName(DataType):\n    \"\"\"\n    Name of a human or other living entity - parts and usage\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | nickname | anonymous | old | maiden\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    text: typing.Optional[String] = Field(\n        description=\"Text representation of the full name\",\n        default=None,\n    )\n    text_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for text extensions\",\n        default=None,\n        alias=\"_text\",\n    )\n    family: typing.Optional[String] = Field(\n        description=\"Family name (often called \\u0027Surname\\u0027)\",\n        default=None,\n    )\n    family_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for family extensions\",\n        default=None,\n        alias=\"_family\",\n    )\n    given: typing.Optional[typing.List[String]] = Field(\n        description=\"Given names (not always \\u0027first\\u0027). Includes middle names\",\n        default=None,\n    )\n    given_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for given extensions\",\n        default=None,\n        alias=\"_given\",\n    )\n    prefix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come before the name\",\n        default=None,\n    )\n    prefix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for prefix extensions\",\n        default=None,\n        alias=\"_prefix\",\n    )\n    suffix: typing.Optional[typing.List[String]] = Field(\n        description=\"Parts that come after the name\",\n        default=None,\n    )\n    suffix_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for suffix extensions\",\n        default=None,\n        alias=\"_suffix\",\n    )\n    period: typing.Optional[\"Period\"] = Field(\n        description=\"Time period when name was/is in use\",\n        default=None,\n    )\n    @field_validator(*('period', 'suffix', 'prefix', 'given', 'family', 'text', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Identifier","title":"<code>Identifier</code>","text":"<p>               Bases: <code>DataType</code></p> <p>An identifier intended for computation</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Identifier(DataType):\n    \"\"\"\n    An identifier intended for computation\n    \"\"\"\n    use: typing.Optional[Code] = Field(\n        description=\"usual | official | temp | secondary | old (If known)\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    type: typing.Optional[CodeableConcept] = Field(\n        description=\"Description of identifier\",\n        default=None,\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"The namespace for the identifier value\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    value: typing.Optional[String] = Field(\n        description=\"The value that is unique\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    period: typing.Optional[\"Period\"] = Field(\n        description=\"Time period when id is/was valid for use\",\n        default=None,\n    )\n    assigner: typing.Optional[\"Reference\"] = Field(\n        description=\"Organization that issued id (may be just text)\",\n        default=None,\n    )\n    @field_validator(*('assigner', 'period', 'value', 'system', 'type', 'use', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ident_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"value.exists()\",\n            human=\"Identifier with no value has limited utility.  If communicating that an identifier value has been suppressed or missing, the value element SHOULD be present with an extension indicating the missing semantic - e.g. data-absent-reason\",\n            key=\"ident-1\",\n            severity=\"warning\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.MarketingStatus","title":"<code>MarketingStatus</code>","text":"<p>               Bases: <code>BackboneType</code></p> <p>The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class MarketingStatus(BackboneType):\n    \"\"\"\n    The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available\n    \"\"\"\n    country: typing.Optional[CodeableConcept] = Field(\n        description=\"The country in which the marketing authorization has been granted shall be specified It should be specified using the ISO 3166 \\u2011 1 alpha-2 code elements\",\n        default=None,\n    )\n    jurisdiction: typing.Optional[CodeableConcept] = Field(\n        description=\"Where a Medicines Regulatory Agency has granted a marketing authorization for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    status: CodeableConcept = Field(\n        description=\"This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples\",\n        default=None,\n    )\n    dateRange: typing.Optional[\"Period\"] = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate: typing.Optional[DateTime] = Field(\n        description=\"The date when the Medicinal Product is placed on the market by the Marketing Authorization Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE \\u201cPlaced on the market\\u201d refers to the release of the Medicinal Product into the distribution chain\",\n        default=None,\n    )\n    restoreDate_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for restoreDate extensions\",\n        default=None,\n        alias=\"_restoreDate\",\n    )\n    @field_validator(*('restoreDate', 'dateRange', 'status', 'jurisdiction', 'country', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Metadata about a resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Meta(DataType):\n    \"\"\"\n    Metadata about a resource\n    \"\"\"\n    versionId: typing.Optional[Id] = Field(\n        description=\"Version specific identifier\",\n        default=None,\n    )\n    versionId_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for versionId extensions\",\n        default=None,\n        alias=\"_versionId\",\n    )\n    lastUpdated: typing.Optional[Instant] = Field(\n        description=\"When the resource version last changed\",\n        default=None,\n    )\n    lastUpdated_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lastUpdated extensions\",\n        default=None,\n        alias=\"_lastUpdated\",\n    )\n    source: typing.Optional[Uri] = Field(\n        description=\"Identifies where the resource comes from\",\n        default=None,\n    )\n    source_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for source extensions\",\n        default=None,\n        alias=\"_source\",\n    )\n    profile: typing.Optional[typing.List[Canonical]] = Field(\n        description=\"Profiles this resource claims to conform to\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    security: typing.Optional[typing.List[Coding]] = Field(\n        description=\"Security Labels applied to this resource\",\n        default=None,\n    )\n    tag: typing.Optional[typing.List[Coding]] = Field(\n        description=\"Tags applied to this resource\",\n        default=None,\n    )\n    @field_validator(*('tag', 'security', 'profile', 'source', 'lastUpdated', 'versionId', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.MonetaryComponent","title":"<code>MonetaryComponent</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Availability data for an {item}</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class MonetaryComponent(DataType):\n    \"\"\"\n    Availability data for an {item}\n    \"\"\"\n    type: Code = Field(\n        description=\"base | surcharge | deduction | discount | tax | informational\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    code: typing.Optional[CodeableConcept] = Field(\n        description=\"Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.\",\n        default=None,\n    )\n    factor: typing.Optional[Decimal] = Field(\n        description=\"Factor used for calculating this component\",\n        default=None,\n    )\n    factor_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for factor extensions\",\n        default=None,\n        alias=\"_factor\",\n    )\n    amount: typing.Optional[\"Money\"] = Field(\n        description=\"Explicit value amount to be used\",\n        default=None,\n    )\n    @field_validator(*('amount', 'factor', 'code', 'type', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Money","title":"<code>Money</code>","text":"<p>               Bases: <code>DataType</code></p> <p>An amount of economic utility in some recognized currency</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Money(DataType):\n    \"\"\"\n    An amount of economic utility in some recognized currency\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    currency: typing.Optional[Code] = Field(\n        description=\"ISO 4217 Currency Code\",\n        default=None,\n    )\n    currency_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for currency extensions\",\n        default=None,\n        alias=\"_currency\",\n    )\n    @field_validator(*('currency', 'value', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.MoneyQuantity","title":"<code>MoneyQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>An amount of money. With regard to precision, see Decimal Precision</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class MoneyQuantity(Quantity):\n    \"\"\"\n    An amount of money. With regard to precision, see [Decimal Precision](datatypes.html#precision)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_mtqy_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(code.exists() or value.empty()) and (system.empty() or system = 'urn:iso:std:iso:4217')\",\n            human=\"There SHALL be a code if there is a value and it SHALL be an expression of currency.  If system is present, it SHALL be ISO 4217 (system = \\\"urn:iso:std:iso:4217\\\" - currency).\",\n            key=\"mtqy-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Narrative","title":"<code>Narrative</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Human-readable summary of the resource (essential clinical and business information)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Narrative(DataType):\n    \"\"\"\n    Human-readable summary of the resource (essential clinical and business information)\n    \"\"\"\n    status: Code = Field(\n        description=\"generated | extensions | additional | empty\",\n        default=None,\n    )\n    status_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for status extensions\",\n        default=None,\n        alias=\"_status\",\n    )\n    div: str = Field(\n        description=\"Limited xhtml content\",\n        default=None,\n    )\n    @field_validator(*('div', 'status', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL contain only the basic html formatting elements and attributes described in chapters 7-11 (except section 4 of chapter 9) and 15 of the HTML 4.0 standard, &lt;a&gt; elements (either name or href), images and internally contained style attributes\",\n            key=\"txt-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('div',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_txt_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"htmlChecks()\",\n            human=\"The narrative SHALL have some non-whitespace content\",\n            key=\"txt-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ParameterDefinition","title":"<code>ParameterDefinition</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Definition of a parameter to a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ParameterDefinition(DataType):\n    \"\"\"\n    Definition of a parameter to a module\n    \"\"\"\n    name: typing.Optional[Code] = Field(\n        description=\"Name used to access the parameter value\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    use: Code = Field(\n        description=\"in | out\",\n        default=None,\n    )\n    use_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for use extensions\",\n        default=None,\n        alias=\"_use\",\n    )\n    min: typing.Optional[Integer] = Field(\n        description=\"Minimum cardinality\",\n        default=None,\n    )\n    min_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for min extensions\",\n        default=None,\n        alias=\"_min\",\n    )\n    max: typing.Optional[String] = Field(\n        description=\"Maximum cardinality (a number of *)\",\n        default=None,\n    )\n    max_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for max extensions\",\n        default=None,\n        alias=\"_max\",\n    )\n    documentation: typing.Optional[String] = Field(\n        description=\"A brief description of the parameter\",\n        default=None,\n    )\n    documentation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for documentation extensions\",\n        default=None,\n        alias=\"_documentation\",\n    )\n    type: Code = Field(\n        description=\"What type of value\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    profile: typing.Optional[Canonical] = Field(\n        description=\"What profile the value is expected to be\",\n        default=None,\n    )\n    profile_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for profile extensions\",\n        default=None,\n        alias=\"_profile\",\n    )\n    @field_validator(*('profile', 'type', 'documentation', 'max', 'min', 'use', 'name', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Period","title":"<code>Period</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Time range defined by start and end date/time</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Period(DataType):\n    \"\"\"\n    Time range defined by start and end date/time\n    \"\"\"\n    start: typing.Optional[DateTime] = Field(\n        description=\"Starting time with inclusive boundary\",\n        default=None,\n    )\n    start_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for start extensions\",\n        default=None,\n        alias=\"_start\",\n    )\n    end: typing.Optional[DateTime] = Field(\n        description=\"End time with inclusive boundary, if not ongoing\",\n        default=None,\n    )\n    end_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for end extensions\",\n        default=None,\n        alias=\"_end\",\n    )\n    @field_validator(*('end', 'start', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_per_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"start.hasValue().not() or end.hasValue().not() or (start.lowBoundary() &lt;= end.highBoundary())\",\n            human=\"If present, start SHALL have a lower or equal value than end\",\n            key=\"per-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.PrimitiveType","title":"<code>PrimitiveType</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Parent type for DataTypes with a simple value</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class PrimitiveType(DataType):\n    \"\"\"\n    Parent type for DataTypes with a simple value\n    \"\"\"\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.ProductShelfLife","title":"<code>ProductShelfLife</code>","text":"<p>               Bases: <code>BackboneType</code></p> <p>The shelf-life and storage information for a medicinal product item or container can be described using this class</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class ProductShelfLife(BackboneType):\n    \"\"\"\n    The shelf-life and storage information for a medicinal product item or container can be described using this class\n    \"\"\"\n    type: typing.Optional[CodeableConcept] = Field(\n        description=\"This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    periodDuration: typing.Optional[\"Duration\"] = Field(\n        description=\"The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    periodString: typing.Optional[String] = Field(\n        description=\"The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used\",\n        default=None,\n    )\n    specialPrecautionsForStorage: typing.Optional[typing.List[CodeableConcept]] = Field(\n        description=\"Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified\",\n        default=None,\n    )\n    @field_validator(*('specialPrecautionsForStorage', 'type', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def period_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Duration, String],\n            field_name_base=\"period\",\n        )\n\n    @property \n    def period(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"period\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Quantity","title":"<code>Quantity</code>","text":"<p>               Bases: <code>DataType</code></p> <p>A measured or measurable amount</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Quantity(DataType):\n    \"\"\"\n    A measured or measurable amount\n    \"\"\"\n    value: typing.Optional[Decimal] = Field(\n        description=\"Numerical value (with implicit precision)\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    comparator: typing.Optional[Code] = Field(\n        description=\"\\u003c | \\u003c= | \\u003e= | \\u003e | ad - how to understand the value\",\n        default=None,\n    )\n    comparator_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for comparator extensions\",\n        default=None,\n        alias=\"_comparator\",\n    )\n    unit: typing.Optional[String] = Field(\n        description=\"Unit representation\",\n        default=None,\n    )\n    unit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for unit extensions\",\n        default=None,\n        alias=\"_unit\",\n    )\n    system: typing.Optional[Uri] = Field(\n        description=\"System that defines coded unit form\",\n        default=None,\n    )\n    system_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for system extensions\",\n        default=None,\n        alias=\"_system\",\n    )\n    code: typing.Optional[Code] = Field(\n        description=\"Coded form of the unit\",\n        default=None,\n    )\n    code_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for code extensions\",\n        default=None,\n        alias=\"_code\",\n    )\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Range","title":"<code>Range</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Set of values bounded by low and high</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Range(DataType):\n    \"\"\"\n    Set of values bounded by low and high\n    \"\"\"\n    low: typing.Optional[Quantity] = Field(\n        description=\"Low limit\",\n        default=None,\n    )\n    high: typing.Optional[Quantity] = Field(\n        description=\"High limit\",\n        default=None,\n    )\n    @field_validator(*('high', 'low', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rng_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"low.value.empty() or high.value.empty() or low.lowBoundary().comparable(high.highBoundary()).not() or (low.lowBoundary() &lt;= high.highBoundary())\",\n            human=\"If present, low SHALL have a lower value than high\",\n            key=\"rng-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Ratio","title":"<code>Ratio</code>","text":"<p>               Bases: <code>DataType</code></p> <p>A ratio of two Quantity values - a numerator and a denominator</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Ratio(DataType):\n    \"\"\"\n    A ratio of two Quantity values - a numerator and a denominator\n    \"\"\"\n    numerator: typing.Optional[Quantity] = Field(\n        description=\"Numerator value\",\n        default=None,\n    )\n    denominator: typing.Optional[Quantity] = Field(\n        description=\"Denominator value\",\n        default=None,\n    )\n    @field_validator(*('denominator', 'numerator', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_rat_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(numerator.exists() and denominator.exists()) or (numerator.empty() and denominator.empty() and extension.exists())\",\n            human=\"Numerator and denominator SHALL both be present, or both are absent. If both are absent, there SHALL be some extension present\",\n            key=\"rat-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.RatioRange","title":"<code>RatioRange</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Range of ratio values</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class RatioRange(DataType):\n    \"\"\"\n    Range of ratio values\n    \"\"\"\n    lowNumerator: typing.Optional[Quantity] = Field(\n        description=\"Low Numerator limit\",\n        default=None,\n    )\n    highNumerator: typing.Optional[Quantity] = Field(\n        description=\"High Numerator limit\",\n        default=None,\n    )\n    denominator: typing.Optional[Quantity] = Field(\n        description=\"Denominator value\",\n        default=None,\n    )\n    @field_validator(*('denominator', 'highNumerator', 'lowNumerator', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ratrng_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"((lowNumerator.exists() or highNumerator.exists()) and denominator.exists()) or (lowNumerator.empty() and highNumerator.empty() and denominator.empty() and extension.exists())\",\n            human=\"One of lowNumerator or highNumerator and denominator SHALL be present, or all are absent. If all are absent, there SHALL be some extension present\",\n            key=\"ratrng-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ratrng_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"lowNumerator.hasValue().not() or highNumerator.hasValue().not()  or (lowNumerator.lowBoundary() &lt;= highNumerator.highBoundary())\",\n            human=\"If present, lowNumerator SHALL have a lower value than highNumerator\",\n            key=\"ratrng-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Reference","title":"<code>Reference</code>","text":"<p>               Bases: <code>DataType</code></p> <p>A reference from one resource to another</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Reference(DataType):\n    \"\"\"\n    A reference from one resource to another\n    \"\"\"\n    reference: typing.Optional[String] = Field(\n        description=\"Literal reference, Relative, internal or absolute URL\",\n        default=None,\n    )\n    reference_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for reference extensions\",\n        default=None,\n        alias=\"_reference\",\n    )\n    type: typing.Optional[Uri] = Field(\n        description=\"Type the reference refers to (e.g. \\\"Patient\\\") - must be a resource in resources\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    identifier: typing.Optional[Identifier] = Field(\n        description=\"Logical reference, when literal reference is not known\",\n        default=None,\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Text alternative for the resource\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    @field_validator(*('display', 'identifier', 'type', 'reference', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ref_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"reference.exists()  implies (reference.startsWith('#').not() or (reference.substring(1).trace('url') in %rootResource.contained.id.trace('ids')) or (reference='#' and %rootResource!=%resource))\",\n            human=\"SHALL have a contained resource if a local reference is provided\",\n            key=\"ref-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ref_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"reference.exists() or identifier.exists() or display.exists() or extension.exists()\",\n            human=\"At least one of reference, identifier and display SHALL be present (unless an extension is provided).\",\n            key=\"ref-2\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.RelatedArtifact","title":"<code>RelatedArtifact</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Related artifacts for a knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class RelatedArtifact(DataType):\n    \"\"\"\n    Related artifacts for a knowledge resource\n    \"\"\"\n    type: Code = Field(\n        description=\"documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of | part-of | amends | amended-with | appends | appended-with | cites | cited-by | comments-on | comment-in | contains | contained-in | corrects | correction-in | replaces | replaced-with | retracts | retracted-by | signs | similar-to | supports | supported-with | transforms | transformed-into | transformed-with | documents | specification-of | created-with | cite-as\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    classifier: typing.Optional[typing.List[CodeableConcept]] = Field(\n        description=\"Additional classifiers\",\n        default=None,\n    )\n    label: typing.Optional[String] = Field(\n        description=\"Short label\",\n        default=None,\n    )\n    label_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for label extensions\",\n        default=None,\n        alias=\"_label\",\n    )\n    display: typing.Optional[String] = Field(\n        description=\"Brief description of the related artifact\",\n        default=None,\n    )\n    display_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for display extensions\",\n        default=None,\n        alias=\"_display\",\n    )\n    citation: typing.Optional[Markdown] = Field(\n        description=\"Bibliographic citation for the artifact\",\n        default=None,\n    )\n    citation_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for citation extensions\",\n        default=None,\n        alias=\"_citation\",\n    )\n    document: typing.Optional[Attachment] = Field(\n        description=\"What document is being referenced\",\n        default=None,\n    )\n    resource: typing.Optional[Canonical] = Field(\n        description=\"What artifact is being referenced\",\n        default=None,\n    )\n    resource_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for resource extensions\",\n        default=None,\n        alias=\"_resource\",\n    )\n    resourceReference: typing.Optional[Reference] = Field(\n        description=\"What artifact, if not a conformance resource\",\n        default=None,\n    )\n    publicationStatus: typing.Optional[Code] = Field(\n        description=\"draft | active | retired | unknown\",\n        default=None,\n    )\n    publicationStatus_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for publicationStatus extensions\",\n        default=None,\n        alias=\"_publicationStatus\",\n    )\n    publicationDate: typing.Optional[Date] = Field(\n        description=\"Date of publication of the artifact being referred to\",\n        default=None,\n    )\n    publicationDate_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for publicationDate extensions\",\n        default=None,\n        alias=\"_publicationDate\",\n    )\n    @field_validator(*('publicationDate', 'publicationStatus', 'resourceReference', 'resource', 'document', 'citation', 'display', 'label', 'classifier', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Resource","title":"<code>Resource</code>","text":"<p>               Bases: <code>Base</code></p> <p>Base Resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Resource(Base):\n    \"\"\"\n    Base Resource\n    \"\"\"\n    id: typing.Optional[String] = Field(\n        description=\"Logical id of this artifact\",\n        default=None,\n    )\n    id_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for id extensions\",\n        default=None,\n        alias=\"_id\",\n    )\n    meta: typing.Optional[Meta] = Field(\n        description=\"Metadata about the resource\",\n        default=None,\n    )\n    implicitRules: typing.Optional[Uri] = Field(\n        description=\"A set of rules under which this content was created\",\n        default=None,\n    )\n    implicitRules_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for implicitRules extensions\",\n        default=None,\n        alias=\"_implicitRules\",\n    )\n    language: typing.Optional[Code] = Field(\n        description=\"Language of the resource content\",\n        default=None,\n    )\n    language_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for language extensions\",\n        default=None,\n        alias=\"_language\",\n    )\n    @field_validator(*('language', 'implicitRules', 'meta'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.SampledData","title":"<code>SampledData</code>","text":"<p>               Bases: <code>DataType</code></p> <p>A series of measurements taken by a device</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class SampledData(DataType):\n    \"\"\"\n    A series of measurements taken by a device\n    \"\"\"\n    origin: Quantity = Field(\n        description=\"Zero value and units\",\n        default=None,\n    )\n    interval: typing.Optional[Decimal] = Field(\n        description=\"Number of intervalUnits between samples\",\n        default=None,\n    )\n    interval_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for interval extensions\",\n        default=None,\n        alias=\"_interval\",\n    )\n    intervalUnit: Code = Field(\n        description=\"The measurement unit of the interval between samples\",\n        default=None,\n    )\n    intervalUnit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for intervalUnit extensions\",\n        default=None,\n        alias=\"_intervalUnit\",\n    )\n    factor: typing.Optional[Decimal] = Field(\n        description=\"Multiply data by this before adding to origin\",\n        default=None,\n    )\n    factor_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for factor extensions\",\n        default=None,\n        alias=\"_factor\",\n    )\n    lowerLimit: typing.Optional[Decimal] = Field(\n        description=\"Lower limit of detection\",\n        default=None,\n    )\n    lowerLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for lowerLimit extensions\",\n        default=None,\n        alias=\"_lowerLimit\",\n    )\n    upperLimit: typing.Optional[Decimal] = Field(\n        description=\"Upper limit of detection\",\n        default=None,\n    )\n    upperLimit_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for upperLimit extensions\",\n        default=None,\n        alias=\"_upperLimit\",\n    )\n    dimensions: PositiveInt = Field(\n        description=\"Number of sample points at each time point\",\n        default=None,\n    )\n    dimensions_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for dimensions extensions\",\n        default=None,\n        alias=\"_dimensions\",\n    )\n    codeMap: typing.Optional[Canonical] = Field(\n        description=\"Defines the codes used in the data\",\n        default=None,\n    )\n    codeMap_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for codeMap extensions\",\n        default=None,\n        alias=\"_codeMap\",\n    )\n    offsets: typing.Optional[String] = Field(\n        description=\"Offsets, typically in time, at which data values were taken\",\n        default=None,\n    )\n    offsets_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for offsets extensions\",\n        default=None,\n        alias=\"_offsets\",\n    )\n    data: typing.Optional[String] = Field(\n        description=\"Decimal values with spaces, or \\\"E\\\" | \\\"U\\\" | \\\"L\\\", or another code\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'offsets', 'codeMap', 'dimensions', 'upperLimit', 'lowerLimit', 'factor', 'intervalUnit', 'interval', 'origin', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_sdd_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"interval.exists().not() xor offsets.exists().not()\",\n            human=\"A SampledData SAHLL have either an interval and offsets but not both\",\n            key=\"sdd-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Signature","title":"<code>Signature</code>","text":"<p>               Bases: <code>DataType</code></p> <p>A Signature - XML DigSig, JWS, Graphical image of signature, etc.</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Signature(DataType):\n    \"\"\"\n    A Signature - XML DigSig, JWS, Graphical image of signature, etc.\n    \"\"\"\n    type: typing.Optional[typing.List[Coding]] = Field(\n        description=\"Indication of the reason the entity signed the object(s)\",\n        default=None,\n    )\n    when: typing.Optional[Instant] = Field(\n        description=\"When the signature was created\",\n        default=None,\n    )\n    when_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for when extensions\",\n        default=None,\n        alias=\"_when\",\n    )\n    who: typing.Optional[Reference] = Field(\n        description=\"Who signed\",\n        default=None,\n    )\n    onBehalfOf: typing.Optional[Reference] = Field(\n        description=\"The party represented\",\n        default=None,\n    )\n    targetFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signed resources\",\n        default=None,\n    )\n    targetFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for targetFormat extensions\",\n        default=None,\n        alias=\"_targetFormat\",\n    )\n    sigFormat: typing.Optional[Code] = Field(\n        description=\"The technical format of the signature\",\n        default=None,\n    )\n    sigFormat_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sigFormat extensions\",\n        default=None,\n        alias=\"_sigFormat\",\n    )\n    data: typing.Optional[Base64Binary] = Field(\n        description=\"The actual signature content (XML DigSig. JWS, picture, etc.)\",\n        default=None,\n    )\n    data_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for data extensions\",\n        default=None,\n        alias=\"_data\",\n    )\n    @field_validator(*('data', 'sigFormat', 'targetFormat', 'onBehalfOf', 'who', 'when', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.SimpleQuantity","title":"<code>SimpleQuantity</code>","text":"<p>               Bases: <code>Quantity</code></p> <p>A fixed quantity (no comparator)</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class SimpleQuantity(Quantity):\n    \"\"\"\n    A fixed quantity (no comparator)\n    \"\"\"\n    @field_validator(*('code', 'system', 'unit', 'comparator', 'value', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_qty_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"code.empty() or system.exists()\",\n            human=\"If a code for the unit is present, the system SHALL also be present\",\n            key=\"qty-3\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_sqty_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"comparator.empty()\",\n            human=\"The comparator is not used on a SimpleQuantity\",\n            key=\"sqty-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.Timing","title":"<code>Timing</code>","text":"<p>               Bases: <code>BackboneType</code></p> <p>A timing schedule that specifies an event that may occur multiple times</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class Timing(BackboneType):\n    \"\"\"\n    A timing schedule that specifies an event that may occur multiple times\n    \"\"\"\n    event: typing.Optional[typing.List[DateTime]] = Field(\n        description=\"When the event occurs\",\n        default=None,\n    )\n    event_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for event extensions\",\n        default=None,\n        alias=\"_event\",\n    )\n    repeat: typing.Optional[\"Element\"] = Field(\n        description=\"When the event is to occur\",\n        default=None,\n    )\n    code: typing.Optional[CodeableConcept] = Field(\n        description=\"C | BID | TID | QID | AM | PM | QD | QOD | +\",\n        default=None,\n    )\n    @field_validator(*('code', 'repeat', 'event', 'modifierExtension', 'extension', 'modifierExtension', 'extension', 'modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('modifierExtension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.empty() or durationUnit.exists()\",\n            human=\"if there's a duration, there needs to be duration units\",\n            key=\"tim-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_2_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.empty() or periodUnit.exists()\",\n            human=\"if there's a period, there needs to be period units\",\n            key=\"tim-2\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_4_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"duration.exists() implies duration &gt;= 0\",\n            human=\"duration SHALL be a non-negative value\",\n            key=\"tim-4\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_5_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"period.exists() implies period &gt;= 0\",\n            human=\"period SHALL be a non-negative value\",\n            key=\"tim-5\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_6_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"periodMax.empty() or period.exists()\",\n            human=\"If there's a periodMax, there must be a period\",\n            key=\"tim-6\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_7_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"durationMax.empty() or duration.exists()\",\n            human=\"If there's a durationMax, there must be a duration\",\n            key=\"tim-7\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_8_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"countMax.empty() or count.exists()\",\n            human=\"If there's a countMax, there must be a count\",\n            key=\"tim-8\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_9_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"offset.empty() or (when.exists() and when.select($this in ('C' | 'CM' | 'CD' | 'CV')).allFalse())\",\n            human=\"If there's an offset, there must be a when (and not C, CM, CD, CV)\",\n            key=\"tim-9\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('repeat',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_tim_10_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"timeOfDay.empty() or when.empty()\",\n            human=\"If there's a timeOfDay, there cannot be a when, or vice versa\",\n            key=\"tim-10\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.TriggerDefinition","title":"<code>TriggerDefinition</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Defines an expected trigger for a module</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class TriggerDefinition(DataType):\n    \"\"\"\n    Defines an expected trigger for a module\n    \"\"\"\n    type: Code = Field(\n        description=\"named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended\",\n        default=None,\n    )\n    type_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for type extensions\",\n        default=None,\n        alias=\"_type\",\n    )\n    name: typing.Optional[String] = Field(\n        description=\"Name or URI that identifies the event\",\n        default=None,\n    )\n    name_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for name extensions\",\n        default=None,\n        alias=\"_name\",\n    )\n    code: typing.Optional[CodeableConcept] = Field(\n        description=\"Coded definition of the event\",\n        default=None,\n    )\n    subscriptionTopic: typing.Optional[Canonical] = Field(\n        description=\"What event\",\n        default=None,\n    )\n    subscriptionTopic_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for subscriptionTopic extensions\",\n        default=None,\n        alias=\"_subscriptionTopic\",\n    )\n    timingTiming: typing.Optional[Timing] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingReference: typing.Optional[Reference] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDate: typing.Optional[Date] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    timingDateTime: typing.Optional[DateTime] = Field(\n        description=\"Timing of the event\",\n        default=None,\n    )\n    data: typing.Optional[typing.List[DataRequirement]] = Field(\n        description=\"Triggering data of the event (multiple = \\u0027and\\u0027)\",\n        default=None,\n    )\n    condition: typing.Optional[Expression] = Field(\n        description=\"Whether the event triggers (boolean expression)\",\n        default=None,\n    )\n    @field_validator(*('condition', 'data', 'subscriptionTopic', 'code', 'name', 'type', 'extension', 'extension', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def timing_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Timing, Reference, Date, DateTime],\n            field_name_base=\"timing\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"data.empty() or timing.empty()\",\n            human=\"Either timing, or a data requirement, but not both\",\n            key=\"trd-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_2_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"condition.exists() implies data.exists()\",\n            human=\"A condition only if there is a data requirement\",\n            key=\"trd-2\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_trd_3_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"(type = 'named-event' implies name.exists()) and (type = 'periodic' implies timing.exists()) and (type.startsWith('data-') implies data.exists())\",\n            human=\"A named event requires a name, a periodic event requires timing, and a data event requires data\",\n            key=\"trd-3\",\n            severity=\"error\",\n        )\n\n    @property \n    def timing(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"timing\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.UsageContext","title":"<code>UsageContext</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Describes the context of use for a conformance or knowledge resource</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class UsageContext(DataType):\n    \"\"\"\n    Describes the context of use for a conformance or knowledge resource\n    \"\"\"\n    code: Coding = Field(\n        description=\"Type of context being specified\",\n        default=None,\n    )\n    valueCodeableConcept: CodeableConcept = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueQuantity: Quantity = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueRange: Range = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    valueReference: Reference = Field(\n        description=\"Value that defines the context\",\n        default=None,\n    )\n    @field_validator(*('code', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def value_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[CodeableConcept, Quantity, Range, Reference],\n            field_name_base=\"value\",\n        )\n\n    @property \n    def value(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"value\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.VirtualServiceDetail","title":"<code>VirtualServiceDetail</code>","text":"<p>               Bases: <code>DataType</code></p> <p>Virtual Service Contact Details</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class VirtualServiceDetail(DataType):\n    \"\"\"\n    Virtual Service Contact Details\n    \"\"\"\n    channelType: typing.Optional[Coding] = Field(\n        description=\"Channel Type\",\n        default=None,\n    )\n    addressUrl: typing.Optional[Url] = Field(\n        description=\"Contact address/number\",\n        default=None,\n    )\n    addressString: typing.Optional[String] = Field(\n        description=\"Contact address/number\",\n        default=None,\n    )\n    addressContactPoint: typing.Optional[ContactPoint] = Field(\n        description=\"Contact address/number\",\n        default=None,\n    )\n    addressExtendedContactDetail: typing.Optional['ExtendedContactDetail'] = Field(\n        description=\"Contact address/number\",\n        default=None,\n    )\n    additionalInfo: typing.Optional[typing.List[Url]] = Field(\n        description=\"Address to see alternative connection details\",\n        default=None,\n    )\n    additionalInfo_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for additionalInfo extensions\",\n        default=None,\n        alias=\"_additionalInfo\",\n    )\n    maxParticipants: typing.Optional[PositiveInt] = Field(\n        description=\"Maximum number of participants supported by the virtual service\",\n        default=None,\n    )\n    maxParticipants_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for maxParticipants extensions\",\n        default=None,\n        alias=\"_maxParticipants\",\n    )\n    sessionKey: typing.Optional[String] = Field(\n        description=\"Session Key required by the virtual service\",\n        default=None,\n    )\n    sessionKey_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for sessionKey extensions\",\n        default=None,\n        alias=\"_sessionKey\",\n    )\n    @field_validator(*('sessionKey', 'maxParticipants', 'additionalInfo', 'channelType', 'extension', 'extension', 'extension', 'extension'), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def address_type_choice_validator(self):\n        return fhir_validators.validate_type_choice_element( \n            self,\n            field_types=[Url, String, ContactPoint, 'ExtendedContactDetail'],\n            field_name_base=\"address\",\n        )\n\n    @property \n    def address(self):\n        return fhir_validators.get_type_choice_value_by_base(self, \n            base=\"address\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/datatypes/R5/complex_types/#fhircraft.fhir.resources.datatypes.R5.complex_types.xhtml","title":"<code>xhtml</code>","text":"<p>               Bases: <code>Element</code></p> <p>Primitive Type xhtml</p> Source code in <code>fhircraft/fhir/resources/datatypes/R5/complex_types.py</code> <pre><code>class xhtml(Element):\n    \"\"\"\n    Primitive Type xhtml\n    \"\"\"\n    value: String = Field(\n        description=\"Actual xhtml\",\n        default=None,\n    )\n    value_ext: typing.Optional[\"Element\"] = Field(\n        description=\"Placeholder element for value extensions\",\n        default=None,\n        alias=\"_value\",\n    )\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ele_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n\n    @field_validator(*('extension',), mode=\"after\", check_fields=None)\n    @classmethod\n    def FHIR_ext_1_constraint_validator(cls, value):\n        return fhir_validators.validate_element_constraint(cls, value, \n            expression=\"extension.exists() != value.exists()\",\n            human=\"Must have either extensions or value[x], not both\",\n            key=\"ext-1\",\n            severity=\"error\",\n        )\n\n    @model_validator(mode=\"after\")\n    def FHIR_ele_1_constraint_model_validator(self):\n        return fhir_validators.validate_model_constraint( \n            self,\n            expression=\"hasValue() or (children().count() &gt; id.count())\",\n            human=\"All FHIR elements must have a @value or children\",\n            key=\"ele-1\",\n            severity=\"error\",\n        )\n</code></pre>"},{"location":"reference/fhircraft/fhir/resources/definitions/generate_datatypes/","title":"Generate datatypes","text":""},{"location":"user-guide/fhir-resources/","title":"Pydantic FHIR models","text":""},{"location":"user-guide/fhir-resources/#constructing-fhir-pydantic-models","title":"Constructing FHIR Pydantic models","text":"<p>To generate a Pydantic model representation for a FHIR resource, use the <code>construct_resource_model</code> function. This function automatically creates a model based on the structure definition of the specified resource or profile.</p> <p>Snapshot required</p> <p>Fhircraft requires the resource's structure definition to be in <code>snapshot</code> form. Models cannot be constructed from definitions that only include a <code>differential</code>. If the <code>snapshot</code> attribute is missing, Fhircraft will raise an error.</p> <p>FHIR versions</p> <p>Fhircraft automatically handles differences between official FHIR releases. It uses the appropriate complex types based on the FHIR version specified in the resource's structure definition, ensuring that the constructed model conforms to the correct release.</p>"},{"location":"user-guide/fhir-resources/#via-local-files-recommended","title":"Via local files (recommended)","text":"<p>For optimal control and security, it is recommended to manage FHIR structure definitions as local files. These files should be loaded into Python and parsed into dictionary objects.</p> <p>Loading utilities</p> <p>Fhircraft provides utility functions to load JSON or YAML files (XML currently not supported) into Python dictionaries. </p> <pre><code>    from fhircraft.utils import load_file\n    structure_definition = load_file('fhir/patient_r4b_structuredefinition.json') \n</code></pre> <p>The <code>construct_resource_model</code> function takes this dictionary containing the FHIR structure definition and constructs the corresponding model.</p> <pre><code>from fhircraft.fhir.resources.factory import construct_resource_model\nresource_model = construct_resource_model(structure_definition=structure_definition)\n</code></pre>"},{"location":"user-guide/fhir-resources/#via-canonical-url","title":"Via canonical URL","text":"<p>A canonical URL is a globally unique identifier for FHIR conformance resources. Fhircraft includes a limited canonical URL resolver that can locate and download a FHIR resource's structure definition via HTTP.</p> <pre><code>from fhircraft.fhir.resources.factory import construct_resource_model\nresource_model = construct_resource_model(canonical_url=url)\n</code></pre> <p>Release version</p> <p>Most canonical URLs will resolve to the latest normative release of the FHIR resource.</p>"},{"location":"user-guide/fhir-resources/#cached-models","title":"Cached models","text":"<p>Fhircraft caches the model created based on the structure definition of FHIR resource. Subsequent calls to <code>construct_resource_model</code> will not trigger any model constructer and will instead return the cached model.  The cache can be reset by simply calling: <pre><code>from fhircraft.fhir.resources.factory import clear_cache\nclear_cache()\n</code></pre></p>"},{"location":"user-guide/fhir-resources/#pydantic-representation","title":"Pydantic representation","text":""},{"location":"user-guide/fhir-resources/#data-types","title":"Data types","text":"<p>Fhircraft introduces a set of data types that align with the FHIR data type classification. These types serve as foundational elements for constructing Pydantic models that accurately reflect FHIR specifications. While rooted in primitive Python types, these Fhircraft data types maintain the FHIR flavor, ensuring that models are both Pythonic and compatible with other Pydantic models. The classification of data types into primitive and complex categories mirrors FHIR\u2019s own structure, representing the fundamental components used to define FHIR resources.</p>"},{"location":"user-guide/fhir-resources/#primitive-types","title":"Primitive Types","text":"<p>Primitive types are the most fundamental data types in FHIR, representing simple values that cannot be subdivided further. In Fhircraft, all FHIR primitive types are represented as parametrized type aliases (<code>TypeAliasType</code>) in Python. This representation is consistent across all FHIR releases. </p> <p>All primitive types can be handled as strings and are parsed using appropriate regular expressions to ensure accurate formatting and conversion to more Pythonic types. This approach ensures that data adheres to FHIR specifications while remaining integrated with Python's type system.</p> FHIR Primitive Fhircraft Primitive Python types Regex boolean <code>Boolean</code> <code>bool</code>, <code>str</code> <code>true|false</code> integer <code>Integer</code> <code>int</code>, <code>str</code> <code>[0]|[-+]?[1-9][0-9]*</code> integer64 <code>Integer64</code> <code>int</code>, <code>str</code> <code>[0]|[-+]?[1-9][0-9]*</code> string <code>String</code> <code>str</code> decimal <code>Decimal</code> <code>float</code>, <code>str</code> <code>-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][+-]?[0-9]+)?</code> uri <code>Uri</code> <code>str</code> <code>\\S*</code> url <code>Url</code> <code>str</code> canonical <code>Canonical</code> <code>str</code> base64Binary <code>Base64Binary</code> <code>str</code> <code>(\\s*([0-9a-zA-Z\\+\\=]){4}\\s*)+</code> instant <code>Instant</code> <code>str</code> <code>([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\\\\.[0-9]+)?(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?</code> date <code>Date</code> <code>str</code> <code>([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?</code> time <code>Time</code> <code>str</code> <code>([01][0-9]|2[0-3])(:[0-5][0-9](:([0-5][0-9]|60)(\\\\.[0-9]+)?(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)?)?</code> datetime <code>DateTime</code> <code>str</code> <code>([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1]))?)?(T([01][0-9]|2[0-3])(:[0-5][0-9](:([0-5][0-9]|60)(\\\\.[0-9]+)?(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)?)?)?</code> code <code>Code</code> <code>str</code> <code>[^\\s]+(\\s[^\\s]+)*</code> oid <code>Oid</code> <code>str</code> <code>urn:oid:[0-2](\\.(0|[1-9][0-9]*))+</code> id <code>Id</code> <code>str</code> <code>[A-Za-z0-9\\-\\.]{1,64}</code> markdown <code>Markdown</code> <code>str</code> <code>\\s*(\\S|\\s)*</code> unsignedInt <code>UnsignedInt</code> <code>int</code>,<code>str</code> <code>[0]|([1-9][0-9]*)</code> positiveInt <code>PositiveInt</code> <code>int</code>,<code>str</code> <code>\\+?[1-9][0-9]*</code> uuid <code>Uuid</code> <code>str</code> ``"},{"location":"user-guide/fhir-resources/#complex-types","title":"Complex Types","text":"<p>Complex types, are composed of multiple elements, each of which can be either primitive or other complex types. They are used to represent more sophisticated data structures. In Fhircraft all FHIR complex types are represented as built-in Pydantic models, which are auto-generated from their respective FHIR structure definitions. Each complex type includes all fields specified in the release-specific FHIR definitions and incorporates validators to enforce FHIR constraints.</p> <p>To import a complex type for a specific FHIR release, use the <code>get_complex_FHIR_type</code> utility function. For example, to import the <code>CodeableConcept</code> complex type from the FHIR R4B release:</p> <pre><code>from fhircraft.fhir.resources.datatypes import get_complex_FHIR_type\nCodeableConcept = get_complex_FHIR_type('CodeableConcept', release='R4B')\n</code></pre> <p>For a comprehensive list of Fhircraft's complex data types and additional details, please refer to the Fhircraft FHIR-release-specific documentation:</p> <ul> <li>FHIR Release R4 complex types</li> <li>FHIR Release R4B complex types</li> <li>FHIR Release R5 complex types</li> </ul>"},{"location":"user-guide/fhir-resources/#fhir-resources","title":"FHIR resources","text":"<p>Each FHIR resource (be it a core resource, complex type, or profiled resource) is represented as a Pydantic <code>FHIRBaseModel</code> with the following structure:</p> <pre><code>class &lt;ResourceName&gt;(FHIRBaseModel):\n\n    &lt;FhirElementName&gt;: &lt;FhirType&gt; = Field(&lt;defaultValue&gt;)\n\n    def &lt;validationName&gt;(self):\n        &lt;FhirValidationFcn&gt;\n</code></pre> <p>For example, for a fictional simplified FHIR resource <code>mycustomresource.json</code></p> mycustomresource.json<pre><code>{\n  \"resourceType\": \"StructureDefinition\",\n  \"id\": \"myresource\",\n  \"url\": \"http://example.org/fhir/StructureDefinition/mycustomresource\",\n  \"name\": \"MyResource\",\n  \"status\": \"draft\",\n  \"kind\": \"resource\",\n  \"abstract\": false,\n  \"type\": \"DomainResource\",\n  \"baseDefinition\": \"http://hl7.org/fhir/StructureDefinition/DomainResource\",\n  \"derivation\": \"constraint\",\n  \"snapshot\": {\n    \"element\": [\n      {\n        \"id\": \"MyResource\",\n        \"path\": \"MyResource\",\n        \"short\": \"A custom resource for demonstration\",\n        \"definition\": \"A custom resource with a single example element.\",\n        \"min\": 0,\n        \"max\": \"*\"\n      },\n      {\n        \"id\": \"MyResource.exampleElement\",\n        \"path\": \"MyResource.exampleElement\",\n        \"short\": \"An example element\",\n        \"definition\": \"An example element of type string.\",\n        \"min\": 1,\n        \"max\": \"1\",\n        \"type\": [\n          {\n            \"code\": \"string\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>constructing a Pydantic FHIR model via </p> <pre><code>from fhircraft.fhir.resources.factory import construct_resource_model\nfrom fhircraft.fhir.utils import load_file\nmycustomresource_model = construct_resource_model(structure_definition=load_file('mycustomresource.json'))\n</code></pre> <p>will result in a model that could be manually specified using the following code: </p> <pre><code>from fhircraft.fhir.resources.base import FHIRBaseModel \nfrom fhircraft.fhir.resources.datatypes.primitives import String \n\nclass MyResource(FHIRBaseModel):\n\n    exampleElement: String = Field(description=\"An example element\")\n</code></pre>"},{"location":"user-guide/fhir-resources/#fhir-elements","title":"FHIR elements","text":"<p>The following section will describe how Fhircraft represents certain aspects of FHIR resource elements. This is purely informative, as Fhircraft automatically accounts for all rules and representation described here when constructing models. </p>"},{"location":"user-guide/fhir-resources/#cardinality","title":"Cardinality","text":"<p>The cardinality of an element determines the field's characteristics in the Pydantic model, such as whether it should be optional, required, or a list. Specifically: - A minimal cardinality of 0 indicates that the field is optional. - A maximal cardinality greater than 1 signifies that the field should be represented as a list.</p> <p>The following table demonstrates how cardinality affects type annotations for an element of type <code>Coding</code>: </p> FHIR type Min. cardinality Max. cardinality Field type <code>Coding</code> <code>1</code> <code>1</code> <code>Coding</code> <code>Coding</code> <code>0</code> <code>1</code> <code>Optional[Coding]</code> <code>Coding</code> <code>1</code> <code>*</code> <code>List[Coding]</code> <code>Coding</code> <code>0</code> <code>*</code> <code>Optional[List[Coding]]</code>"},{"location":"user-guide/fhir-resources/#backbone-elements","title":"Backbone elements","text":"<p>Backbone elements represent reusable groups of elements that can be shared across different resources or used multiple times within a resource to provide hierarchical structure. These elements are modeled using the FHIR complex type <code>BackboneElement</code>. </p> <p>In Fhircraft, backbone elements are represented as individual Pydantic models. These models include the structure and fields defined by the <code>BackboneElement</code> type. The model is then referenced by the original resource, preserving the hierarchical structure in the Pydantic model.</p> <p>For example, the <code>Observation.component</code> element of the <code>Observation</code> FHIR resource is a <code>BackboneElement</code>. In Fhircraft, this would be represented as follows:</p> <pre><code>class ObservationComponent(BackboneElement):\n    ...\n\nclass Observation(FHIRBaseModel):\n    ...\n    component = Optional[List[ObservationComponent]] = Field(...)\n</code></pre>"},{"location":"user-guide/fhir-resources/#slicing","title":"Slicing","text":"<p>Slicing in FHIR is a mechanism that allows for the differentiation and specialization of repeated elements within a resource. It's used when a single element or field in a resource can have multiple subtypes or variations that need to be distinguished from one another based on certain criteria. Slicing is often applied in profiles and extensions to enforce specific constraints and rules on these repeated elements.</p> <p>Note</p> <p>Slicing is only applicable to elements that are allowed to repeat.</p> <p>Each \"slice\" represents a distinct subset or variation of the repeated element that meets specific criteria defined by the discriminators. Slices allow the same element to be used in different ways within the same resource.  Fhircraft represents each slice as an independent model, based on <code>FHIRSliceModel</code>, with its own fields and constraints, and representing the profiled structure of the slice. </p> <p>The sliced element can accept any value that matches any of the slices or the original element. This is achieved via an ordered <code>Union</code> of the slices and the original element type. </p> <p>For example, for an <code>Observation.component</code> element in the profile <code>ProfiledObservation</code> that has been sliced into the slices - <code>'string-component'</code>: An <code>Observation.component</code> where <code>Observation.component.value</code> only accepts <code>str</code> - <code>'integer-component'</code>: An <code>Observation.component</code> where <code>Observation.component.value</code> only accepts <code>int</code>  from which Fhircraft will automatically generate the following model structure:</p> <pre><code>class ObservationComponent(BackboneElement):\n    ...\n    valueString: str = Field(...)\n    valueInteger: int = Field(...)\n\nclass StringComponent(FHIRSliceModel):\n    ...\n    valueString: str = Field(...)\n\nclass IntegerComponent(FHIRSliceModel):\n    ...    \n    valueInteger: str = Field(...)\n\nclass ProfiledObservation(FHIRBaseModel):\n    ...\n    component = Optional[List[\n        Annotated[\n            Union[StringComponent, IntegerComponent, ObservationComponent],\n            Field(union_mode='left_to_right')\n        ]\n    ]] = Field(...)\n</code></pre> <p>Thanks to the use of <code>union_mode='left_to_right'</code>, when a value is assigned to a sliced element (<code>component</code>), the model will first try to instanciate the individual slice models (based on their individual validation criteria) and otherwise use the original model to store the data. For example</p> <pre><code>myobs = ProfiledObservation(component=[\n        {\n            ...\n            valueInteger=5,\n        }, {\n            ...\n            valueString='value,\n        }\n    ],\n    ...\n)\ntype(myobs.component[0])\n# IntegerComponent\ntype(myobs.component[1])\n# StringComponent\n</code></pre> <p>FHIR profiles can also enforce individual cardinality rules on the slices. Fhircraft accounts for these via model validators that ensure that the correct number of slices of each type are present in the model. </p> <p>The elements in the model that contain slices can be examined by calling the <code>get_sliced_elements</code> class method on the model.</p> <pre><code>&gt;&gt;&gt;ProfiledObservation.get_sliced_elements()\n{'component': [StringComponent, IntegerComponent]}\n</code></pre>"},{"location":"user-guide/fhir-resources/#type-choice-elements","title":"Type-choice elements","text":"<p>In FHIR, choice-type elements are named using the pattern <code>&lt;elementName&gt;[x]</code>, where <code>[x]</code> indicates that the element can be of multiple types. Fhircraft represents each allowed type by creating a separate field, replacing <code>[x]</code> with the specific type name.  For example, a FHIR element <code>value[x]</code> that allows either <code>str</code> or <code>int</code> values would be represented by two Pydantic fields:  <code>valueString</code> and <code>valueInteger</code>.</p> <p>Only one type can be chosen at a time for a choice-type element, meaning that you cannot assign multiple types to the same element in a single instance of a resource. Fhircraft enforces this constraint through validation, ensuring that only one of the fields representing the different types has a value.</p> <p>For example, the <code>Observation.effective[x]</code> element of the <code>Observation</code> FHIR resource is a type choice value that accepts a value of the one of the types <code>Date</code>, <code>DateTime</code>, <code>Instant</code>, or <code>Timing</code>. In Fhircraft, this would be represented as follows:</p> <pre><code>class Observation(FHIRBaseModel):\n    ...\n    effectiveDateTime = Optional[DateTime] = Field(...)\n    effectiveDate = Optional[Date] = Field(...)\n    effectiveInstant = Optional[Instant] = Field(...)\n    effectiveTiming = Optional[Timing] = Field(...)\n\n   @model_validator(mode=\"after\")\n    def effective_type_choice_validator(self):\n        ...\n</code></pre> <p>Additionally, if the chosen type for an instance is not known, you can access the value via a property  <code>&lt;elementName&gt;</code> (without the <code>[x]</code>) that returns the value of the type that has been set.</p> <pre><code>&gt;&gt;&gt; obs = Observation(effectiveDate='01/01/2000')\n&gt;&gt;&gt; obs.effective\n'01/01/2000'\n</code></pre>"},{"location":"user-guide/fhir-resources/#primitive-extensions","title":"Primitive extensions","text":"<p>FHIR allows for extensions and IDs to be added even to primitive data types to enable the representation of additional information or to capture data that isn't part of the core specification.</p> <p>When a primitive data type in FHIR has an extension (or ID), these are not applied directly to the primitive value itself. Instead, the primitive type is wrapped in a structure that allows for the inclusion of both the original value and any associated extensions or IDs. </p> <p>To account for this extensibility of primitive values, for each primitive-type field <code>&lt;fieldName&gt;</code> in a model , Fhircraft creates an additional field <code>&lt;fieldName&gt;_ext</code> of type <code>Element</code> that containts the <code>id</code> and <code>extension</code> fields for that primitive value. </p> <p>For example, for the <code>Observation.status</code> field of the <code>Observation</code> resource, Fhircraft generates a model that can be represented as <pre><code>class Observation(FHIRBaseModel):\n    ...\n    status: Code = Field(...)\n    status_ext: Element = Field(...)\n</code></pre> where any extensions for <code>status</code> can be added to <code>status_ext.extension</code>. </p>"},{"location":"user-guide/fhir-resources/#invariant-constraints","title":"Invariant constraints","text":"<p>Invariant constraints are logical expressions that specify conditions that must be met for the data to be considered valid. These constraints often involve relationships between different elements within a resource and are crucial for maintaining the integrity of FHIR data, ensuring that resources adhere to expected standards.</p> <p>In Fhircraft, invariant constraints are typically expressed using FHIRPath, a specialized expression language for querying and validating FHIR data. Fhircraft processes these constraints into Pydantic field or model validators that leverage its built-in FHIRPath engine to perform the necessary validation.</p> <p>If a resource violates an invariant constraint, the Fhircraft model will raise a <code>ValidationError</code>, indicating that the resource does not conform to the FHIR specification. The <code>ValidationError</code> will reference invariant's identifier as well as the evaluated FHIRPath expression, for reference.</p> <p>For example, if a <code>Quantity</code> resource is specified with unit <code>code</code> but without its coding <code>system</code>, the invariant <code>[qty-3]</code> will violated and the validation fails:</p> <pre><code>from fhircraft.fhir.resources.datatypes.R5.complex_types import Quantity\nweight = Quantity(value=10, unit='miligrams', code='mg')\n# ValidationError: 1 validation error for Quantity\n#    If a code for the unit is present, the system SHALL also be present. \n#    [qty-3] -&gt; \"code.empty() or system.exists()\"\n</code></pre>"},{"location":"user-guide/fhir-resources/#fixed-values-pattern-constraints","title":"Fixed values &amp; Pattern constraints","text":"<p>Warning</p> <p>Under construction, TBA</p>"},{"location":"user-guide/fhirpath/","title":"FHIRPath","text":"<p>FHIRPath is a path-based navigation and extraction language, similar to XPath. It is designed to operate on hierarchical data models, enabling operations such as traversal, selection, and filtering of data. FHIRPath is particularly suited to the healthcare domain, where it is used extensively with HL7 Fast Healthcare Interoperability Resources (FHIR). The language's design was heavily influenced by the need to navigate paths, select specific data points, and formulate invariants within FHIR data models.</p> <p>Fhircraft provides a fully compliant FHIRPath engine that adheres to the FHIRPath Normative Release v2.0.0 (ANSI/HL7 NMN R1-2020). This engine allows users to parse and evaluate FHIRPath expressions against FHIR data structures.</p>"},{"location":"user-guide/fhirpath/#basics","title":"Basics","text":""},{"location":"user-guide/fhirpath/#fhirpath-expressions","title":"FHIRPath expressions","text":"<p>The Fhircraft FHIRPath engine can be accessed through the <code>fhircraft.fhir.path module</code>, where an initialized instance is available as <code>fhirpath</code>. This engine provides a <code>parse</code> method, which is used to convert string-based FHIRPath expressions into their corresponding Python representations.</p> <pre><code>from fhircraft.fhir.path import fhirpath \nexpression = fhirpath.parse('Observation.value.unit')\n</code></pre> <p>The <code>expression</code> object represents the parsed FHIRPath expression in Python, which can then be used to evaluate the expression against FHIR-compliant Python objects.</p> <p>Info</p> <p>For a comprehensive guide on constructing FHIRPath expressions, refer to the official FHIRPath documentation. </p> <p>FHIRPath expressions operate on collections, meaning that the result of every expression is a collection\u2014even when the expression yields a single element. This design simplifies path specification by abstracting away the need to consider the cardinality of individual elements, making it particularly well-suited for traversing graph-like structures. To evaluate a parsed expression and retrieve the value(s) from a FHIR object, you can use the  <code>get_value</code> method.</p> <pre><code>value_unit = expression.get_value(my_observation)\n</code></pre> <p>This method will execute the FHIRPath expression against the provided FHIR object and return the corresponding collection of values.</p>"},{"location":"user-guide/fhirpath/#advanced-usage","title":"Advanced Usage","text":"<p>Warning</p> <p>Under construction, TBA</p>"}]}